{"version":3,"sources":["../src/index.ts","../src/generate-text/generate-text.ts","../src/error/index.ts","../src/error/invalid-argument-error.ts","../src/error/invalid-stream-part-error.ts","../src/error/invalid-tool-approval-error.ts","../src/error/invalid-tool-input-error.ts","../src/error/tool-call-not-found-for-approval-error.ts","../src/error/no-image-generated-error.ts","../src/error/no-object-generated-error.ts","../src/error/no-output-generated-error.ts","../src/error/no-speech-generated-error.ts","../src/error/no-such-tool-error.ts","../src/error/tool-call-repair-error.ts","../src/error/unsupported-model-version-error.ts","../src/prompt/invalid-data-content-error.ts","../src/prompt/invalid-message-role-error.ts","../src/prompt/message-conversion-error.ts","../src/util/retry-error.ts","../src/logger/log-warnings.ts","../src/model/resolve-model.ts","../src/util/log-v2-compatibility-warning.ts","../src/model/as-embedding-model-v3.ts","../src/model/as-image-model-v3.ts","../src/model/as-language-model-v3.ts","../src/model/as-speech-model-v3.ts","../src/model/as-transcription-model-v3.ts","../src/prompt/convert-to-language-model-prompt.ts","../src/util/detect-media-type.ts","../src/util/download/download.ts","../src/version.ts","../src/util/download/download-function.ts","../src/prompt/data-content.ts","../src/prompt/split-data-url.ts","../src/util/as-array.ts","../src/prompt/create-tool-model-output.ts","../src/prompt/prepare-call-settings.ts","../src/prompt/prepare-tools-and-tool-choice.ts","../src/util/is-non-empty-object.ts","../src/prompt/standardize-prompt.ts","../src/prompt/message.ts","../src/types/provider-metadata.ts","../src/types/json-value.ts","../src/prompt/content-part.ts","../src/prompt/wrap-gateway-error.ts","../src/telemetry/assemble-operation-name.ts","../src/telemetry/get-base-telemetry-attributes.ts","../src/telemetry/get-tracer.ts","../src/telemetry/noop-tracer.ts","../src/telemetry/record-span.ts","../src/telemetry/select-telemetry-attributes.ts","../src/telemetry/stringify-for-telemetry.ts","../src/types/usage.ts","../src/util/merge-objects.ts","../src/util/retry-with-exponential-backoff.ts","../src/util/prepare-retries.ts","../src/generate-text/collect-tool-approvals.ts","../src/generate-text/execute-tool-call.ts","../src/generate-text/extract-text-content.ts","../src/generate-text/generated-file.ts","../src/generate-text/is-approval-needed.ts","../src/generate-text/output.ts","../src/util/parse-partial-json.ts","../src/util/fix-json.ts","../src/generate-text/parse-tool-call.ts","../src/generate-text/step-result.ts","../src/generate-text/stop-condition.ts","../src/generate-text/to-response-messages.ts","../src/generate-text/stream-text.ts","../src/util/prepare-headers.ts","../src/text-stream/create-text-stream-response.ts","../src/util/write-to-server-response.ts","../src/text-stream/pipe-text-stream-to-response.ts","../src/ui-message-stream/json-to-sse-transform-stream.ts","../src/ui-message-stream/ui-message-stream-headers.ts","../src/ui-message-stream/create-ui-message-stream-response.ts","../src/ui-message-stream/get-response-ui-message-id.ts","../src/ui/process-ui-message-stream.ts","../src/ui-message-stream/ui-message-chunks.ts","../src/ui/ui-messages.ts","../src/ui-message-stream/handle-ui-message-stream-finish.ts","../src/ui-message-stream/pipe-ui-message-stream-to-response.ts","../src/util/async-iterable-stream.ts","../src/util/consume-stream.ts","../src/util/create-resolvable-promise.ts","../src/util/create-stitchable-stream.ts","../src/util/now.ts","../src/generate-text/run-tools-transformation.ts","../src/agent/tool-loop-agent.ts","../src/ui-message-stream/create-ui-message-stream.ts","../src/ui-message-stream/read-ui-message-stream.ts","../src/ui/convert-to-model-messages.ts","../src/ui/validate-ui-messages.ts","../src/agent/create-agent-ui-stream.ts","../src/agent/create-agent-ui-stream-response.ts","../src/agent/pipe-agent-ui-stream-to-response.ts","../src/embed/embed.ts","../src/embed/embed-many.ts","../src/util/split-array.ts","../src/generate-image/generate-image.ts","../src/generate-image/index.ts","../src/generate-object/generate-object.ts","../src/generate-text/extract-reasoning-content.ts","../src/generate-object/output-strategy.ts","../src/generate-object/parse-and-validate-object-result.ts","../src/generate-object/validate-object-generation-input.ts","../src/generate-object/stream-object.ts","../src/util/cosine-similarity.ts","../src/util/data-url.ts","../src/util/is-deep-equal-data.ts","../src/util/serial-job-executor.ts","../src/util/simulate-readable-stream.ts","../src/generate-speech/generate-speech.ts","../src/generate-speech/generated-audio-file.ts","../src/generate-text/prune-messages.ts","../src/generate-text/smooth-stream.ts","../src/middleware/default-embedding-settings-middleware.ts","../src/middleware/default-settings-middleware.ts","../src/util/get-potential-start-index.ts","../src/middleware/extract-reasoning-middleware.ts","../src/middleware/simulate-streaming-middleware.ts","../src/middleware/add-tool-input-examples-middleware.ts","../src/middleware/wrap-language-model.ts","../src/middleware/wrap-embedding-model.ts","../src/model/as-provider-v3.ts","../src/middleware/wrap-provider.ts","../src/registry/custom-provider.ts","../src/registry/no-such-provider-error.ts","../src/registry/provider-registry.ts","../src/rerank/rerank.ts","../src/transcribe/transcribe.ts","../src/error/no-transcript-generated-error.ts","../src/ui/call-completion-api.ts","../src/ui/process-text-stream.ts","../src/ui/chat.ts","../src/ui/convert-file-list-to-file-ui-parts.ts","../src/ui/default-chat-transport.ts","../src/ui/http-chat-transport.ts","../src/ui/last-assistant-message-is-complete-with-approval-responses.ts","../src/ui/last-assistant-message-is-complete-with-tool-calls.ts","../src/ui/transform-text-to-ui-message-stream.ts","../src/ui/text-stream-chat-transport.ts"],"sourcesContent":["// re-exports:\nexport { createGateway, gateway, type GatewayModelId } from '@ai-sdk/gateway';\nexport {\n  asSchema,\n  createIdGenerator,\n  dynamicTool,\n  generateId,\n  jsonSchema,\n  parseJsonEventStream,\n  tool,\n  zodSchema,\n  type FlexibleSchema,\n  type IdGenerator,\n  type InferSchema,\n  type InferToolInput,\n  type InferToolOutput,\n  type Schema,\n  type Tool,\n  type ToolApprovalRequest,\n  type ToolApprovalResponse,\n  type ToolCallOptions,\n  type ToolExecutionOptions,\n  type ToolExecuteFunction,\n} from '@ai-sdk/provider-utils';\n\n// directory exports\nexport * from './agent';\nexport * from './embed';\nexport * from './error';\nexport * from './generate-image';\nexport * from './generate-object';\nexport * from './generate-speech';\nexport * from './generate-text';\nexport * from './logger';\nexport * from './middleware';\nexport * from './prompt';\nexport * from './registry';\nexport * from './rerank';\nexport * from './text-stream';\nexport * from './transcribe';\nexport * from './types';\nexport * from './ui';\nexport * from './ui-message-stream';\nexport * from './util';\n\n// telemetry types:\nexport type { TelemetrySettings } from './telemetry/telemetry-settings';\n\n// import globals\nimport './global';\n","import {\n  LanguageModelV3,\n  LanguageModelV3Content,\n  LanguageModelV3ToolCall,\n} from '@ai-sdk/provider';\nimport {\n  createIdGenerator,\n  getErrorMessage,\n  IdGenerator,\n  ProviderOptions,\n  ToolApprovalResponse,\n  withUserAgentSuffix,\n} from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { NoOutputGeneratedError } from '../error';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveLanguageModel } from '../model/resolve-model';\nimport { ModelMessage } from '../prompt';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { createToolModelOutput } from '../prompt/create-tool-model-output';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { wrapGatewayError } from '../prompt/wrap-gateway-error';\nimport { ToolCallNotFoundForApprovalError } from '../error/tool-call-not-found-for-approval-error';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { stringifyForTelemetry } from '../telemetry/stringify-for-telemetry';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { LanguageModel, ToolChoice } from '../types';\nimport {\n  addLanguageModelUsage,\n  asLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { asArray } from '../util/as-array';\nimport { DownloadFunction } from '../util/download/download-function';\nimport { mergeObjects } from '../util/merge-objects';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { VERSION } from '../version';\nimport { collectToolApprovals } from './collect-tool-approvals';\nimport { ContentPart } from './content-part';\nimport { executeToolCall } from './execute-tool-call';\nimport { extractTextContent } from './extract-text-content';\nimport { GenerateTextResult } from './generate-text-result';\nimport { DefaultGeneratedFile } from './generated-file';\nimport { isApprovalNeeded } from './is-approval-needed';\nimport { Output, text } from './output';\nimport { InferCompleteOutput } from './output-utils';\nimport { parseToolCall } from './parse-tool-call';\nimport { PrepareStepFunction } from './prepare-step';\nimport { ResponseMessage } from './response-message';\nimport { DefaultStepResult, StepResult } from './step-result';\nimport {\n  isStopConditionMet,\n  stepCountIs,\n  StopCondition,\n} from './stop-condition';\nimport { toResponseMessages } from './to-response-messages';\nimport { ToolApprovalRequestOutput } from './tool-approval-request-output';\nimport { TypedToolCall } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair-function';\nimport { TypedToolError } from './tool-error';\nimport { ToolOutput } from './tool-output';\nimport { TypedToolResult } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type GenerateTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type GenerateTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: StepResult<TOOLS> & {\n    /**\n     * Details for all steps.\n     */\n    readonly steps: StepResult<TOOLS>[];\n\n    /**\n     * Total usage for all steps. This is the sum of the usage of all steps.\n     */\n    readonly totalUsage: LanguageModelUsage;\n\n    /**\n     * Context that is passed into tool execution.\n     *\n     * Experimental (can break in patch releases).\n     *\n     * @default undefined\n     */\n    experimental_context: unknown;\n  },\n) => PromiseLike<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamText` instead.\n\n@param model - The language model to use.\n\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n@param toolChoice - The tool choice strategy. Default: 'auto'.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxOutputTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param experimental_generateMessageId - Generate a unique ID for each message.\n\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when all steps are finished and the response is complete.\n\n@returns\nA result object that contains the generated text, the results of the tool calls, and additional information.\n */\nexport async function generateText<\n  TOOLS extends ToolSet,\n  OUTPUT extends Output = Output<string, string>,\n>({\n  model: modelArg,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_prepareStep,\n  prepareStep = experimental_prepareStep,\n  experimental_repairToolCall: repairToolCall,\n  experimental_download: download,\n  experimental_context,\n  _internal: {\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  onStepFinish,\n  onFinish,\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n*/\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<NoInfer<TOOLS>>;\n\n    /**\nCondition for stopping the generation when there are tool results in the last step.\nWhen the condition is an array, any of the conditions can be met to stop the generation.\n\n@default stepCountIs(1)\n     */\n    stopWhen?:\n      | StopCondition<NoInfer<TOOLS>>\n      | Array<StopCondition<NoInfer<TOOLS>>>;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n     * @deprecated Use `activeTools` instead.\n     */\n    experimental_activeTools?: Array<keyof NoInfer<TOOLS>>;\n\n    /**\nLimits the tools that are available for the model to call without\nchanging the tool call and result types in the result.\n     */\n    activeTools?: Array<keyof NoInfer<TOOLS>>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    output?: OUTPUT;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n\n@deprecated Use `output` instead.\n     */\n    experimental_output?: OUTPUT;\n\n    /**\nCustom download function to use for URLs.\n\nBy default, files are downloaded if the model does not support the URL for the given media type.\n     */\n    experimental_download?: DownloadFunction | undefined;\n\n    /**\n     * @deprecated Use `prepareStep` instead.\n     */\n    experimental_prepareStep?: PrepareStepFunction<NoInfer<TOOLS>>;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n    */\n    prepareStep?: PrepareStepFunction<NoInfer<TOOLS>>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<NoInfer<TOOLS>>;\n\n    /**\n     * Callback that is called when each step (LLM call) is finished, including intermediate steps.\n     */\n    onStepFinish?: GenerateTextOnStepFinishCallback<NoInfer<TOOLS>>;\n\n    /**\n     * Callback that is called when all steps are finished and the response is complete.\n     */\n    onFinish?: GenerateTextOnFinishCallback<NoInfer<TOOLS>>;\n\n    /**\n     * Context that is passed into tool execution.\n     *\n     * Experimental (can break in patch releases).\n     *\n     * @default undefined\n     */\n    experimental_context?: unknown;\n\n    /**\n     * Internal. For test use only. May change without notice.\n     */\n    _internal?: {\n      generateId?: IdGenerator;\n      currentDate?: () => Date;\n    };\n  }): Promise<GenerateTextResult<TOOLS, OUTPUT>> {\n  const model = resolveLanguageModel(modelArg);\n  const stopConditions = asArray(stopWhen);\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const callSettings = prepareCallSettings(settings);\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries },\n  });\n\n  const initialPrompt = await standardizePrompt({\n    system,\n    prompt,\n    messages,\n  } as Prompt);\n\n  const tracer = getTracer(telemetry);\n\n  try {\n    return await recordSpan({\n      name: 'ai.generateText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.generateText',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // model:\n          'ai.model.provider': model.provider,\n          'ai.model.id': model.modelId,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n        },\n      }),\n      tracer,\n      fn: async span => {\n        const initialMessages = initialPrompt.messages;\n        const responseMessages: Array<ResponseMessage> = [];\n\n        const { approvedToolApprovals, deniedToolApprovals } =\n          collectToolApprovals<TOOLS>({ messages: initialMessages });\n\n        const localApprovedToolApprovals = approvedToolApprovals.filter(\n          toolApproval => !toolApproval.toolCall.providerExecuted,\n        );\n\n        if (\n          deniedToolApprovals.length > 0 ||\n          localApprovedToolApprovals.length > 0\n        ) {\n          const toolOutputs = await executeTools({\n            toolCalls: localApprovedToolApprovals.map(\n              toolApproval => toolApproval.toolCall,\n            ),\n            tools: tools as TOOLS,\n            tracer,\n            telemetry,\n            messages: initialMessages,\n            abortSignal,\n            experimental_context,\n          });\n\n          const toolContent: Array<any> = [];\n\n          // add regular tool results for approved tool calls:\n          for (const output of toolOutputs) {\n            const modelOutput = await createToolModelOutput({\n              toolCallId: output.toolCallId,\n              input: output.input,\n              tool: tools?.[output.toolName],\n              output:\n                output.type === 'tool-result' ? output.output : output.error,\n              errorMode: output.type === 'tool-error' ? 'json' : 'none',\n            });\n\n            toolContent.push({\n              type: 'tool-result' as const,\n              toolCallId: output.toolCallId,\n              toolName: output.toolName,\n              output: modelOutput,\n            });\n          }\n\n          // add execution denied tool results for all denied tool approvals:\n          for (const toolApproval of deniedToolApprovals) {\n            toolContent.push({\n              type: 'tool-result' as const,\n              toolCallId: toolApproval.toolCall.toolCallId,\n              toolName: toolApproval.toolCall.toolName,\n              output: {\n                type: 'execution-denied' as const,\n                reason: toolApproval.approvalResponse.reason,\n                // For provider-executed tools, include approvalId so provider can correlate\n                ...(toolApproval.toolCall.providerExecuted && {\n                  providerOptions: {\n                    openai: {\n                      approvalId: toolApproval.approvalResponse.approvalId,\n                    },\n                  },\n                }),\n              },\n            });\n          }\n\n          responseMessages.push({\n            role: 'tool',\n            content: toolContent,\n          });\n        }\n\n        // Forward provider-executed approval responses to the provider\n        const providerExecutedToolApprovals = [\n          ...approvedToolApprovals,\n          ...deniedToolApprovals,\n        ].filter(toolApproval => toolApproval.toolCall.providerExecuted);\n\n        if (providerExecutedToolApprovals.length > 0) {\n          responseMessages.push({\n            role: 'tool',\n            content: providerExecutedToolApprovals.map(\n              toolApproval =>\n                ({\n                  type: 'tool-approval-response',\n                  approvalId: toolApproval.approvalResponse.approvalId,\n                  approved: toolApproval.approvalResponse.approved,\n                  reason: toolApproval.approvalResponse.reason,\n                  providerExecuted: true,\n                }) satisfies ToolApprovalResponse,\n            ),\n          });\n        }\n\n        const callSettings = prepareCallSettings(settings);\n\n        let currentModelResponse: Awaited<\n          ReturnType<LanguageModelV3['doGenerate']>\n        > & { response: { id: string; timestamp: Date; modelId: string } };\n        let clientToolCalls: Array<TypedToolCall<TOOLS>> = [];\n        let clientToolOutputs: Array<ToolOutput<TOOLS>> = [];\n        const steps: GenerateTextResult<TOOLS, OUTPUT>['steps'] = [];\n\n        // Track provider-executed tool calls that support deferred results\n        // (e.g., code_execution in programmatic tool calling scenarios).\n        // These tools may not return their results in the same turn as their call.\n        const pendingDeferredToolCalls = new Map<\n          string,\n          { toolName: string }\n        >();\n\n        do {\n          const stepInputMessages = [...initialMessages, ...responseMessages];\n\n          const prepareStepResult = await prepareStep?.({\n            model,\n            steps,\n            stepNumber: steps.length,\n            messages: stepInputMessages,\n            experimental_context,\n          });\n\n          const stepModel = resolveLanguageModel(\n            prepareStepResult?.model ?? model,\n          );\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: prepareStepResult?.system ?? initialPrompt.system,\n              messages: prepareStepResult?.messages ?? stepInputMessages,\n            },\n            supportedUrls: await stepModel.supportedUrls,\n            download,\n          });\n\n          experimental_context =\n            prepareStepResult?.experimental_context ?? experimental_context;\n\n          const { toolChoice: stepToolChoice, tools: stepTools } =\n            await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: prepareStepResult?.toolChoice ?? toolChoice,\n              activeTools: prepareStepResult?.activeTools ?? activeTools,\n            });\n\n          currentModelResponse = await retry(() =>\n            recordSpan({\n              name: 'ai.generateText.doGenerate',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.generateText.doGenerate',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  'ai.model.provider': stepModel.provider,\n                  'ai.model.id': stepModel.modelId,\n                  // prompt:\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => stepTools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      stepToolChoice != null\n                        ? JSON.stringify(stepToolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': stepModel.provider,\n                  'gen_ai.request.model': stepModel.modelId,\n                  'gen_ai.request.frequency_penalty': settings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': settings.maxOutputTokens,\n                  'gen_ai.request.presence_penalty': settings.presencePenalty,\n                  'gen_ai.request.stop_sequences': settings.stopSequences,\n                  'gen_ai.request.temperature':\n                    settings.temperature ?? undefined,\n                  'gen_ai.request.top_k': settings.topK,\n                  'gen_ai.request.top_p': settings.topP,\n                },\n              }),\n              tracer,\n              fn: async span => {\n                const stepProviderOptions = mergeObjects(\n                  providerOptions,\n                  prepareStepResult?.providerOptions,\n                );\n\n                const result = await stepModel.doGenerate({\n                  ...callSettings,\n                  tools: stepTools,\n                  toolChoice: stepToolChoice,\n                  responseFormat: await output?.responseFormat,\n                  prompt: promptMessages,\n                  providerOptions: stepProviderOptions,\n                  abortSignal,\n                  headers: headersWithUserAgent,\n                });\n\n                // Fill in default values:\n                const responseData = {\n                  id: result.response?.id ?? generateId(),\n                  timestamp: result.response?.timestamp ?? currentDate(),\n                  modelId: result.response?.modelId ?? stepModel.modelId,\n                  headers: result.response?.headers,\n                  body: result.response?.body,\n                };\n\n                // Add response information to the span:\n                span.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.response.finishReason': result.finishReason.unified,\n                      'ai.response.text': {\n                        output: () => extractTextContent(result.content),\n                      },\n                      'ai.response.toolCalls': {\n                        output: () => {\n                          const toolCalls = asToolCalls(result.content);\n                          return toolCalls == null\n                            ? undefined\n                            : JSON.stringify(toolCalls);\n                        },\n                      },\n                      'ai.response.id': responseData.id,\n                      'ai.response.model': responseData.modelId,\n                      'ai.response.timestamp':\n                        responseData.timestamp.toISOString(),\n                      'ai.response.providerMetadata': JSON.stringify(\n                        result.providerMetadata,\n                      ),\n\n                      // TODO rename telemetry attributes to inputTokens and outputTokens\n                      'ai.usage.promptTokens': result.usage.inputTokens.total,\n                      'ai.usage.completionTokens':\n                        result.usage.outputTokens.total,\n\n                      // standardized gen-ai llm span attributes:\n                      'gen_ai.response.finish_reasons': [\n                        result.finishReason.unified,\n                      ],\n                      'gen_ai.response.id': responseData.id,\n                      'gen_ai.response.model': responseData.modelId,\n                      'gen_ai.usage.input_tokens':\n                        result.usage.inputTokens.total,\n                      'gen_ai.usage.output_tokens':\n                        result.usage.outputTokens.total,\n                    },\n                  }),\n                );\n\n                return { ...result, response: responseData };\n              },\n            }),\n          );\n\n          // parse tool calls:\n          const stepToolCalls: TypedToolCall<TOOLS>[] = await Promise.all(\n            currentModelResponse.content\n              .filter(\n                (part): part is LanguageModelV3ToolCall =>\n                  part.type === 'tool-call',\n              )\n              .map(toolCall =>\n                parseToolCall({\n                  toolCall,\n                  tools,\n                  repairToolCall,\n                  system,\n                  messages: stepInputMessages,\n                }),\n              ),\n          );\n          const toolApprovalRequests: Record<\n            string,\n            ToolApprovalRequestOutput<TOOLS>\n          > = {};\n\n          // notify the tools that the tool calls are available:\n          for (const toolCall of stepToolCalls) {\n            if (toolCall.invalid) {\n              continue; // ignore invalid tool calls\n            }\n\n            const tool = tools?.[toolCall.toolName];\n\n            if (tool == null) {\n              // ignore tool calls for tools that are not available,\n              // e.g. provider-executed dynamic tools\n              continue;\n            }\n\n            if (tool?.onInputAvailable != null) {\n              await tool.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context,\n              });\n            }\n\n            if (\n              await isApprovalNeeded({\n                tool,\n                toolCall,\n                messages: stepInputMessages,\n                experimental_context,\n              })\n            ) {\n              toolApprovalRequests[toolCall.toolCallId] = {\n                type: 'tool-approval-request',\n                approvalId: generateId(),\n                toolCall,\n              };\n            }\n          }\n\n          // insert error tool outputs for invalid tool calls:\n          // TODO AI SDK 6: invalid inputs should not require output parts\n          const invalidToolCalls = stepToolCalls.filter(\n            toolCall => toolCall.invalid && toolCall.dynamic,\n          );\n\n          clientToolOutputs = [];\n\n          for (const toolCall of invalidToolCalls) {\n            clientToolOutputs.push({\n              type: 'tool-error',\n              toolCallId: toolCall.toolCallId,\n              toolName: toolCall.toolName,\n              input: toolCall.input,\n              error: getErrorMessage(toolCall.error!),\n              dynamic: true,\n            });\n          }\n\n          // execute client tool calls:\n          clientToolCalls = stepToolCalls.filter(\n            toolCall => !toolCall.providerExecuted,\n          );\n\n          if (tools != null) {\n            clientToolOutputs.push(\n              ...(await executeTools({\n                toolCalls: clientToolCalls.filter(\n                  toolCall =>\n                    !toolCall.invalid &&\n                    toolApprovalRequests[toolCall.toolCallId] == null,\n                ),\n                tools,\n                tracer,\n                telemetry,\n                messages: stepInputMessages,\n                abortSignal,\n                experimental_context,\n              })),\n            );\n          }\n\n          // Track provider-executed tool calls that support deferred results.\n          // In programmatic tool calling, a server tool (e.g., code_execution) may\n          // trigger a client tool, and the server tool's result is deferred until\n          // the client tool's result is sent back.\n          for (const toolCall of stepToolCalls) {\n            if (!toolCall.providerExecuted) continue;\n            const tool = tools?.[toolCall.toolName];\n            if (tool?.type === 'provider' && tool.supportsDeferredResults) {\n              // Check if this tool call already has a result in the current response\n              const hasResultInResponse = currentModelResponse.content.some(\n                part =>\n                  part.type === 'tool-result' &&\n                  part.toolCallId === toolCall.toolCallId,\n              );\n              if (!hasResultInResponse) {\n                pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                  toolName: toolCall.toolName,\n                });\n              }\n            }\n          }\n\n          // Mark deferred tool calls as resolved when we receive their results\n          for (const part of currentModelResponse.content) {\n            if (part.type === 'tool-result') {\n              pendingDeferredToolCalls.delete(part.toolCallId);\n            }\n          }\n\n          // content:\n          const stepContent = asContent({\n            content: currentModelResponse.content,\n            toolCalls: stepToolCalls,\n            toolOutputs: clientToolOutputs,\n            toolApprovalRequests: Object.values(toolApprovalRequests),\n            tools,\n          });\n\n          // append to messages for potential next step:\n          responseMessages.push(\n            ...(await toResponseMessages({\n              content: stepContent,\n              tools,\n            })),\n          );\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = new DefaultStepResult({\n            content: stepContent,\n            finishReason: currentModelResponse.finishReason.unified,\n            rawFinishReason: currentModelResponse.finishReason.raw,\n            usage: asLanguageModelUsage(currentModelResponse.usage),\n            warnings: currentModelResponse.warnings,\n            providerMetadata: currentModelResponse.providerMetadata,\n            request: currentModelResponse.request ?? {},\n            response: {\n              ...currentModelResponse.response,\n              // deep clone msgs to avoid mutating past messages in multi-step:\n              messages: structuredClone(responseMessages),\n            },\n          });\n\n          logWarnings({\n            warnings: currentModelResponse.warnings ?? [],\n            provider: stepModel.provider,\n            model: stepModel.modelId,\n          });\n\n          steps.push(currentStepResult);\n          await onStepFinish?.(currentStepResult);\n        } while (\n          // Continue if:\n          // 1. There are client tool calls that have all been executed, OR\n          // 2. There are pending deferred results from provider-executed tools\n          ((clientToolCalls.length > 0 &&\n            clientToolOutputs.length === clientToolCalls.length) ||\n            pendingDeferredToolCalls.size > 0) &&\n          // continue until a stop condition is met:\n          !(await isStopConditionMet({ stopConditions, steps }))\n        );\n\n        // Add response information to the span:\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.response.finishReason':\n                currentModelResponse.finishReason.unified,\n              'ai.response.text': {\n                output: () => extractTextContent(currentModelResponse.content),\n              },\n              'ai.response.toolCalls': {\n                output: () => {\n                  const toolCalls = asToolCalls(currentModelResponse.content);\n                  return toolCalls == null\n                    ? undefined\n                    : JSON.stringify(toolCalls);\n                },\n              },\n              'ai.response.providerMetadata': JSON.stringify(\n                currentModelResponse.providerMetadata,\n              ),\n\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              'ai.usage.promptTokens':\n                currentModelResponse.usage.inputTokens.total,\n              'ai.usage.completionTokens':\n                currentModelResponse.usage.outputTokens.total,\n            },\n          }),\n        );\n\n        const lastStep = steps[steps.length - 1];\n\n        const totalUsage = steps.reduce(\n          (totalUsage, step) => {\n            return addLanguageModelUsage(totalUsage, step.usage);\n          },\n          {\n            inputTokens: undefined,\n            outputTokens: undefined,\n            totalTokens: undefined,\n            reasoningTokens: undefined,\n            cachedInputTokens: undefined,\n          } as LanguageModelUsage,\n        );\n\n        await onFinish?.({\n          finishReason: lastStep.finishReason,\n          rawFinishReason: lastStep.rawFinishReason,\n          usage: lastStep.usage,\n          content: lastStep.content,\n          text: lastStep.text,\n          reasoningText: lastStep.reasoningText,\n          reasoning: lastStep.reasoning,\n          files: lastStep.files,\n          sources: lastStep.sources,\n          toolCalls: lastStep.toolCalls,\n          staticToolCalls: lastStep.staticToolCalls,\n          dynamicToolCalls: lastStep.dynamicToolCalls,\n          toolResults: lastStep.toolResults,\n          staticToolResults: lastStep.staticToolResults,\n          dynamicToolResults: lastStep.dynamicToolResults,\n          request: lastStep.request,\n          response: lastStep.response,\n          warnings: lastStep.warnings,\n          providerMetadata: lastStep.providerMetadata,\n          steps,\n          totalUsage,\n          experimental_context,\n        });\n\n        // parse output only if the last step was finished with \"stop\":\n        let resolvedOutput;\n        if (lastStep.finishReason === 'stop') {\n          const outputSpecification = output ?? text();\n          resolvedOutput = await outputSpecification.parseCompleteOutput(\n            { text: lastStep.text },\n            {\n              response: lastStep.response,\n              usage: lastStep.usage,\n              finishReason: lastStep.finishReason,\n            },\n          );\n        }\n\n        return new DefaultGenerateTextResult({\n          steps,\n          totalUsage,\n          output: resolvedOutput,\n        });\n      },\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\n\nasync function executeTools<TOOLS extends ToolSet>({\n  toolCalls,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context,\n}: {\n  toolCalls: Array<TypedToolCall<TOOLS>>;\n  tools: TOOLS;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: ModelMessage[];\n  abortSignal: AbortSignal | undefined;\n  experimental_context: unknown;\n}): Promise<Array<ToolOutput<TOOLS>>> {\n  const toolOutputs = await Promise.all(\n    toolCalls.map(async toolCall =>\n      executeToolCall({\n        toolCall,\n        tools,\n        tracer,\n        telemetry,\n        messages,\n        abortSignal,\n        experimental_context,\n      }),\n    ),\n  );\n\n  return toolOutputs.filter(\n    (output): output is NonNullable<typeof output> => output != null,\n  );\n}\n\nclass DefaultGenerateTextResult<TOOLS extends ToolSet, OUTPUT extends Output>\n  implements GenerateTextResult<TOOLS, OUTPUT>\n{\n  readonly steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n  readonly totalUsage: LanguageModelUsage;\n  private readonly _output: InferCompleteOutput<OUTPUT> | undefined;\n\n  constructor(options: {\n    steps: GenerateTextResult<TOOLS, OUTPUT>['steps'];\n    output: InferCompleteOutput<OUTPUT> | undefined;\n    totalUsage: LanguageModelUsage;\n  }) {\n    this.steps = options.steps;\n    this._output = options.output;\n    this.totalUsage = options.totalUsage;\n  }\n\n  private get finalStep() {\n    return this.steps[this.steps.length - 1];\n  }\n\n  get content() {\n    return this.finalStep.content;\n  }\n\n  get text() {\n    return this.finalStep.text;\n  }\n\n  get files() {\n    return this.finalStep.files;\n  }\n\n  get reasoningText() {\n    return this.finalStep.reasoningText;\n  }\n\n  get reasoning() {\n    return this.finalStep.reasoning;\n  }\n\n  get toolCalls() {\n    return this.finalStep.toolCalls;\n  }\n\n  get staticToolCalls() {\n    return this.finalStep.staticToolCalls;\n  }\n\n  get dynamicToolCalls() {\n    return this.finalStep.dynamicToolCalls;\n  }\n\n  get toolResults() {\n    return this.finalStep.toolResults;\n  }\n\n  get staticToolResults() {\n    return this.finalStep.staticToolResults;\n  }\n\n  get dynamicToolResults() {\n    return this.finalStep.dynamicToolResults;\n  }\n\n  get sources() {\n    return this.finalStep.sources;\n  }\n\n  get finishReason() {\n    return this.finalStep.finishReason;\n  }\n\n  get rawFinishReason() {\n    return this.finalStep.rawFinishReason;\n  }\n\n  get warnings() {\n    return this.finalStep.warnings;\n  }\n\n  get providerMetadata() {\n    return this.finalStep.providerMetadata;\n  }\n\n  get response() {\n    return this.finalStep.response;\n  }\n\n  get request() {\n    return this.finalStep.request;\n  }\n\n  get usage() {\n    return this.finalStep.usage;\n  }\n\n  get experimental_output() {\n    return this.output;\n  }\n\n  get output() {\n    if (this._output == null) {\n      throw new NoOutputGeneratedError();\n    }\n\n    return this._output;\n  }\n}\n\nfunction asToolCalls(content: Array<LanguageModelV3Content>) {\n  const parts = content.filter(\n    (part): part is LanguageModelV3ToolCall => part.type === 'tool-call',\n  );\n\n  if (parts.length === 0) {\n    return undefined;\n  }\n\n  return parts.map(toolCall => ({\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: toolCall.input,\n  }));\n}\n\nfunction asContent<TOOLS extends ToolSet>({\n  content,\n  toolCalls,\n  toolOutputs,\n  toolApprovalRequests,\n  tools,\n}: {\n  content: Array<LanguageModelV3Content>;\n  toolCalls: Array<TypedToolCall<TOOLS>>;\n  toolOutputs: Array<ToolOutput<TOOLS>>;\n  toolApprovalRequests: Array<ToolApprovalRequestOutput<TOOLS>>;\n  tools: TOOLS | undefined;\n}): Array<ContentPart<TOOLS>> {\n  const contentParts: Array<ContentPart<TOOLS>> = [];\n\n  for (const part of content) {\n    switch (part.type) {\n      case 'text':\n      case 'reasoning':\n      case 'source':\n        contentParts.push(part);\n        break;\n\n      case 'file': {\n        contentParts.push({\n          type: 'file' as const,\n          file: new DefaultGeneratedFile(part),\n          ...(part.providerMetadata != null\n            ? { providerMetadata: part.providerMetadata }\n            : {}),\n        });\n        break;\n      }\n\n      case 'tool-call': {\n        contentParts.push(\n          toolCalls.find(toolCall => toolCall.toolCallId === part.toolCallId)!,\n        );\n        break;\n      }\n\n      case 'tool-result': {\n        const toolCall = toolCalls.find(\n          toolCall => toolCall.toolCallId === part.toolCallId,\n        );\n\n        // Handle deferred results for provider-executed tools (e.g., programmatic tool calling).\n        // When a server tool (like code_execution) triggers a client tool, the server tool's\n        // result may be deferred to a later turn. In this case, there's no matching tool-call\n        // in the current response.\n        if (toolCall == null) {\n          const tool = tools?.[part.toolName];\n          const supportsDeferredResults =\n            tool?.type === 'provider' && tool.supportsDeferredResults;\n\n          if (!supportsDeferredResults) {\n            throw new Error(`Tool call ${part.toolCallId} not found.`);\n          }\n\n          // Create tool result without tool call input (deferred result)\n          if (part.isError) {\n            contentParts.push({\n              type: 'tool-error' as const,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName as keyof TOOLS & string,\n              input: undefined,\n              error: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic,\n            } as TypedToolError<TOOLS>);\n          } else {\n            contentParts.push({\n              type: 'tool-result' as const,\n              toolCallId: part.toolCallId,\n              toolName: part.toolName as keyof TOOLS & string,\n              input: undefined,\n              output: part.result,\n              providerExecuted: true,\n              dynamic: part.dynamic,\n            } as TypedToolResult<TOOLS>);\n          }\n          break;\n        }\n\n        if (part.isError) {\n          contentParts.push({\n            type: 'tool-error' as const,\n            toolCallId: part.toolCallId,\n            toolName: part.toolName as keyof TOOLS & string,\n            input: toolCall.input,\n            error: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic,\n          } as TypedToolError<TOOLS>);\n        } else {\n          contentParts.push({\n            type: 'tool-result' as const,\n            toolCallId: part.toolCallId,\n            toolName: part.toolName as keyof TOOLS & string,\n            input: toolCall.input,\n            output: part.result,\n            providerExecuted: true,\n            dynamic: toolCall.dynamic,\n          } as TypedToolResult<TOOLS>);\n        }\n        break;\n      }\n\n      case 'tool-approval-request': {\n        const toolCall = toolCalls.find(\n          toolCall => toolCall.toolCallId === part.toolCallId,\n        );\n\n        if (toolCall == null) {\n          throw new ToolCallNotFoundForApprovalError({\n            toolCallId: part.toolCallId,\n            approvalId: part.approvalId,\n          });\n        }\n\n        contentParts.push({\n          type: 'tool-approval-request' as const,\n          approvalId: part.approvalId,\n          toolCall,\n        });\n        break;\n      }\n    }\n  }\n\n  return [...contentParts, ...toolOutputs, ...toolApprovalRequests];\n}\n","export {\n  AISDKError,\n  APICallError,\n  EmptyResponseBodyError,\n  InvalidPromptError,\n  InvalidResponseDataError,\n  JSONParseError,\n  LoadAPIKeyError,\n  LoadSettingError,\n  NoContentGeneratedError,\n  NoSuchModelError,\n  TooManyEmbeddingValuesForCallError,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\n\nexport { InvalidArgumentError } from './invalid-argument-error';\nexport { InvalidStreamPartError } from './invalid-stream-part-error';\nexport { InvalidToolApprovalError } from './invalid-tool-approval-error';\nexport { InvalidToolInputError } from './invalid-tool-input-error';\nexport { ToolCallNotFoundForApprovalError } from './tool-call-not-found-for-approval-error';\nexport { NoImageGeneratedError } from './no-image-generated-error';\nexport { NoObjectGeneratedError } from './no-object-generated-error';\nexport { NoOutputGeneratedError } from './no-output-generated-error';\nexport { NoSpeechGeneratedError } from './no-speech-generated-error';\nexport { NoSuchToolError } from './no-such-tool-error';\nexport { ToolCallRepairError } from './tool-call-repair-error';\nexport { UnsupportedModelVersionError } from './unsupported-model-version-error';\n\nexport { InvalidDataContentError } from '../prompt/invalid-data-content-error';\nexport { InvalidMessageRoleError } from '../prompt/invalid-message-role-error';\nexport { MessageConversionError } from '../prompt/message-conversion-error';\nexport { DownloadError } from '@ai-sdk/provider-utils';\nexport { RetryError } from '../util/retry-error';\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { SingleRequestTextStreamPart } from '../generate-text/run-tools-transformation';\n\nconst name = 'AI_InvalidStreamPartError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidStreamPartError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly chunk: SingleRequestTextStreamPart<any>;\n\n  constructor({\n    chunk,\n    message,\n  }: {\n    chunk: SingleRequestTextStreamPart<any>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.chunk = chunk;\n  }\n\n  static isInstance(error: unknown): error is InvalidStreamPartError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolApprovalError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolApprovalError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly approvalId: string;\n\n  constructor({ approvalId }: { approvalId: string }) {\n    super({\n      name,\n      message:\n        `Tool approval response references unknown approvalId: \"${approvalId}\". ` +\n        `No matching tool-approval-request found in message history.`,\n    });\n\n    this.approvalId = approvalId;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolApprovalError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidToolInputError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidToolInputError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly toolInput: string;\n\n  constructor({\n    toolInput,\n    toolName,\n    cause,\n    message = `Invalid input for tool ${toolName}: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    toolInput: string;\n    toolName: string;\n    cause: unknown;\n  }) {\n    super({ name, message, cause });\n\n    this.toolInput = toolInput;\n    this.toolName = toolName;\n  }\n\n  static isInstance(error: unknown): error is InvalidToolInputError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_ToolCallNotFoundForApprovalError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallNotFoundForApprovalError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolCallId: string;\n  readonly approvalId: string;\n\n  constructor({\n    toolCallId,\n    approvalId,\n  }: {\n    toolCallId: string;\n    approvalId: string;\n  }) {\n    super({\n      name,\n      message: `Tool call \"${toolCallId}\" not found for approval request \"${approvalId}\".`,\n    });\n\n    this.toolCallId = toolCallId;\n    this.approvalId = approvalId;\n  }\n\n  static isInstance(error: unknown): error is ToolCallNotFoundForApprovalError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\n\nconst name = 'AI_NoImageGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no image could be generated. This can have multiple causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n */\nexport class NoImageGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\nThe response metadata for each call.\n   */\n  readonly responses: Array<ImageModelResponseMetadata> | undefined;\n\n  constructor({\n    message = 'No image generated.',\n    cause,\n    responses,\n  }: {\n    message?: string;\n    cause?: Error;\n    responses?: Array<ImageModelResponseMetadata>;\n  }) {\n    super({ name, message, cause });\n\n    this.responses = responses;\n  }\n\n  static isInstance(error: unknown): error is NoImageGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { FinishReason } from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\n\nconst name = 'AI_NoObjectGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no object could be generated. This can have several causes:\n\n- The model failed to generate a response.\n- The model generated a response that could not be parsed.\n- The model generated a response that could not be validated against the schema.\n\nThe error contains the following properties:\n\n- `text`: The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n */\nexport class NoObjectGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  /**\n  The text that was generated by the model. This can be the raw text or the tool call text, depending on the model.\n   */\n  readonly text: string | undefined;\n\n  /**\n  The response metadata.\n   */\n  readonly response: LanguageModelResponseMetadata | undefined;\n\n  /**\n  The usage of the model.\n   */\n  readonly usage: LanguageModelUsage | undefined;\n\n  /**\n  Reason why the model finished generating a response.\n   */\n  readonly finishReason: FinishReason | undefined;\n\n  constructor({\n    message = 'No object generated.',\n    cause,\n    text,\n    response,\n    usage,\n    finishReason,\n  }: {\n    message?: string;\n    cause?: Error;\n    text?: string;\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  }) {\n    super({ name, message, cause });\n\n    this.text = text;\n    this.response = response;\n    this.usage = usage;\n    this.finishReason = finishReason;\n  }\n\n  static isInstance(error: unknown): error is NoObjectGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoOutputGeneratedError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\n/**\nThrown when no LLM output was generated, e.g. because of errors.\n */\nexport class NoOutputGeneratedError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  constructor({\n    message = 'No output generated.',\n    cause,\n  }: {\n    message?: string;\n    cause?: Error;\n  } = {}) {\n    super({ name, message, cause });\n  }\n\n  static isInstance(error: unknown): error is NoOutputGeneratedError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\n\n/**\nError that is thrown when no speech audio was generated.\n */\nexport class NoSpeechGeneratedError extends AISDKError {\n  readonly responses: Array<SpeechModelResponseMetadata>;\n\n  constructor(options: { responses: Array<SpeechModelResponseMetadata> }) {\n    super({\n      name: 'AI_NoSpeechGeneratedError',\n      message: 'No speech audio generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchToolError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchToolError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly toolName: string;\n  readonly availableTools: string[] | undefined;\n\n  constructor({\n    toolName,\n    availableTools = undefined,\n    message = `Model tried to call unavailable tool '${toolName}'. ${\n      availableTools === undefined\n        ? 'No tools are available.'\n        : `Available tools: ${availableTools.join(', ')}.`\n    }`,\n  }: {\n    toolName: string;\n    availableTools?: string[] | undefined;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.toolName = toolName;\n    this.availableTools = availableTools;\n  }\n\n  static isInstance(error: unknown): error is NoSuchToolError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError, getErrorMessage } from '@ai-sdk/provider';\nimport { InvalidToolInputError } from './invalid-tool-input-error';\nimport { NoSuchToolError } from './no-such-tool-error';\n\nconst name = 'AI_ToolCallRepairError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class ToolCallRepairError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalError: NoSuchToolError | InvalidToolInputError;\n\n  constructor({\n    cause,\n    originalError,\n    message = `Error repairing tool call: ${getErrorMessage(cause)}`,\n  }: {\n    message?: string;\n    cause: unknown;\n    originalError: NoSuchToolError | InvalidToolInputError;\n  }) {\n    super({ name, message, cause });\n    this.originalError = originalError;\n  }\n\n  static isInstance(error: unknown): error is ToolCallRepairError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\n/**\nError that is thrown when a model with an unsupported version is used.\n */\nexport class UnsupportedModelVersionError extends AISDKError {\n  readonly version: string;\n  readonly provider: string;\n  readonly modelId: string;\n\n  constructor(options: { version: string; provider: string; modelId: string }) {\n    super({\n      name: 'AI_UnsupportedModelVersionError',\n      message:\n        `Unsupported model version ${options.version} for provider \"${options.provider}\" and model \"${options.modelId}\". ` +\n        `AI SDK 5 only supports models that implement specification version \"v2\".`,\n    });\n\n    this.version = options.version;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidDataContentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidDataContentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly content: unknown;\n\n  constructor({\n    content,\n    cause,\n    message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.`,\n  }: {\n    content: unknown;\n    cause?: unknown;\n    message?: string;\n  }) {\n    super({ name, message, cause });\n\n    this.content = content;\n  }\n\n  static isInstance(error: unknown): error is InvalidDataContentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { UIMessage } from '../ui/ui-messages';\n\nconst name = 'AI_MessageConversionError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class MessageConversionError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly originalMessage: Omit<UIMessage, 'id'>;\n\n  constructor({\n    originalMessage,\n    message,\n  }: {\n    originalMessage: Omit<UIMessage, 'id'>;\n    message: string;\n  }) {\n    super({ name, message });\n\n    this.originalMessage = originalMessage;\n  }\n\n  static isInstance(error: unknown): error is MessageConversionError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { Warning } from '../types';\n\n/**\n * A function for logging warnings.\n *\n * You can assign it to the `AI_SDK_LOG_WARNINGS` global variable to use it as the default warning logger.\n *\n * @example\n * ```ts\n * globalThis.AI_SDK_LOG_WARNINGS = (options) => {\n *   console.log('WARNINGS:', options.warnings, options.provider, options.model);\n * };\n * ```\n */\nexport type LogWarningsFunction = (options: {\n  /**\n   * The warnings returned by the model provider.\n   */\n  warnings: Warning[];\n\n  /**\n   * The provider id used for the call.\n   */\n  provider: string;\n\n  /**\n   * The model id used for the call.\n   */\n  model: string;\n}) => void;\n\n/**\n * Formats a warning object into a human-readable string with clear AI SDK branding\n */\nfunction formatWarning({\n  warning,\n  provider,\n  model,\n}: {\n  warning: Warning;\n  provider: string;\n  model: string;\n}): string {\n  const prefix = `AI SDK Warning (${provider} / ${model}):`;\n\n  switch (warning.type) {\n    case 'unsupported': {\n      let message = `${prefix} The feature \"${warning.feature}\" is not supported.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n\n    case 'compatibility': {\n      let message = `${prefix} The feature \"${warning.feature}\" is used in a compatibility mode.`;\n      if (warning.details) {\n        message += ` ${warning.details}`;\n      }\n      return message;\n    }\n\n    case 'other': {\n      return `${prefix} ${warning.message}`;\n    }\n\n    default: {\n      // Fallback for any unknown warning types\n      return `${prefix} ${JSON.stringify(warning, null, 2)}`;\n    }\n  }\n}\n\nexport const FIRST_WARNING_INFO_MESSAGE =\n  'AI SDK Warning System: To turn off warning logging, set the AI_SDK_LOG_WARNINGS global to false.';\n\nlet hasLoggedBefore = false;\n\nexport const logWarnings: LogWarningsFunction = options => {\n  // if the warnings array is empty, do nothing\n  if (options.warnings.length === 0) {\n    return;\n  }\n\n  const logger = globalThis.AI_SDK_LOG_WARNINGS;\n\n  // if the logger is set to false, do nothing\n  if (logger === false) {\n    return;\n  }\n\n  // use the provided logger if it is a function\n  if (typeof logger === 'function') {\n    logger(options);\n    return;\n  }\n\n  // display information note on first call\n  if (!hasLoggedBefore) {\n    hasLoggedBefore = true;\n    console.info(FIRST_WARNING_INFO_MESSAGE);\n  }\n\n  // default behavior: log warnings to the console\n  for (const warning of options.warnings) {\n    console.warn(\n      formatWarning({\n        warning,\n        provider: options.provider,\n        model: options.model,\n      }),\n    );\n  }\n};\n\n// Reset function for testing purposes\nexport const resetLogWarningsState = () => {\n  hasLoggedBefore = false;\n};\n","import { gateway } from '@ai-sdk/gateway';\nimport {\n  EmbeddingModelV3,\n  ImageModelV3,\n  LanguageModelV3,\n  ProviderV3,\n  SpeechModelV3,\n  TranscriptionModelV3,\n} from '@ai-sdk/provider';\nimport { UnsupportedModelVersionError } from '../error';\nimport { EmbeddingModel } from '../types/embedding-model';\nimport { LanguageModel } from '../types/language-model';\nimport { SpeechModel } from '../types/speech-model';\nimport { TranscriptionModel } from '../types/transcription-model';\nimport { asEmbeddingModelV3 } from './as-embedding-model-v3';\nimport { asImageModelV3 } from './as-image-model-v3';\nimport { asLanguageModelV3 } from './as-language-model-v3';\nimport { asSpeechModelV3 } from './as-speech-model-v3';\nimport { asTranscriptionModelV3 } from './as-transcription-model-v3';\nimport { ImageModel } from '../types/image-model';\n\nexport function resolveLanguageModel(model: LanguageModel): LanguageModelV3 {\n  if (typeof model !== 'string') {\n    if (\n      model.specificationVersion !== 'v3' &&\n      model.specificationVersion !== 'v2'\n    ) {\n      const unsupportedModel: any = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId,\n      });\n    }\n\n    return asLanguageModelV3(model);\n  }\n\n  return getGlobalProvider().languageModel(model);\n}\n\nexport function resolveEmbeddingModel(model: EmbeddingModel): EmbeddingModelV3 {\n  if (typeof model !== 'string') {\n    if (\n      model.specificationVersion !== 'v3' &&\n      model.specificationVersion !== 'v2'\n    ) {\n      const unsupportedModel: any = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId,\n      });\n    }\n\n    return asEmbeddingModelV3(model);\n  }\n\n  return getGlobalProvider().embeddingModel(model);\n}\n\nexport function resolveTranscriptionModel(\n  model: TranscriptionModel,\n): TranscriptionModelV3 | undefined {\n  if (typeof model !== 'string') {\n    if (\n      model.specificationVersion !== 'v3' &&\n      model.specificationVersion !== 'v2'\n    ) {\n      const unsupportedModel: any = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId,\n      });\n    }\n    return asTranscriptionModelV3(model);\n  }\n\n  return getGlobalProvider().transcriptionModel?.(model);\n}\n\nexport function resolveSpeechModel(\n  model: SpeechModel,\n): SpeechModelV3 | undefined {\n  if (typeof model !== 'string') {\n    if (\n      model.specificationVersion !== 'v3' &&\n      model.specificationVersion !== 'v2'\n    ) {\n      const unsupportedModel: any = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId,\n      });\n    }\n    return asSpeechModelV3(model);\n  }\n\n  return getGlobalProvider().speechModel?.(model);\n}\n\nexport function resolveImageModel(model: ImageModel): ImageModelV3 {\n  if (typeof model !== 'string') {\n    if (\n      model.specificationVersion !== 'v3' &&\n      model.specificationVersion !== 'v2'\n    ) {\n      const unsupportedModel: any = model;\n      throw new UnsupportedModelVersionError({\n        version: unsupportedModel.specificationVersion,\n        provider: unsupportedModel.provider,\n        modelId: unsupportedModel.modelId,\n      });\n    }\n\n    return asImageModelV3(model);\n  }\n\n  return getGlobalProvider().imageModel(model);\n}\n\nfunction getGlobalProvider(): ProviderV3 {\n  return globalThis.AI_SDK_DEFAULT_PROVIDER ?? gateway;\n}\n","import { logWarnings } from '../logger/log-warnings';\n\nexport function logV2CompatibilityWarning({\n  provider,\n  modelId,\n}: {\n  provider: string;\n  modelId: string;\n}): void {\n  logWarnings({\n    warnings: [\n      {\n        type: 'compatibility',\n        feature: 'specificationVersion',\n        details: `Using v2 specification compatibility mode. Some features may not be available.`,\n      },\n    ],\n    provider,\n    model: modelId,\n  });\n}\n","import { EmbeddingModelV2, EmbeddingModelV3 } from '@ai-sdk/provider';\nimport { logV2CompatibilityWarning } from '../util/log-v2-compatibility-warning';\n\nexport function asEmbeddingModelV3(\n  model: EmbeddingModelV2<string> | EmbeddingModelV3,\n): EmbeddingModelV3 {\n  if (model.specificationVersion === 'v3') {\n    return model;\n  }\n\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId,\n  });\n\n  // TODO this could break, we need to properly map v2 to v3\n  // and support all relevant v3 properties:\n  return new Proxy(model, {\n    get(target, prop: keyof EmbeddingModelV2<string>) {\n      if (prop === 'specificationVersion') return 'v3';\n      return target[prop];\n    },\n  }) as unknown as EmbeddingModelV3;\n}\n","import { ImageModelV2, ImageModelV3 } from '@ai-sdk/provider';\nimport { logV2CompatibilityWarning } from '../util/log-v2-compatibility-warning';\n\nexport function asImageModelV3(\n  model: ImageModelV2 | ImageModelV3,\n): ImageModelV3 {\n  if (model.specificationVersion === 'v3') {\n    return model;\n  }\n\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId,\n  });\n\n  // TODO this could break, we need to properly map v2 to v3\n  // and support all relevant v3 properties:\n  return new Proxy(model, {\n    get(target, prop: keyof ImageModelV2) {\n      if (prop === 'specificationVersion') return 'v3';\n      return target[prop];\n    },\n  }) as unknown as ImageModelV3;\n}\n","import {\n  LanguageModelV2,\n  LanguageModelV2FinishReason,\n  LanguageModelV2StreamPart,\n  LanguageModelV2Usage,\n  LanguageModelV3,\n  LanguageModelV3FinishReason,\n  LanguageModelV3StreamPart,\n  LanguageModelV3Usage,\n} from '@ai-sdk/provider';\nimport { logV2CompatibilityWarning } from '../util/log-v2-compatibility-warning';\n\nexport function asLanguageModelV3(\n  model: LanguageModelV2 | LanguageModelV3,\n): LanguageModelV3 {\n  if (model.specificationVersion === 'v3') {\n    return model;\n  }\n\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId,\n  });\n\n  // TODO this could break, we need to properly map v2 to v3\n  // and support all relevant v3 properties:\n  return new Proxy(model, {\n    get(target, prop: keyof LanguageModelV2) {\n      switch (prop) {\n        case 'specificationVersion':\n          return 'v3';\n        case 'doGenerate':\n          return async (...args: Parameters<LanguageModelV2['doGenerate']>) => {\n            const result = await target.doGenerate(...args);\n            return {\n              ...result,\n              finishReason: convertV2FinishReasonToV3(result.finishReason),\n              usage: convertV2UsageToV3(result.usage),\n            };\n          };\n        case 'doStream':\n          return async (...args: Parameters<LanguageModelV2['doStream']>) => {\n            const result = await target.doStream(...args);\n            return {\n              ...result,\n              stream: convertV2StreamToV3(result.stream),\n            };\n          };\n        default:\n          return target[prop];\n      }\n    },\n  }) as unknown as LanguageModelV3;\n}\n\nfunction convertV2StreamToV3(\n  stream: ReadableStream<LanguageModelV2StreamPart>,\n): ReadableStream<LanguageModelV3StreamPart> {\n  return stream.pipeThrough(\n    new TransformStream<LanguageModelV2StreamPart, LanguageModelV3StreamPart>({\n      transform(chunk, controller) {\n        switch (chunk.type) {\n          case 'finish':\n            controller.enqueue({\n              ...chunk,\n              finishReason: convertV2FinishReasonToV3(chunk.finishReason),\n              usage: convertV2UsageToV3(chunk.usage),\n            });\n            break;\n          default:\n            // TODO: AI SDK 6 - no casting (stream parts need to be mapped)\n            controller.enqueue(chunk as LanguageModelV3StreamPart);\n            break;\n        }\n      },\n    }),\n  );\n}\n\nfunction convertV2FinishReasonToV3(\n  finishReason: LanguageModelV2FinishReason,\n): LanguageModelV3FinishReason {\n  return {\n    unified: finishReason === 'unknown' ? 'other' : finishReason,\n    raw: undefined,\n  };\n}\n\nfunction convertV2UsageToV3(usage: LanguageModelV2Usage): LanguageModelV3Usage {\n  return {\n    inputTokens: {\n      total: usage.inputTokens,\n      noCache: undefined,\n      cacheRead: usage.cachedInputTokens,\n      cacheWrite: undefined,\n    },\n    outputTokens: {\n      total: usage.outputTokens,\n      text: undefined,\n      reasoning: usage.reasoningTokens,\n    },\n  };\n}\n","import { SpeechModelV2, SpeechModelV3 } from '@ai-sdk/provider';\nimport { logV2CompatibilityWarning } from '../util/log-v2-compatibility-warning';\n\nexport function asSpeechModelV3(\n  model: SpeechModelV3 | SpeechModelV2,\n): SpeechModelV3 {\n  if (model.specificationVersion === 'v3') {\n    return model;\n  }\n\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId,\n  });\n\n  // TODO this could break, we need to properly map v2 to v3\n  // and support all relevant v3 properties:\n  return new Proxy(model, {\n    get(target, prop: keyof SpeechModelV2) {\n      if (prop === 'specificationVersion') return 'v3';\n      return target[prop];\n    },\n  }) as unknown as SpeechModelV3;\n}\n","import { TranscriptionModelV2, TranscriptionModelV3 } from '@ai-sdk/provider';\nimport { logV2CompatibilityWarning } from '../util/log-v2-compatibility-warning';\n\nexport function asTranscriptionModelV3(\n  model: TranscriptionModelV3 | TranscriptionModelV2,\n): TranscriptionModelV3 {\n  if (model.specificationVersion === 'v3') {\n    return model;\n  }\n\n  logV2CompatibilityWarning({\n    provider: model.provider,\n    modelId: model.modelId,\n  });\n\n  // TODO this could break, we need to properly map v2 to v3\n  // and support all relevant v3 properties:\n  return new Proxy(model, {\n    get(target, prop: keyof TranscriptionModelV2) {\n      if (prop === 'specificationVersion') return 'v3';\n      return target[prop];\n    },\n  }) as unknown as TranscriptionModelV3;\n}\n","import {\n  LanguageModelV3FilePart,\n  LanguageModelV3Message,\n  LanguageModelV3Prompt,\n  LanguageModelV3TextPart,\n  LanguageModelV3ToolResultOutput,\n} from '@ai-sdk/provider';\nimport {\n  DataContent,\n  FilePart,\n  ImagePart,\n  isUrlSupported,\n  ModelMessage,\n  ReasoningPart,\n  TextPart,\n  ToolCallPart,\n  ToolResultOutput,\n  ToolResultPart,\n} from '@ai-sdk/provider-utils';\nimport {\n  detectMediaType,\n  imageMediaTypeSignatures,\n} from '../util/detect-media-type';\nimport {\n  createDefaultDownloadFunction,\n  DownloadFunction,\n} from '../util/download/download-function';\nimport { convertToLanguageModelV3DataContent } from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { StandardizedPrompt } from './standardize-prompt';\nimport { asArray } from '../util/as-array';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download = createDefaultDownloadFunction(),\n}: {\n  prompt: StandardizedPrompt;\n  supportedUrls: Record<string, RegExp[]>;\n  download: DownloadFunction | undefined;\n}): Promise<LanguageModelV3Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download,\n    supportedUrls,\n  );\n\n  const messages = [\n    ...(prompt.system != null\n      ? typeof prompt.system === 'string'\n        ? [{ role: 'system' as const, content: prompt.system }]\n        : asArray(prompt.system).map(message => ({\n            role: 'system' as const,\n            content: message.content,\n            providerOptions: message.providerOptions,\n          }))\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage({ message, downloadedAssets }),\n    ),\n  ];\n\n  // combine consecutive tool messages into a single tool message\n  const combinedMessages = [];\n  for (const message of messages) {\n    if (message.role !== 'tool') {\n      combinedMessages.push(message);\n      continue;\n    }\n\n    const lastCombinedMessage = combinedMessages.at(-1);\n    if (lastCombinedMessage?.role === 'tool') {\n      lastCombinedMessage.content.push(...message.content);\n    } else {\n      combinedMessages.push(message);\n    }\n  }\n\n  return combinedMessages;\n}\n\n/**\n * Convert a ModelMessage to a LanguageModelV3Message.\n *\n * @param message The ModelMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage({\n  message,\n  downloadedAssets,\n}: {\n  message: ModelMessage;\n  downloadedAssets: Record<\n    string,\n    { mediaType: string | undefined; data: Uint8Array }\n  >;\n}): LanguageModelV3Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerOptions: message.providerOptions,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerOptions: message.providerOptions,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts (no text, and no provider options):\n            part =>\n              part.type !== 'text' ||\n              part.text !== '' ||\n              part.providerOptions != null,\n          )\n          .filter(\n            (\n              part,\n            ): part is\n              | TextPart\n              | FilePart\n              | ReasoningPart\n              | ToolCallPart\n              | ToolResultPart => part.type !== 'tool-approval-request',\n          )\n          .map(part => {\n            const providerOptions = part.providerOptions;\n\n            switch (part.type) {\n              case 'file': {\n                const { data, mediaType } = convertToLanguageModelV3DataContent(\n                  part.data,\n                );\n                return {\n                  type: 'file',\n                  data,\n                  filename: part.filename,\n                  mediaType: mediaType ?? part.mediaType,\n                  providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  providerExecuted: part.providerExecuted,\n                  providerOptions,\n                };\n              }\n              case 'tool-result': {\n                return {\n                  type: 'tool-result' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  output: mapToolResultOutput(part.output),\n                  providerOptions,\n                };\n              }\n            }\n          }),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content\n          .filter(\n            // Only include tool-approval-response for provider-executed tools\n            part =>\n              part.type !== 'tool-approval-response' || part.providerExecuted,\n          )\n          .map(part => {\n            switch (part.type) {\n              case 'tool-result': {\n                return {\n                  type: 'tool-result' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  output: mapToolResultOutput(part.output),\n                  providerOptions: part.providerOptions,\n                };\n              }\n              case 'tool-approval-response': {\n                return {\n                  type: 'tool-approval-response' as const,\n                  approvalId: part.approvalId,\n                  approved: part.approved,\n                  reason: part.reason,\n                };\n              }\n            }\n          }),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: ModelMessage[],\n  download: DownloadFunction,\n  supportedUrls: Record<string, RegExp[]>,\n): Promise<\n  Record<string, { mediaType: string | undefined; data: Uint8Array }>\n> {\n  const plannedDownloads = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    .map(part => {\n      const mediaType =\n        part.mediaType ?? (part.type === 'image' ? 'image/*' : undefined);\n\n      let data = part.type === 'image' ? part.image : part.data;\n      if (typeof data === 'string') {\n        try {\n          data = new URL(data);\n        } catch (ignored) {}\n      }\n\n      return { mediaType, data };\n    })\n\n    .filter(\n      (part): part is { mediaType: string | undefined; data: URL } =>\n        part.data instanceof URL,\n    )\n    .map(part => ({\n      url: part.data,\n      isUrlSupportedByModel:\n        part.mediaType != null &&\n        isUrlSupported({\n          url: part.data.toString(),\n          mediaType: part.mediaType,\n          supportedUrls,\n        }),\n    }));\n\n  // download in parallel:\n  const downloadedFiles = await download(plannedDownloads);\n\n  return Object.fromEntries(\n    downloadedFiles\n      .map((file, index) =>\n        file == null\n          ? null\n          : [\n              plannedDownloads[index].url.toString(),\n              { data: file.data, mediaType: file.mediaType },\n            ],\n      )\n      .filter(file => file != null),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV3Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mediaType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV3TextPart | LanguageModelV3FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerOptions: part.providerOptions,\n    };\n  }\n\n  let originalData: DataContent | URL;\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      originalData = part.image;\n      break;\n    case 'file':\n      originalData = part.data;\n\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  const { data: convertedData, mediaType: convertedMediaType } =\n    convertToLanguageModelV3DataContent(originalData);\n\n  let mediaType: string | undefined = convertedMediaType ?? part.mediaType;\n  let data: Uint8Array | string | URL = convertedData; // binary | base64 | url\n\n  // If the content is a URL, we check if it was downloaded:\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType ??= downloadedFile.mediaType;\n    }\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV3Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the media type automatically\n      // to deal with incorrect media type inputs.\n      // When detection fails, use provided media type.\n      if (data instanceof Uint8Array || typeof data === 'string') {\n        mediaType =\n          detectMediaType({ data, signatures: imageMediaTypeSignatures }) ??\n          mediaType;\n      }\n\n      return {\n        type: 'file',\n        mediaType: mediaType ?? 'image/*', // any image\n        filename: undefined,\n        data,\n        providerOptions: part.providerOptions,\n      };\n    }\n\n    case 'file': {\n      // We must have a mediaType for files, if not, throw an error.\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions,\n      };\n    }\n  }\n}\n\nfunction mapToolResultOutput(\n  output: ToolResultOutput,\n): LanguageModelV3ToolResultOutput {\n  if (output.type !== 'content') {\n    return output;\n  }\n\n  return {\n    type: 'content',\n    value: output.value.map(item => {\n      if (item.type !== 'media') {\n        return item;\n      }\n\n      // AI SDK 5 tool backwards compatibility:\n      // map media type to image-data or file-data\n      if (item.mediaType.startsWith('image/')) {\n        return {\n          type: 'image-data' as const,\n          data: item.data,\n          mediaType: item.mediaType,\n        };\n      }\n\n      return {\n        type: 'file-data' as const,\n        data: item.data,\n        mediaType: item.mediaType,\n      };\n    }),\n  };\n}\n","import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMediaTypeSignatures = [\n  {\n    mediaType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46], // GIF\n  },\n  {\n    mediaType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47], // PNG\n  },\n  {\n    mediaType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8], // JPEG\n  },\n  {\n    mediaType: 'image/webp' as const,\n    bytesPrefix: [\n      0x52,\n      0x49,\n      0x46,\n      0x46, // \"RIFF\"\n      null,\n      null,\n      null,\n      null, // file size (variable)\n      0x57,\n      0x45,\n      0x42,\n      0x50, // \"WEBP\"\n    ],\n  },\n  {\n    mediaType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n  },\n  {\n    mediaType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n  },\n  {\n    mediaType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n  },\n  {\n    mediaType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n  },\n  {\n    mediaType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n  },\n] as const;\n\nexport const audioMediaTypeSignatures = [\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfa],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xf3],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xf2],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xe3],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xe2],\n  },\n  {\n    mediaType: 'audio/wav' as const,\n    bytesPrefix: [\n      0x52, // R\n      0x49, // I\n      0x46, // F\n      0x46, // F\n      null,\n      null,\n      null,\n      null,\n      0x57, // W\n      0x41, // A\n      0x56, // V\n      0x45, // E\n    ],\n  },\n  {\n    mediaType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n  },\n  {\n    mediaType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n  },\n  {\n    mediaType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n  },\n  {\n    mediaType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n  },\n  {\n    mediaType: 'audio/webm',\n    bytesPrefix: [0x1a, 0x45, 0xdf, 0xa3],\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\n/**\n * Detect the media IANA media type of a file using a list of signatures.\n *\n * @param data - The file data.\n * @param signatures - The signatures to use for detection.\n * @returns The media type of the file.\n */\nexport function detectMediaType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMediaTypeSignatures | typeof imageMediaTypeSignatures;\n}): (typeof signatures)[number]['mediaType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  // Convert the first ~18 bytes (24 base64 chars) for consistent detection logic:\n  const bytes =\n    typeof processedData === 'string'\n      ? convertBase64ToUint8Array(\n          processedData.substring(0, Math.min(processedData.length, 24)),\n        )\n      : processedData;\n\n  for (const signature of signatures) {\n    if (\n      bytes.length >= signature.bytesPrefix.length &&\n      signature.bytesPrefix.every(\n        (byte, index) => byte === null || bytes[index] === byte,\n      )\n    ) {\n      return signature.mediaType;\n    }\n  }\n\n  return undefined;\n}\n","import { DownloadError } from '@ai-sdk/provider-utils';\nimport {\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport { VERSION } from '../../version';\n\n/**\n * Download a file from a URL.\n *\n * @param url - The URL to download from.\n * @returns The downloaded data and media type.\n *\n * @throws DownloadError if the download fails.\n */\nexport const download = async ({ url }: { url: URL }) => {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText, {\n      headers: withUserAgentSuffix(\n        {},\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n    });\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n};\n","declare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n","import { download as originalDownload } from './download';\n\n/**\n * Experimental. Can change in patch versions without warning.\n *\n * Download function. Called with the array of URLs and a boolean indicating\n * whether the URL is supported by the model.\n *\n * The download function can decide for each URL:\n * - to return null (which means that the URL should be passed to the model)\n * - to download the asset and return the data (incl. retries, authentication, etc.)\n *\n * Should throw DownloadError if the download fails.\n *\n * Should return an array of objects sorted by the order of the requested downloads.\n * For each object, the data should be a Uint8Array if the URL was downloaded.\n * For each object, the mediaType should be the media type of the downloaded asset.\n * For each object, the data should be null if the URL should be passed through as is.\n */\nexport type DownloadFunction = (\n  options: Array<{\n    url: URL;\n    isUrlSupportedByModel: boolean;\n  }>,\n) => PromiseLike<\n  Array<{\n    data: Uint8Array;\n    mediaType: string | undefined;\n  } | null>\n>;\n\n/**\n * Default download function.\n * Downloads the file if it is not supported by the model.\n */\nexport const createDefaultDownloadFunction =\n  (download: typeof originalDownload = originalDownload): DownloadFunction =>\n  requestedDownloads =>\n    Promise.all(\n      requestedDownloads.map(async requestedDownload =>\n        requestedDownload.isUrlSupportedByModel\n          ? null\n          : download(requestedDownload),\n      ),\n    );\n","import { AISDKError, LanguageModelV3DataContent } from '@ai-sdk/provider';\nimport {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n  DataContent,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { splitDataUrl } from './split-data-url';\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom<Buffer>(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\nexport function convertToLanguageModelV3DataContent(\n  content: DataContent | URL,\n): {\n  data: LanguageModelV3DataContent;\n  mediaType: string | undefined;\n} {\n  // Buffer & Uint8Array:\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: undefined };\n  }\n\n  // ArrayBuffer needs conversion to Uint8Array (lightweight):\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: undefined };\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  if (typeof content === 'string') {\n    try {\n      content = new URL(content);\n    } catch (error) {\n      // ignored\n    }\n  }\n\n  // Extract data from data URL:\n  if (content instanceof URL && content.protocol === 'data:') {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString(),\n    );\n\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new AISDKError({\n        name: 'InvalidDataContentError',\n        message: `Invalid data URL format in content ${content.toString()}`,\n      });\n    }\n\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n\n  return { data: content, mediaType: undefined };\n}\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","export function splitDataUrl(dataUrl: string): {\n  mediaType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mediaType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mediaType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n","export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n","import { getErrorMessage, JSONValue } from '@ai-sdk/provider';\nimport { Tool, ToolResultOutput } from '@ai-sdk/provider-utils';\n\nexport async function createToolModelOutput({\n  toolCallId,\n  input,\n  output,\n  tool,\n  errorMode,\n}: {\n  toolCallId: string;\n  input: unknown;\n  output: unknown;\n  tool: Tool | undefined;\n  errorMode: 'none' | 'text' | 'json';\n}): Promise<ToolResultOutput> {\n  if (errorMode === 'text') {\n    return { type: 'error-text', value: getErrorMessage(output) };\n  } else if (errorMode === 'json') {\n    return { type: 'error-json', value: toJSONValue(output) };\n  }\n\n  if (tool?.toModelOutput) {\n    return await tool.toModelOutput({ toolCallId, input, output });\n  }\n\n  return typeof output === 'string'\n    ? { type: 'text', value: output }\n    : { type: 'json', value: toJSONValue(output) };\n}\n\nfunction toJSONValue(value: unknown): JSONValue {\n  return value === undefined ? null : (value as JSONValue);\n}\n","import { InvalidArgumentError } from '../error/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and returns a new object with limited values.\n */\nexport function prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxOutputTokens',\n        value: maxOutputTokens,\n        message: 'maxOutputTokens must be an integer',\n      });\n    }\n\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxOutputTokens',\n        value: maxOutputTokens,\n        message: 'maxOutputTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed,\n  };\n}\n","import {\n  LanguageModelV3FunctionTool,\n  LanguageModelV3ProviderTool,\n  LanguageModelV3ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/provider-utils';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\n\nexport async function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): Promise<{\n  tools:\n    | Array<LanguageModelV3FunctionTool | LanguageModelV3ProviderTool>\n    | undefined;\n  toolChoice: LanguageModelV3ToolChoice | undefined;\n}> {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  const languageModelTools: Array<\n    LanguageModelV3FunctionTool | LanguageModelV3ProviderTool\n  > = [];\n  for (const [name, tool] of filteredTools) {\n    const toolType = tool.type;\n\n    switch (toolType) {\n      case undefined:\n      case 'dynamic':\n      case 'function':\n        languageModelTools.push({\n          type: 'function' as const,\n          name,\n          description: tool.description,\n          inputSchema: await asSchema(tool.inputSchema).jsonSchema,\n          ...(tool.inputExamples != null\n            ? { inputExamples: tool.inputExamples }\n            : {}),\n          providerOptions: tool.providerOptions,\n          ...(tool.strict != null ? { strict: tool.strict } : {}),\n        });\n        break;\n      case 'provider':\n        languageModelTools.push({\n          type: 'provider' as const,\n          name,\n          id: tool.id,\n          args: tool.args,\n        });\n        break;\n      default: {\n        const exhaustiveCheck: never = toolType as never;\n        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return {\n    tools: languageModelTools,\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n","export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n","import { InvalidPromptError } from '@ai-sdk/provider';\nimport {\n  ModelMessage,\n  safeValidateTypes,\n  SystemModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { modelMessageSchema } from './message';\nimport { Prompt } from './prompt';\nimport { asArray } from '../util/as-array';\n\nexport type StandardizedPrompt = {\n  /**\n   * System message.\n   */\n  system?: string | SystemModelMessage | Array<SystemModelMessage>;\n\n  /**\n   * Messages.\n   */\n  messages: ModelMessage[];\n};\n\nexport async function standardizePrompt(\n  prompt: Prompt,\n): Promise<StandardizedPrompt> {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string or a SystemModelMessage\n  if (\n    prompt.system != null &&\n    typeof prompt.system !== 'string' &&\n    !asArray(prompt.system).every(\n      message =>\n        typeof message === 'object' &&\n        message !== null &&\n        'role' in message &&\n        message.role === 'system',\n    )\n  ) {\n    throw new InvalidPromptError({\n      prompt,\n      message:\n        'system must be a string, SystemModelMessage, or array of SystemModelMessage',\n    });\n  }\n\n  let messages: ModelMessage[];\n\n  if (prompt.prompt != null && typeof prompt.prompt === 'string') {\n    messages = [{ role: 'user', content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (messages.length === 0) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'messages must not be empty',\n    });\n  }\n\n  const validationResult = await safeValidateTypes({\n    value: messages,\n    schema: z.array(modelMessageSchema),\n  });\n\n  if (!validationResult.success) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'The messages do not match the ModelMessage[] schema.',\n      cause: validationResult.error,\n    });\n  }\n\n  return {\n    messages,\n    system: prompt.system,\n  };\n}\n","import {\n  AssistantModelMessage,\n  ModelMessage,\n  SystemModelMessage,\n  ToolModelMessage,\n  UserModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport {\n  filePartSchema,\n  imagePartSchema,\n  reasoningPartSchema,\n  textPartSchema,\n  toolApprovalRequestSchema,\n  toolCallPartSchema,\n  toolApprovalResponseSchema,\n  toolResultPartSchema,\n} from './content-part';\n\nexport const systemModelMessageSchema: z.ZodType<SystemModelMessage> = z.object(\n  {\n    role: z.literal('system'),\n    content: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n  },\n);\n\nexport const userModelMessageSchema: z.ZodType<UserModelMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\nexport const assistantModelMessageSchema: z.ZodType<AssistantModelMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          toolCallPartSchema,\n          toolResultPartSchema,\n          toolApprovalRequestSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n  });\n\nexport const toolModelMessageSchema: z.ZodType<ToolModelMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(z.union([toolResultPartSchema, toolApprovalResponseSchema])),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\nexport const modelMessageSchema: z.ZodType<ModelMessage> = z.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema,\n]);\n","import { SharedV3ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod/v4';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = SharedV3ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema.optional()),\n);\n","import { JSONValue as OriginalJSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod/v4';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema.optional()),\n    z.array(jsonValueSchema),\n  ]),\n);\n\nexport type JSONValue = OriginalJSONValue;\n","import {\n  FilePart,\n  ImagePart,\n  ProviderOptions,\n  ReasoningPart,\n  TextPart,\n  ToolApprovalRequest,\n  ToolApprovalResponse,\n  ToolResultOutput,\n  ToolResultPart,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { jsonValueSchema } from '../types/json-value';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport { dataContentSchema } from './data-content';\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mediaType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mediaType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  input: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  input: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: z.boolean().optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc input is optional on Zod type\n\n/**\n@internal\n */\nexport const outputSchema: z.ZodType<ToolResultOutput> = z.discriminatedUnion(\n  'type',\n  [\n    z.object({\n      type: z.literal('text'),\n      value: z.string(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('json'),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('execution-denied'),\n      reason: z.string().optional(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('error-text'),\n      value: z.string(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('error-json'),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('content'),\n      value: z.array(\n        z.union([\n          z.object({\n            type: z.literal('text'),\n            text: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('media'),\n            data: z.string(),\n            mediaType: z.string(),\n          }),\n          z.object({\n            type: z.literal('file-data'),\n            data: z.string(),\n            mediaType: z.string(),\n            filename: z.string().optional(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('file-url'),\n            url: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('file-id'),\n            fileId: z.union([z.string(), z.record(z.string(), z.string())]),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-data'),\n            data: z.string(),\n            mediaType: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-url'),\n            url: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-file-id'),\n            fileId: z.union([z.string(), z.record(z.string(), z.string())]),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('custom'),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n        ]),\n      ),\n    }),\n  ],\n);\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n\nexport const toolApprovalRequestSchema: z.ZodType<ToolApprovalRequest> =\n  z.object({\n    type: z.literal('tool-approval-request'),\n    approvalId: z.string(),\n    toolCallId: z.string(),\n  });\n\nexport const toolApprovalResponseSchema: z.ZodType<ToolApprovalResponse> =\n  z.object({\n    type: z.literal('tool-approval-response'),\n    approvalId: z.string(),\n    approved: z.boolean(),\n    reason: z.string().optional(),\n  });\n","import { GatewayAuthenticationError } from '@ai-sdk/gateway';\nimport { AISDKError } from '@ai-sdk/provider';\n\nexport function wrapGatewayError(error: unknown): unknown {\n  if (!GatewayAuthenticationError.isInstance(error)) return error;\n\n  const isProductionEnv = process?.env.NODE_ENV === 'production';\n  const moreInfoURL = 'https://ai-sdk.dev/unauthenticated-ai-gateway';\n\n  if (isProductionEnv) {\n    return new AISDKError({\n      name: 'GatewayError',\n      message: `Unauthenticated. Configure AI_GATEWAY_API_KEY or use a provider module. Learn more: ${moreInfoURL}`,\n    });\n  }\n\n  return Object.assign(\n    new Error(`\\u001b[1m\\u001b[31mUnauthenticated request to AI Gateway.\\u001b[0m\n\nTo authenticate, set the \\u001b[33mAI_GATEWAY_API_KEY\\u001b[0m environment variable with your API key.\n\nAlternatively, you can use a provider module instead of the AI Gateway.\n\nLearn more: \\u001b[34m${moreInfoURL}\\u001b[0m\n\n`),\n    { name: 'GatewayAuthenticationError' },\n  );\n}\n","import { TelemetrySettings } from './telemetry-settings';\n\nexport function assembleOperationName({\n  operationId,\n  telemetry,\n}: {\n  operationId: string;\n  telemetry?: TelemetrySettings;\n}) {\n  return {\n    // standardized operation and resource name:\n    'operation.name': `${operationId}${\n      telemetry?.functionId != null ? ` ${telemetry.functionId}` : ''\n    }`,\n    'resource.name': telemetry?.functionId,\n\n    // detailed, AI SDK specific data:\n    'ai.operationId': operationId,\n    'ai.telemetry.functionId': telemetry?.functionId,\n  };\n}\n","import { Attributes } from '@opentelemetry/api';\nimport { CallSettings } from '../prompt/call-settings';\nimport { TelemetrySettings } from './telemetry-settings';\n\nexport function getBaseTelemetryAttributes({\n  model,\n  settings,\n  telemetry,\n  headers,\n}: {\n  model: { modelId: string; provider: string };\n  settings: Omit<CallSettings, 'abortSignal' | 'headers' | 'temperature'>;\n  telemetry: TelemetrySettings | undefined;\n  headers: Record<string, string | undefined> | undefined;\n}): Attributes {\n  return {\n    'ai.model.provider': model.provider,\n    'ai.model.id': model.modelId,\n\n    // settings:\n    ...Object.entries(settings).reduce((attributes, [key, value]) => {\n      attributes[`ai.settings.${key}`] = value;\n      return attributes;\n    }, {} as Attributes),\n\n    // add metadata as attributes:\n    ...Object.entries(telemetry?.metadata ?? {}).reduce(\n      (attributes, [key, value]) => {\n        attributes[`ai.telemetry.metadata.${key}`] = value;\n        return attributes;\n      },\n      {} as Attributes,\n    ),\n\n    // request headers\n    ...Object.entries(headers ?? {}).reduce((attributes, [key, value]) => {\n      if (value !== undefined) {\n        attributes[`ai.request.headers.${key}`] = value;\n      }\n      return attributes;\n    }, {} as Attributes),\n  };\n}\n","import { Tracer, trace } from '@opentelemetry/api';\nimport { noopTracer } from './noop-tracer';\n\nexport function getTracer({\n  isEnabled = false,\n  tracer,\n}: {\n  isEnabled?: boolean;\n  tracer?: Tracer;\n} = {}): Tracer {\n  if (!isEnabled) {\n    return noopTracer;\n  }\n\n  if (tracer) {\n    return tracer;\n  }\n\n  return trace.getTracer('ai');\n}\n","import { Span, SpanContext, Tracer } from '@opentelemetry/api';\n\n/**\n * Tracer implementation that does nothing (null object).\n */\nexport const noopTracer: Tracer = {\n  startSpan(): Span {\n    return noopSpan;\n  },\n\n  startActiveSpan<F extends (span: Span) => unknown>(\n    name: unknown,\n    arg1: unknown,\n    arg2?: unknown,\n    arg3?: F,\n  ): ReturnType<any> {\n    if (typeof arg1 === 'function') {\n      return arg1(noopSpan);\n    }\n    if (typeof arg2 === 'function') {\n      return arg2(noopSpan);\n    }\n    if (typeof arg3 === 'function') {\n      return arg3(noopSpan);\n    }\n  },\n};\n\nconst noopSpan: Span = {\n  spanContext() {\n    return noopSpanContext;\n  },\n  setAttribute() {\n    return this;\n  },\n  setAttributes() {\n    return this;\n  },\n  addEvent() {\n    return this;\n  },\n  addLink() {\n    return this;\n  },\n  addLinks() {\n    return this;\n  },\n  setStatus() {\n    return this;\n  },\n  updateName() {\n    return this;\n  },\n  end() {\n    return this;\n  },\n  isRecording() {\n    return false;\n  },\n  recordException() {\n    return this;\n  },\n};\n\nconst noopSpanContext: SpanContext = {\n  traceId: '',\n  spanId: '',\n  traceFlags: 0,\n};\n","import { Attributes, Span, Tracer, SpanStatusCode } from '@opentelemetry/api';\n\nexport async function recordSpan<T>({\n  name,\n  tracer,\n  attributes,\n  fn,\n  endWhenDone = true,\n}: {\n  name: string;\n  tracer: Tracer;\n  attributes: Attributes | PromiseLike<Attributes>;\n  fn: (span: Span) => Promise<T>;\n  endWhenDone?: boolean;\n}) {\n  return tracer.startActiveSpan(\n    name,\n    { attributes: await attributes },\n    async span => {\n      try {\n        const result = await fn(span);\n\n        if (endWhenDone) {\n          span.end();\n        }\n\n        return result;\n      } catch (error) {\n        try {\n          recordErrorOnSpan(span, error);\n        } finally {\n          // always stop the span when there is an error:\n          span.end();\n        }\n\n        throw error;\n      }\n    },\n  );\n}\n\n/**\n * Record an error on a span. If the error is an instance of Error, an exception event will be recorded on the span, otherwise\n * the span will be set to an error status.\n *\n * @param span - The span to record the error on.\n * @param error - The error to record on the span.\n */\nexport function recordErrorOnSpan(span: Span, error: unknown) {\n  if (error instanceof Error) {\n    span.recordException({\n      name: error.name,\n      message: error.message,\n      stack: error.stack,\n    });\n    span.setStatus({\n      code: SpanStatusCode.ERROR,\n      message: error.message,\n    });\n  } else {\n    span.setStatus({ code: SpanStatusCode.ERROR });\n  }\n}\n","import type { Attributes, AttributeValue } from '@opentelemetry/api';\nimport type { TelemetrySettings } from './telemetry-settings';\n\ntype ResolvableAttributeValue = () =>\n  | AttributeValue\n  | PromiseLike<AttributeValue>\n  | undefined;\n\nexport async function selectTelemetryAttributes({\n  telemetry,\n  attributes,\n}: {\n  telemetry?: TelemetrySettings;\n  attributes: {\n    [attributeKey: string]:\n      | AttributeValue\n      | { input: ResolvableAttributeValue }\n      | { output: ResolvableAttributeValue }\n      | undefined;\n  };\n}): Promise<Attributes> {\n  // when telemetry is disabled, return an empty object to avoid serialization overhead:\n  if (telemetry?.isEnabled !== true) {\n    return {};\n  }\n\n  const resultAttributes: Attributes = {};\n\n  for (const [key, value] of Object.entries(attributes)) {\n    if (value == null) {\n      continue;\n    }\n\n    // input value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'input' in value &&\n      typeof value.input === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordInputs === false) {\n        continue;\n      }\n\n      const result = await value.input();\n\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n\n      continue;\n    }\n\n    // output value, check if it should be recorded:\n    if (\n      typeof value === 'object' &&\n      'output' in value &&\n      typeof value.output === 'function'\n    ) {\n      // default to true:\n      if (telemetry?.recordOutputs === false) {\n        continue;\n      }\n\n      const result = await value.output();\n\n      if (result != null) {\n        resultAttributes[key] = result;\n      }\n      continue;\n    }\n\n    // value is an attribute value already:\n    resultAttributes[key] = value as AttributeValue;\n  }\n\n  return resultAttributes;\n}\n","import {\n  LanguageModelV3Message,\n  LanguageModelV3Prompt,\n} from '@ai-sdk/provider';\nimport { convertDataContentToBase64String } from '../prompt/data-content';\n\n/**\n * Helper utility to serialize prompt content for OpenTelemetry tracing.\n * It is initially created because normalized LanguageModelV1Prompt carries\n * images as Uint8Arrays, on which JSON.stringify acts weirdly, converting\n * them to objects with stringified indices as keys, e.g. {\"0\": 42, \"1\": 69 }.\n */\nexport function stringifyForTelemetry(prompt: LanguageModelV3Prompt): string {\n  return JSON.stringify(\n    prompt.map((message: LanguageModelV3Message) => ({\n      ...message,\n      content:\n        typeof message.content === 'string'\n          ? message.content\n          : message.content.map(part =>\n              part.type === 'file'\n                ? {\n                    ...part,\n                    data:\n                      part.data instanceof Uint8Array\n                        ? convertDataContentToBase64String(part.data)\n                        : part.data,\n                  }\n                : part,\n            ),\n    })),\n  );\n}\n","import {\n  ImageModelV3Usage,\n  JSONObject,\n  LanguageModelV3Usage,\n} from '@ai-sdk/provider';\n\n/**\n * Represents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\n   * The total number of input (prompt) tokens used.\n   */\n  inputTokens: number | undefined;\n\n  /**\n   * Detailed information about the input tokens.\n   */\n  inputTokenDetails: {\n    /**\n     * The number of non-cached input (prompt) tokens used.\n     */\n    noCacheTokens: number | undefined;\n\n    /**\n     * The number of cached input (prompt) tokens read.\n     */\n    cacheReadTokens: number | undefined;\n\n    /**\n     * The number of cached input (prompt) tokens written.\n     */\n    cacheWriteTokens: number | undefined;\n  };\n\n  /**\n   * The number of total output (completion) tokens used.\n   */\n  outputTokens: number | undefined;\n\n  /**\n   * Detailed information about the output tokens.\n   */\n  outputTokenDetails: {\n    /**\n     * The number of text tokens used.\n     */\n    textTokens: number | undefined;\n\n    /**\n     * The number of reasoning tokens used.\n     */\n    reasoningTokens: number | undefined;\n  };\n\n  /**\n   * The total number of tokens used.\n   */\n  totalTokens: number | undefined;\n\n  /**\n   * @deprecated Use outputTokenDetails.reasoning instead.\n   */\n  reasoningTokens?: number | undefined;\n\n  /**\n   * @deprecated Use inputTokenDetails.cacheRead instead.\n   */\n  cachedInputTokens?: number | undefined;\n\n  /**\n   * Raw usage information from the provider.\n   *\n   * This is the usage information in the shape that the provider returns.\n   * It can include additional information that is not part of the standard usage information.\n   */\n  raw?: JSONObject;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\n// TODO replace with EmbeddingModelV3Usage\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function asLanguageModelUsage(\n  usage: LanguageModelV3Usage,\n): LanguageModelUsage {\n  return {\n    inputTokens: usage.inputTokens.total,\n    inputTokenDetails: {\n      noCacheTokens: usage.inputTokens.noCache,\n      cacheReadTokens: usage.inputTokens.cacheRead,\n      cacheWriteTokens: usage.inputTokens.cacheWrite,\n    },\n    outputTokens: usage.outputTokens.total,\n    outputTokenDetails: {\n      textTokens: usage.outputTokens.text,\n      reasoningTokens: usage.outputTokens.reasoning,\n    },\n    totalTokens: addTokenCounts(\n      usage.inputTokens.total,\n      usage.outputTokens.total,\n    ),\n    raw: usage.raw,\n    reasoningTokens: usage.outputTokens.reasoning,\n    cachedInputTokens: usage.inputTokens.cacheRead,\n  };\n}\n\nexport function createNullLanguageModelUsage(): LanguageModelUsage {\n  return {\n    inputTokens: undefined,\n    inputTokenDetails: {\n      noCacheTokens: undefined,\n      cacheReadTokens: undefined,\n      cacheWriteTokens: undefined,\n    },\n    outputTokens: undefined,\n    outputTokenDetails: {\n      textTokens: undefined,\n      reasoningTokens: undefined,\n    },\n    totalTokens: undefined,\n    raw: undefined,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    inputTokenDetails: {\n      noCacheTokens: addTokenCounts(\n        usage1.inputTokenDetails?.noCacheTokens,\n        usage2.inputTokenDetails?.noCacheTokens,\n      ),\n      cacheReadTokens: addTokenCounts(\n        usage1.inputTokenDetails?.cacheReadTokens,\n        usage2.inputTokenDetails?.cacheReadTokens,\n      ),\n      cacheWriteTokens: addTokenCounts(\n        usage1.inputTokenDetails?.cacheWriteTokens,\n        usage2.inputTokenDetails?.cacheWriteTokens,\n      ),\n    },\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    outputTokenDetails: {\n      textTokens: addTokenCounts(\n        usage1.outputTokenDetails?.textTokens,\n        usage2.outputTokenDetails?.textTokens,\n      ),\n      reasoningTokens: addTokenCounts(\n        usage1.outputTokenDetails?.reasoningTokens,\n        usage2.outputTokenDetails?.reasoningTokens,\n      ),\n    },\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens,\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens,\n    ),\n  };\n}\n\nfunction addTokenCounts(\n  tokenCount1: number | undefined,\n  tokenCount2: number | undefined,\n): number | undefined {\n  return tokenCount1 == null && tokenCount2 == null\n    ? undefined\n    : (tokenCount1 ?? 0) + (tokenCount2 ?? 0);\n}\n\n/**\nUsage information for an image model call.\n */\nexport type ImageModelUsage = ImageModelV3Usage;\n\nexport function addImageModelUsage(\n  usage1: ImageModelUsage,\n  usage2: ImageModelUsage,\n): ImageModelUsage {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n  };\n}\n","/**\n * Deeply merges two objects together.\n * - Properties from the `overrides` object override those in the `base` object with the same key.\n * - For nested objects, the merge is performed recursively (deep merge).\n * - Arrays are replaced, not merged.\n * - Primitive values are replaced.\n * - If both `base` and `overrides` are undefined, returns undefined.\n * - If one of `base` or `overrides` is undefined, returns the other.\n *\n * @param base The target object to merge into\n * @param overrides The source object to merge from\n * @returns A new object with the merged properties, or undefined if both inputs are undefined\n */\nexport function mergeObjects<T extends object, U extends object>(\n  base: T | undefined,\n  overrides: U | undefined,\n): (T & U) | T | U | undefined {\n  // If both inputs are undefined, return undefined\n  if (base === undefined && overrides === undefined) {\n    return undefined;\n  }\n\n  // If target is undefined, return source\n  if (base === undefined) {\n    return overrides;\n  }\n\n  // If source is undefined, return target\n  if (overrides === undefined) {\n    return base;\n  }\n\n  // Create a new object to avoid mutating the inputs\n  const result = { ...base } as T & U;\n\n  // Iterate through all keys in the source object\n  for (const key in overrides) {\n    if (Object.prototype.hasOwnProperty.call(overrides, key)) {\n      const overridesValue = overrides[key];\n\n      // Skip if the overrides value is undefined\n      if (overridesValue === undefined) continue;\n\n      // Get the base value if it exists\n      const baseValue =\n        key in base ? base[key as unknown as keyof T] : undefined;\n\n      // Check if both values are objects that can be deeply merged\n      const isSourceObject =\n        overridesValue !== null &&\n        typeof overridesValue === 'object' &&\n        !Array.isArray(overridesValue) &&\n        !(overridesValue instanceof Date) &&\n        !(overridesValue instanceof RegExp);\n\n      const isTargetObject =\n        baseValue !== null &&\n        baseValue !== undefined &&\n        typeof baseValue === 'object' &&\n        !Array.isArray(baseValue) &&\n        !(baseValue instanceof Date) &&\n        !(baseValue instanceof RegExp);\n\n      // If both values are mergeable objects, merge them recursively\n      if (isSourceObject && isTargetObject) {\n        result[key as keyof (T & U)] = mergeObjects(\n          baseValue as object,\n          overridesValue as object,\n        ) as any;\n      } else {\n        // For primitives, arrays, or when one value is not a mergeable object,\n        // simply override with the source value\n        result[key as keyof (T & U)] = overridesValue as any;\n      }\n    }\n  }\n\n  return result;\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay,\n}: {\n  error: APICallError;\n  exponentialBackoffDelay: number;\n}): number {\n  const headers = error.responseHeaders;\n\n  if (!headers) return exponentialBackoffDelay;\n\n  let ms: number | undefined;\n\n  // retry-ms is more precise than retry-after and used by e.g. OpenAI\n  const retryAfterMs = headers['retry-after-ms'];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n\n  // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n  const retryAfter = headers['retry-after'];\n  if (retryAfter && ms === undefined) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1000;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n\n  // check that the delay is reasonable:\n  if (\n    ms != null &&\n    !Number.isNaN(ms) &&\n    0 <= ms &&\n    (ms < 60 * 1000 || ms < exponentialBackoffDelay)\n  ) {\n    return ms;\n  }\n\n  return exponentialBackoffDelay;\n}\n\n/**\nThe `retryWithExponentialBackoffRespectingRetryHeaders` strategy retries a failed API call with an exponential backoff,\nwhile respecting rate limit headers (retry-after-ms and retry-after) if they are provided and reasonable (0-60 seconds).\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoffRespectingRetryHeaders =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n    abortSignal,\n  }: {\n    maxRetries?: number;\n    initialDelayInMs?: number;\n    backoffFactor?: number;\n    abortSignal?: AbortSignal;\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n      abortSignal,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n    abortSignal,\n  }: {\n    maxRetries: number;\n    delayInMs: number;\n    backoffFactor: number;\n    abortSignal: AbortSignal | undefined;\n  },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs,\n        }),\n        { abortSignal },\n      );\n\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal,\n        },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n","import { InvalidArgumentError } from '../error/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoffRespectingRetryHeaders,\n} from '../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n  abortSignal,\n}: {\n  maxRetries: number | undefined;\n  abortSignal: AbortSignal | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal,\n    }),\n  };\n}\n","import {\n  ModelMessage,\n  ToolApprovalRequest,\n  ToolApprovalResponse,\n} from '@ai-sdk/provider-utils';\nimport { InvalidToolApprovalError } from '../error/invalid-tool-approval-error';\nimport { ToolCallNotFoundForApprovalError } from '../error/tool-call-not-found-for-approval-error';\nimport { TypedToolCall } from './tool-call';\nimport { TypedToolResult } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type CollectedToolApprovals<TOOLS extends ToolSet> = {\n  approvalRequest: ToolApprovalRequest;\n  approvalResponse: ToolApprovalResponse;\n  toolCall: TypedToolCall<TOOLS>;\n};\n\n/**\n * If the last message is a tool message, this function collects all tool approvals\n * from that message.\n */\nexport function collectToolApprovals<TOOLS extends ToolSet>({\n  messages,\n}: {\n  messages: ModelMessage[];\n}): {\n  approvedToolApprovals: Array<CollectedToolApprovals<TOOLS>>;\n  deniedToolApprovals: Array<CollectedToolApprovals<TOOLS>>;\n} {\n  const lastMessage = messages.at(-1);\n\n  if (lastMessage?.role != 'tool') {\n    return {\n      approvedToolApprovals: [],\n      deniedToolApprovals: [],\n    };\n  }\n\n  // gather tool calls and prepare lookup\n  const toolCallsByToolCallId: Record<string, TypedToolCall<TOOLS>> = {};\n  for (const message of messages) {\n    if (message.role === 'assistant' && typeof message.content !== 'string') {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === 'tool-call') {\n          toolCallsByToolCallId[part.toolCallId] = part as TypedToolCall<TOOLS>;\n        }\n      }\n    }\n  }\n\n  // gather approval responses and prepare lookup\n  const toolApprovalRequestsByApprovalId: Record<string, ToolApprovalRequest> =\n    {};\n  for (const message of messages) {\n    if (message.role === 'assistant' && typeof message.content !== 'string') {\n      const content = message.content;\n      for (const part of content) {\n        if (part.type === 'tool-approval-request') {\n          toolApprovalRequestsByApprovalId[part.approvalId] = part;\n        }\n      }\n    }\n  }\n\n  // gather tool results from the last tool message\n  const toolResults: Record<string, TypedToolResult<TOOLS>> = {};\n  for (const part of lastMessage.content) {\n    if (part.type === 'tool-result') {\n      toolResults[part.toolCallId] = part as TypedToolResult<TOOLS>;\n    }\n  }\n\n  const approvedToolApprovals: Array<CollectedToolApprovals<TOOLS>> = [];\n  const deniedToolApprovals: Array<CollectedToolApprovals<TOOLS>> = [];\n\n  const approvalResponses = lastMessage.content.filter(\n    part => part.type === 'tool-approval-response',\n  );\n  for (const approvalResponse of approvalResponses) {\n    const approvalRequest =\n      toolApprovalRequestsByApprovalId[approvalResponse.approvalId];\n\n    if (approvalRequest == null) {\n      throw new InvalidToolApprovalError({\n        approvalId: approvalResponse.approvalId,\n      });\n    }\n\n    if (toolResults[approvalRequest.toolCallId] != null) {\n      continue;\n    }\n\n    const toolCall = toolCallsByToolCallId[approvalRequest.toolCallId];\n    if (toolCall == null) {\n      throw new ToolCallNotFoundForApprovalError({\n        toolCallId: approvalRequest.toolCallId,\n        approvalId: approvalRequest.approvalId,\n      });\n    }\n\n    const approval: CollectedToolApprovals<TOOLS> = {\n      approvalRequest,\n      approvalResponse,\n      toolCall,\n    };\n\n    if (approvalResponse.approved) {\n      approvedToolApprovals.push(approval);\n    } else {\n      deniedToolApprovals.push(approval);\n    }\n  }\n\n  return { approvedToolApprovals, deniedToolApprovals };\n}\n","import { executeTool, ModelMessage } from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { recordErrorOnSpan, recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { TypedToolCall } from './tool-call';\nimport { ToolOutput } from './tool-output';\nimport { ToolSet } from './tool-set';\nimport { TypedToolResult } from './tool-result';\nimport { TypedToolError } from './tool-error';\n\nexport async function executeToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  tracer,\n  telemetry,\n  messages,\n  abortSignal,\n  experimental_context,\n  onPreliminaryToolResult,\n}: {\n  toolCall: TypedToolCall<TOOLS>;\n  tools: TOOLS | undefined;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  messages: ModelMessage[];\n  abortSignal: AbortSignal | undefined;\n  experimental_context: unknown;\n  onPreliminaryToolResult?: (result: TypedToolResult<TOOLS>) => void;\n}): Promise<ToolOutput<TOOLS> | undefined> {\n  const { toolName, toolCallId, input } = toolCall;\n  const tool = tools?.[toolName];\n\n  if (tool?.execute == null) {\n    return undefined;\n  }\n\n  return recordSpan({\n    name: 'ai.toolCall',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({\n          operationId: 'ai.toolCall',\n          telemetry,\n        }),\n        'ai.toolCall.name': toolName,\n        'ai.toolCall.id': toolCallId,\n        'ai.toolCall.args': {\n          output: () => JSON.stringify(input),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      let output: unknown;\n\n      try {\n        const stream = executeTool({\n          execute: tool.execute!.bind(tool),\n          input,\n          options: {\n            toolCallId,\n            messages,\n            abortSignal,\n            experimental_context,\n          },\n        });\n\n        for await (const part of stream) {\n          if (part.type === 'preliminary') {\n            onPreliminaryToolResult?.({\n              ...toolCall,\n              type: 'tool-result',\n              output: part.output,\n              preliminary: true,\n            });\n          } else {\n            output = part.output;\n          }\n        }\n      } catch (error) {\n        recordErrorOnSpan(span, error);\n        return {\n          type: 'tool-error',\n          toolCallId,\n          toolName,\n          input,\n          error,\n          dynamic: tool.type === 'dynamic',\n          ...(toolCall.providerMetadata != null\n            ? { providerMetadata: toolCall.providerMetadata }\n            : {}),\n        } as TypedToolError<TOOLS>;\n      }\n\n      try {\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.toolCall.result': {\n                output: () => JSON.stringify(output),\n              },\n            },\n          }),\n        );\n      } catch (ignored) {\n        // JSON stringify might fail if the result is not serializable,\n        // in which case we just ignore it. In the future we might want to\n        // add an optional serialize method to the tool interface and warn\n        // if the result is not serializable.\n      }\n\n      return {\n        type: 'tool-result',\n        toolCallId,\n        toolName,\n        input,\n        output,\n        dynamic: tool.type === 'dynamic',\n        ...(toolCall.providerMetadata != null\n          ? { providerMetadata: toolCall.providerMetadata }\n          : {}),\n      } as TypedToolResult<TOOLS>;\n    },\n  });\n}\n","import { LanguageModelV3Content, LanguageModelV3Text } from '@ai-sdk/provider';\n\nexport function extractTextContent(\n  content: LanguageModelV3Content[],\n): string | undefined {\n  const parts = content.filter(\n    (content): content is LanguageModelV3Text => content.type === 'text',\n  );\n\n  if (parts.length === 0) {\n    return undefined;\n  }\n\n  return parts.map(content => content.text).join('');\n}\n","import {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n} from '@ai-sdk/provider-utils';\n\n/**\n * A generated file.\n */\nexport interface GeneratedFile {\n  /**\nFile as a base64 encoded string.\n     */\n  readonly base64: string;\n\n  /**\nFile as a Uint8Array.\n     */\n  readonly uint8Array: Uint8Array;\n\n  /**\nThe IANA media type of the file.\n\n@see https://www.iana.org/assignments/media-types/media-types.xhtml\n   */\n  readonly mediaType: string;\n}\n\nexport class DefaultGeneratedFile implements GeneratedFile {\n  private base64Data: string | undefined;\n  private uint8ArrayData: Uint8Array | undefined;\n\n  readonly mediaType: string;\n\n  constructor({\n    data,\n    mediaType,\n  }: {\n    data: string | Uint8Array;\n    mediaType: string;\n  }) {\n    const isUint8Array = data instanceof Uint8Array;\n    this.base64Data = isUint8Array ? undefined : data;\n    this.uint8ArrayData = isUint8Array ? data : undefined;\n    this.mediaType = mediaType;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get base64() {\n    if (this.base64Data == null) {\n      this.base64Data = convertUint8ArrayToBase64(this.uint8ArrayData!);\n    }\n    return this.base64Data;\n  }\n\n  // lazy conversion with caching to avoid unnecessary conversion overhead:\n  get uint8Array() {\n    if (this.uint8ArrayData == null) {\n      this.uint8ArrayData = convertBase64ToUint8Array(this.base64Data!);\n    }\n    return this.uint8ArrayData;\n  }\n}\n\nexport class DefaultGeneratedFileWithType extends DefaultGeneratedFile {\n  readonly type = 'file';\n\n  constructor(options: { data: string | Uint8Array; mediaType: string }) {\n    super(options);\n  }\n}\n","import { ModelMessage } from '@ai-sdk/provider-utils';\nimport { TypedToolCall } from './tool-call';\nimport { ToolSet } from './tool-set';\n\nexport async function isApprovalNeeded<TOOLS extends ToolSet>({\n  tool,\n  toolCall,\n  messages,\n  experimental_context,\n}: {\n  tool: TOOLS[keyof TOOLS];\n  toolCall: TypedToolCall<TOOLS>;\n  messages: ModelMessage[];\n  experimental_context: unknown;\n}) {\n  if (tool.needsApproval == null) {\n    return false;\n  }\n\n  if (typeof tool.needsApproval === 'boolean') {\n    return tool.needsApproval;\n  }\n\n  return await tool.needsApproval(toolCall.input, {\n    toolCallId: toolCall.toolCallId,\n    messages,\n    experimental_context,\n  });\n}\n","import {\n  JSONValue,\n  LanguageModelV3CallOptions,\n  TypeValidationError,\n} from '@ai-sdk/provider';\nimport {\n  asSchema,\n  FlexibleSchema,\n  resolve,\n  safeParseJSON,\n  safeValidateTypes,\n} from '@ai-sdk/provider-utils';\nimport { NoObjectGeneratedError } from '../error/no-object-generated-error';\nimport { FinishReason } from '../types/language-model';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { LanguageModelUsage } from '../types/usage';\nimport { DeepPartial } from '../util/deep-partial';\nimport { parsePartialJson } from '../util/parse-partial-json';\n\nexport interface Output<OUTPUT = any, PARTIAL = any> {\n  /**\n   * The response format to use for the model.\n   */\n  responseFormat: PromiseLike<LanguageModelV3CallOptions['responseFormat']>;\n\n  /**\n   * Parses the complete output of the model.\n   */\n  parseCompleteOutput(\n    options: { text: string },\n    context: {\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): Promise<OUTPUT>;\n\n  /**\n   * Parses the partial output of the model.\n   */\n  parsePartialOutput(options: {\n    text: string;\n  }): Promise<{ partial: PARTIAL } | undefined>;\n}\n\n/**\n * Output specification for text generation.\n * This is the default output mode that generates plain text.\n *\n * @returns An output specification for generating text.\n */\nexport const text = (): Output<string, string> => ({\n  responseFormat: Promise.resolve({ type: 'text' }),\n\n  async parseCompleteOutput({ text }: { text: string }) {\n    return text;\n  },\n\n  async parsePartialOutput({ text }: { text: string }) {\n    return { partial: text };\n  },\n});\n\n/**\n * Output specification for typed object generation using schemas.\n * When the model generates a text response, it will return an object that matches the schema.\n *\n * @param schema - The schema of the object to generate.\n * @param name - Optional name of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n * @param description - Optional description of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n *\n * @returns An output specification for generating objects with the specified schema.\n */\nexport const object = <OBJECT>({\n  schema: inputSchema,\n  name,\n  description,\n}: {\n  schema: FlexibleSchema<OBJECT>;\n  /**\n   * Optional name of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n   */\n  name?: string;\n  /**\n   * Optional description of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n   */\n  description?: string;\n}): Output<OBJECT, DeepPartial<OBJECT>> => {\n  const schema = asSchema(inputSchema);\n\n  return {\n    responseFormat: resolve(schema.jsonSchema).then(jsonSchema => ({\n      type: 'json' as const,\n      schema: jsonSchema,\n      ...(name != null && { name }),\n      ...(description != null && { description }),\n    })),\n\n    async parseCompleteOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = await safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const validationResult = await safeValidateTypes({\n        value: parseResult.value,\n        schema,\n      });\n\n      if (!validationResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: validationResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return validationResult.value;\n    },\n\n    async parsePartialOutput({ text }: { text: string }) {\n      const result = await parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input': {\n          return undefined;\n        }\n\n        case 'repaired-parse':\n        case 'successful-parse': {\n          return {\n            // Note: currently no validation of partial results:\n            partial: result.value as DeepPartial<OBJECT>,\n          };\n        }\n      }\n    },\n  };\n};\n\n/**\n * Output specification for array generation.\n * When the model generates a text response, it will return an array of elements.\n *\n * @param element - The schema of the array elements to generate.\n * @param name - Optional name of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n * @param description - Optional description of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n *\n * @returns An output specification for generating an array of elements.\n */\nexport const array = <ELEMENT>({\n  element: inputElementSchema,\n  name,\n  description,\n}: {\n  element: FlexibleSchema<ELEMENT>;\n  /**\n   * Optional name of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n   */\n  name?: string;\n  /**\n   * Optional description of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n   */\n  description?: string;\n}): Output<Array<ELEMENT>, Array<ELEMENT>> => {\n  const elementSchema = asSchema(inputElementSchema);\n\n  return {\n    // JSON schema that describes an array of elements:\n    responseFormat: resolve(elementSchema.jsonSchema).then(jsonSchema => {\n      // remove $schema from schema.jsonSchema:\n      const { $schema, ...itemSchema } = jsonSchema;\n\n      return {\n        type: 'json' as const,\n        schema: {\n          $schema: 'http://json-schema.org/draft-07/schema#',\n          type: 'object',\n          properties: {\n            elements: { type: 'array', items: itemSchema },\n          },\n          required: ['elements'],\n          additionalProperties: false,\n        },\n        ...(name != null && { name }),\n        ...(description != null && { description }),\n      };\n    }),\n\n    async parseCompleteOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = await safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const outerValue = parseResult.value;\n\n      if (\n        outerValue == null ||\n        typeof outerValue !== 'object' ||\n        !('elements' in outerValue) ||\n        !Array.isArray(outerValue.elements)\n      ) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: new TypeValidationError({\n            value: outerValue,\n            cause: 'response must be an object with an elements array',\n          }),\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      for (const element of outerValue.elements) {\n        const validationResult = await safeValidateTypes({\n          value: element,\n          schema: elementSchema,\n        });\n\n        if (!validationResult.success) {\n          throw new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            cause: validationResult.error,\n            text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          });\n        }\n      }\n\n      return outerValue.elements as Array<ELEMENT>;\n    },\n\n    async parsePartialOutput({ text }: { text: string }) {\n      const result = await parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input': {\n          return undefined;\n        }\n\n        case 'repaired-parse':\n        case 'successful-parse': {\n          const outerValue = result.value;\n\n          // no parsable elements array\n          if (\n            outerValue == null ||\n            typeof outerValue !== 'object' ||\n            !('elements' in outerValue) ||\n            !Array.isArray(outerValue.elements)\n          ) {\n            return undefined;\n          }\n\n          const rawElements =\n            result.state === 'repaired-parse' && outerValue.elements.length > 0\n              ? outerValue.elements.slice(0, -1)\n              : outerValue.elements;\n\n          const parsedElements: Array<ELEMENT> = [];\n          for (const rawElement of rawElements) {\n            const validationResult = await safeValidateTypes({\n              value: rawElement,\n              schema: elementSchema,\n            });\n\n            if (validationResult.success) {\n              parsedElements.push(validationResult.value);\n            }\n          }\n\n          return { partial: parsedElements };\n        }\n      }\n    },\n  };\n};\n\n/**\n * Output specification for choice generation.\n * When the model generates a text response, it will return a one of the choice options.\n *\n * @param options - The available choices.\n * @param name - Optional name of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n * @param description - Optional description of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n *\n * @returns An output specification for generating a choice.\n */\nexport const choice = <CHOICE extends string>({\n  options: choiceOptions,\n  name,\n  description,\n}: {\n  options: Array<CHOICE>;\n  /**\n   * Optional name of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n   */\n  name?: string;\n  /**\n   * Optional description of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n   */\n  description?: string;\n}): Output<CHOICE, CHOICE> => {\n  return {\n    // JSON schema that describes an enumeration:\n    responseFormat: Promise.resolve({\n      type: 'json',\n      schema: {\n        $schema: 'http://json-schema.org/draft-07/schema#',\n        type: 'object',\n        properties: {\n          result: { type: 'string', enum: choiceOptions },\n        },\n        required: ['result'],\n        additionalProperties: false,\n      },\n      ...(name != null && { name }),\n      ...(description != null && { description }),\n    } as const),\n\n    async parseCompleteOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = await safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      const outerValue = parseResult.value;\n\n      if (\n        outerValue == null ||\n        typeof outerValue !== 'object' ||\n        !('result' in outerValue) ||\n        typeof outerValue.result !== 'string' ||\n        !choiceOptions.includes(outerValue.result as any)\n      ) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: response did not match schema.',\n          cause: new TypeValidationError({\n            value: outerValue,\n            cause: 'response must be an object that contains a choice value.',\n          }),\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return outerValue.result as CHOICE;\n    },\n\n    async parsePartialOutput({ text }: { text: string }) {\n      const result = await parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input': {\n          return undefined;\n        }\n\n        case 'repaired-parse':\n        case 'successful-parse': {\n          const outerValue = result.value;\n\n          if (\n            outerValue == null ||\n            typeof outerValue !== 'object' ||\n            !('result' in outerValue) ||\n            typeof outerValue.result !== 'string'\n          ) {\n            return undefined;\n          }\n\n          // list of potential matches.\n          const potentialMatches = choiceOptions.filter(choiceOption =>\n            choiceOption.startsWith(outerValue.result as string),\n          );\n\n          if (result.state === 'successful-parse') {\n            // successful parse: exact choice value\n            return potentialMatches.includes(outerValue.result as any)\n              ? { partial: outerValue.result as CHOICE }\n              : undefined;\n          } else {\n            // repaired parse: only return if not ambiguous\n            return potentialMatches.length === 1\n              ? { partial: potentialMatches[0] as CHOICE }\n              : undefined;\n          }\n        }\n      }\n    },\n  };\n};\n\n/**\n * Output specification for unstructured JSON generation.\n * When the model generates a text response, it will return a JSON object.\n *\n * @param name - Optional name of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n * @param description - Optional description of the output that should be generated. Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n *\n * @returns An output specification for generating JSON.\n */\nexport const json = ({\n  name,\n  description,\n}: {\n  /**\n   * Optional name of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema name.\n   */\n  name?: string;\n  /**\n   * Optional description of the output that should be generated.\n   * Used by some providers for additional LLM guidance, e.g. via tool or schema description.\n   */\n  description?: string;\n} = {}): Output<JSONValue, JSONValue> => {\n  return {\n    responseFormat: Promise.resolve({\n      type: 'json' as const,\n      ...(name != null && { name }),\n      ...(description != null && { description }),\n    }),\n\n    async parseCompleteOutput(\n      { text }: { text: string },\n      context: {\n        response: LanguageModelResponseMetadata;\n        usage: LanguageModelUsage;\n        finishReason: FinishReason;\n      },\n    ) {\n      const parseResult = await safeParseJSON({ text });\n\n      if (!parseResult.success) {\n        throw new NoObjectGeneratedError({\n          message: 'No object generated: could not parse the response.',\n          cause: parseResult.error,\n          text,\n          response: context.response,\n          usage: context.usage,\n          finishReason: context.finishReason,\n        });\n      }\n\n      return parseResult.value;\n    },\n\n    async parsePartialOutput({ text }: { text: string }) {\n      const result = await parsePartialJson(text);\n\n      switch (result.state) {\n        case 'failed-parse':\n        case 'undefined-input': {\n          return undefined;\n        }\n\n        case 'repaired-parse':\n        case 'successful-parse': {\n          return result.value === undefined\n            ? undefined\n            : { partial: result.value };\n        }\n      }\n    },\n  };\n};\n","import { JSONValue } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { fixJson } from './fix-json';\n\nexport async function parsePartialJson(jsonText: string | undefined): Promise<{\n  value: JSONValue | undefined;\n  state:\n    | 'undefined-input'\n    | 'successful-parse'\n    | 'repaired-parse'\n    | 'failed-parse';\n}> {\n  if (jsonText === undefined) {\n    return { value: undefined, state: 'undefined-input' };\n  }\n\n  let result = await safeParseJSON({ text: jsonText });\n\n  if (result.success) {\n    return { value: result.value, state: 'successful-parse' };\n  }\n\n  result = await safeParseJSON({ text: fixJson(jsonText) });\n\n  if (result.success) {\n    return { value: result.value, state: 'repaired-parse' };\n  }\n\n  return { value: undefined, state: 'failed-parse' };\n}\n","type State =\n  | 'ROOT'\n  | 'FINISH'\n  | 'INSIDE_STRING'\n  | 'INSIDE_STRING_ESCAPE'\n  | 'INSIDE_LITERAL'\n  | 'INSIDE_NUMBER'\n  | 'INSIDE_OBJECT_START'\n  | 'INSIDE_OBJECT_KEY'\n  | 'INSIDE_OBJECT_AFTER_KEY'\n  | 'INSIDE_OBJECT_BEFORE_VALUE'\n  | 'INSIDE_OBJECT_AFTER_VALUE'\n  | 'INSIDE_OBJECT_AFTER_COMMA'\n  | 'INSIDE_ARRAY_START'\n  | 'INSIDE_ARRAY_AFTER_VALUE'\n  | 'INSIDE_ARRAY_AFTER_COMMA';\n\n// Implemented as a scanner with additional fixing\n// that performs a single linear time scan pass over the partial JSON.\n//\n// The states should ideally match relevant states from the JSON spec:\n// https://www.json.org/json-en.html\n//\n// Please note that invalid JSON is not considered/covered, because it\n// is assumed that the resulting JSON will be processed by a standard\n// JSON parser that will detect any invalid JSON.\nexport function fixJson(input: string): string {\n  const stack: State[] = ['ROOT'];\n  let lastValidIndex = -1;\n  let literalStart: number | null = null;\n\n  function processValueStart(char: string, i: number, swapState: State) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_STRING');\n          break;\n        }\n\n        case 'f':\n        case 't':\n        case 'n': {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_LITERAL');\n          break;\n        }\n\n        case '-': {\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n        case '0':\n        case '1':\n        case '2':\n        case '3':\n        case '4':\n        case '5':\n        case '6':\n        case '7':\n        case '8':\n        case '9': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_NUMBER');\n          break;\n        }\n\n        case '{': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_OBJECT_START');\n          break;\n        }\n\n        case '[': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push('INSIDE_ARRAY_START');\n          break;\n        }\n      }\n    }\n  }\n\n  function processAfterObjectValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_OBJECT_AFTER_COMMA');\n        break;\n      }\n      case '}': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  function processAfterArrayValue(char: string, i: number) {\n    switch (char) {\n      case ',': {\n        stack.pop();\n        stack.push('INSIDE_ARRAY_AFTER_COMMA');\n        break;\n      }\n      case ']': {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n\n    switch (currentState) {\n      case 'ROOT':\n        processValueStart(char, i, 'FINISH');\n        break;\n\n      case 'INSIDE_OBJECT_START': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n          case '}': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_COMMA': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_AFTER_KEY');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_KEY': {\n        switch (char) {\n          case ':': {\n            stack.pop();\n            stack.push('INSIDE_OBJECT_BEFORE_VALUE');\n\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_OBJECT_BEFORE_VALUE': {\n        processValueStart(char, i, 'INSIDE_OBJECT_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        processAfterObjectValue(char, i);\n        break;\n      }\n\n      case 'INSIDE_STRING': {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n\n          case '\\\\': {\n            stack.push('INSIDE_STRING_ESCAPE');\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START': {\n        switch (char) {\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n            break;\n          }\n        }\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        switch (char) {\n          case ',': {\n            stack.pop();\n            stack.push('INSIDE_ARRAY_AFTER_COMMA');\n            break;\n          }\n\n          case ']': {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_ARRAY_AFTER_COMMA': {\n        processValueStart(char, i, 'INSIDE_ARRAY_AFTER_VALUE');\n        break;\n      }\n\n      case 'INSIDE_STRING_ESCAPE': {\n        stack.pop();\n        lastValidIndex = i;\n\n        break;\n      }\n\n      case 'INSIDE_NUMBER': {\n        switch (char) {\n          case '0':\n          case '1':\n          case '2':\n          case '3':\n          case '4':\n          case '5':\n          case '6':\n          case '7':\n          case '8':\n          case '9': {\n            lastValidIndex = i;\n            break;\n          }\n\n          case 'e':\n          case 'E':\n          case '-':\n          case '.': {\n            break;\n          }\n\n          case ',': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case '}': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n              processAfterObjectValue(char, i);\n            }\n\n            break;\n          }\n\n          case ']': {\n            stack.pop();\n\n            if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n              processAfterArrayValue(char, i);\n            }\n\n            break;\n          }\n\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, i + 1);\n\n        if (\n          !'false'.startsWith(partialLiteral) &&\n          !'true'.startsWith(partialLiteral) &&\n          !'null'.startsWith(partialLiteral)\n        ) {\n          stack.pop();\n\n          if (stack[stack.length - 1] === 'INSIDE_OBJECT_AFTER_VALUE') {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === 'INSIDE_ARRAY_AFTER_VALUE') {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n\n        break;\n      }\n    }\n  }\n\n  let result = input.slice(0, lastValidIndex + 1);\n\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n\n    switch (state) {\n      case 'INSIDE_STRING': {\n        result += '\"';\n        break;\n      }\n\n      case 'INSIDE_OBJECT_KEY':\n      case 'INSIDE_OBJECT_AFTER_KEY':\n      case 'INSIDE_OBJECT_AFTER_COMMA':\n      case 'INSIDE_OBJECT_START':\n      case 'INSIDE_OBJECT_BEFORE_VALUE':\n      case 'INSIDE_OBJECT_AFTER_VALUE': {\n        result += '}';\n        break;\n      }\n\n      case 'INSIDE_ARRAY_START':\n      case 'INSIDE_ARRAY_AFTER_COMMA':\n      case 'INSIDE_ARRAY_AFTER_VALUE': {\n        result += ']';\n        break;\n      }\n\n      case 'INSIDE_LITERAL': {\n        const partialLiteral = input.substring(literalStart!, input.length);\n\n        if ('true'.startsWith(partialLiteral)) {\n          result += 'true'.slice(partialLiteral.length);\n        } else if ('false'.startsWith(partialLiteral)) {\n          result += 'false'.slice(partialLiteral.length);\n        } else if ('null'.startsWith(partialLiteral)) {\n          result += 'null'.slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n","import { LanguageModelV3ToolCall } from '@ai-sdk/provider';\nimport {\n  asSchema,\n  ModelMessage,\n  safeParseJSON,\n  safeValidateTypes,\n  SystemModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { InvalidToolInputError } from '../error/invalid-tool-input-error';\nimport { NoSuchToolError } from '../error/no-such-tool-error';\nimport { ToolCallRepairError } from '../error/tool-call-repair-error';\nimport { DynamicToolCall, TypedToolCall } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair-function';\nimport { ToolSet } from './tool-set';\n\nexport async function parseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n  repairToolCall,\n  system,\n  messages,\n}: {\n  toolCall: LanguageModelV3ToolCall;\n  tools: TOOLS | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  system: string | SystemModelMessage | Array<SystemModelMessage> | undefined;\n  messages: ModelMessage[];\n}): Promise<TypedToolCall<TOOLS>> {\n  try {\n    if (tools == null) {\n      // provider-executed dynamic tools are not part of our list of tools:\n      if (toolCall.providerExecuted && toolCall.dynamic) {\n        return await parseProviderExecutedDynamicToolCall(toolCall);\n      }\n\n      throw new NoSuchToolError({ toolName: toolCall.toolName });\n    }\n\n    try {\n      return await doParseToolCall({ toolCall, tools });\n    } catch (error) {\n      if (\n        repairToolCall == null ||\n        !(\n          NoSuchToolError.isInstance(error) ||\n          InvalidToolInputError.isInstance(error)\n        )\n      ) {\n        throw error;\n      }\n\n      let repairedToolCall: LanguageModelV3ToolCall | null = null;\n\n      try {\n        repairedToolCall = await repairToolCall({\n          toolCall,\n          tools,\n          inputSchema: async ({ toolName }) => {\n            const { inputSchema } = tools[toolName];\n            return await asSchema(inputSchema).jsonSchema;\n          },\n          system,\n          messages,\n          error,\n        });\n      } catch (repairError) {\n        throw new ToolCallRepairError({\n          cause: repairError,\n          originalError: error,\n        });\n      }\n\n      // no repaired tool call returned\n      if (repairedToolCall == null) {\n        throw error;\n      }\n\n      return await doParseToolCall({ toolCall: repairedToolCall, tools });\n    }\n  } catch (error) {\n    // use parsed input when possible\n    const parsedInput = await safeParseJSON({ text: toolCall.input });\n    const input = parsedInput.success ? parsedInput.value : toolCall.input;\n\n    // TODO AI SDK 6: special invalid tool call parts\n    return {\n      type: 'tool-call',\n      toolCallId: toolCall.toolCallId,\n      toolName: toolCall.toolName,\n      input,\n      dynamic: true,\n      invalid: true,\n      error,\n      title: tools?.[toolCall.toolName]?.title,\n      providerExecuted: toolCall.providerExecuted,\n      providerMetadata: toolCall.providerMetadata,\n    };\n  }\n}\n\nasync function parseProviderExecutedDynamicToolCall(\n  toolCall: LanguageModelV3ToolCall,\n): Promise<DynamicToolCall> {\n  const parseResult =\n    toolCall.input.trim() === ''\n      ? { success: true as const, value: {} }\n      : await safeParseJSON({ text: toolCall.input });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName: toolCall.toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error,\n    });\n  }\n\n  return {\n    type: 'tool-call',\n    toolCallId: toolCall.toolCallId,\n    toolName: toolCall.toolName,\n    input: parseResult.value,\n    providerExecuted: true,\n    dynamic: true,\n    providerMetadata: toolCall.providerMetadata,\n  };\n}\n\nasync function doParseToolCall<TOOLS extends ToolSet>({\n  toolCall,\n  tools,\n}: {\n  toolCall: LanguageModelV3ToolCall;\n  tools: TOOLS;\n}): Promise<TypedToolCall<TOOLS>> {\n  const toolName = toolCall.toolName as keyof TOOLS & string;\n\n  const tool = tools[toolName];\n\n  if (tool == null) {\n    // provider-executed dynamic tools are not part of our list of tools:\n    if (toolCall.providerExecuted && toolCall.dynamic) {\n      return await parseProviderExecutedDynamicToolCall(toolCall);\n    }\n\n    throw new NoSuchToolError({\n      toolName: toolCall.toolName,\n      availableTools: Object.keys(tools),\n    });\n  }\n\n  const schema = asSchema(tool.inputSchema);\n\n  // when the tool call has no arguments, we try passing an empty object to the schema\n  // (many LLMs generate empty strings for tool calls with no arguments)\n  const parseResult =\n    toolCall.input.trim() === ''\n      ? await safeValidateTypes({ value: {}, schema })\n      : await safeParseJSON({ text: toolCall.input, schema });\n\n  if (parseResult.success === false) {\n    throw new InvalidToolInputError({\n      toolName,\n      toolInput: toolCall.input,\n      cause: parseResult.error,\n    });\n  }\n\n  return tool.type === 'dynamic'\n    ? {\n        type: 'tool-call',\n        toolCallId: toolCall.toolCallId,\n        toolName: toolCall.toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        dynamic: true,\n        title: tool.title,\n      }\n    : {\n        type: 'tool-call',\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        input: parseResult.value,\n        providerExecuted: toolCall.providerExecuted,\n        providerMetadata: toolCall.providerMetadata,\n        title: tool.title,\n      };\n}\n","import { ReasoningPart } from '@ai-sdk/provider-utils';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModelRequestMetadata,\n  LanguageModelResponseMetadata,\n  ProviderMetadata,\n} from '../types';\nimport { Source } from '../types/language-model';\nimport { LanguageModelUsage } from '../types/usage';\nimport { ContentPart } from './content-part';\nimport { GeneratedFile } from './generated-file';\nimport { ResponseMessage } from './response-message';\nimport { DynamicToolCall, StaticToolCall, TypedToolCall } from './tool-call';\nimport {\n  DynamicToolResult,\n  StaticToolResult,\n  TypedToolResult,\n} from './tool-result';\nimport { ToolSet } from './tool-set';\n\n/**\n * The result of a single step in the generation process.\n */\nexport type StepResult<TOOLS extends ToolSet> = {\n  /**\nThe content that was generated in the last step.\n   */\n  readonly content: Array<ContentPart<TOOLS>>;\n\n  /**\nThe generated text.\n*/\n  readonly text: string;\n\n  /**\nThe reasoning that was generated during the generation.\n*/\n  readonly reasoning: Array<ReasoningPart>;\n\n  /**\nThe reasoning text that was generated during the generation.\n*/\n  readonly reasoningText: string | undefined;\n\n  /**\nThe files that were generated during the generation.\n*/\n  readonly files: Array<GeneratedFile>;\n\n  /**\nThe sources that were used to generate the text.\n*/\n  readonly sources: Array<Source>;\n\n  /**\nThe tool calls that were made during the generation.\n*/\n  readonly toolCalls: Array<TypedToolCall<TOOLS>>;\n\n  /**\nThe static tool calls that were made in the last step.\n*/\n  readonly staticToolCalls: Array<StaticToolCall<TOOLS>>;\n\n  /**\nThe dynamic tool calls that were made in the last step.\n*/\n  readonly dynamicToolCalls: Array<DynamicToolCall>;\n\n  /**\nThe results of the tool calls.\n*/\n  readonly toolResults: Array<TypedToolResult<TOOLS>>;\n\n  /**\nThe static tool results that were made in the last step.\n*/\n  readonly staticToolResults: Array<StaticToolResult<TOOLS>>;\n\n  /**\nThe dynamic tool results that were made in the last step.\n*/\n  readonly dynamicToolResults: Array<DynamicToolResult>;\n\n  /**\n   * The unified reason why the generation finished.\n   */\n  readonly finishReason: FinishReason;\n\n  /**\n   * The raw reason why the generation finished (from the provider).\n   */\n  readonly rawFinishReason: string | undefined;\n\n  /**\nThe token usage of the generated text.\n*/\n  readonly usage: LanguageModelUsage;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  readonly warnings: CallWarning[] | undefined;\n\n  /**\nAdditional request information.\n   */\n  readonly request: LanguageModelRequestMetadata;\n\n  /**\nAdditional response information.\n*/\n  readonly response: LanguageModelResponseMetadata & {\n    /**\nThe response messages that were generated during the call.\nResponse messages can be either assistant messages or tool messages.\nThey contain a generated id.\n*/\n    readonly messages: Array<ResponseMessage>;\n\n    /**\nResponse body (available only for providers that use HTTP requests).\n     */\n    body?: unknown;\n  };\n\n  /**\nAdditional provider-specific metadata. They are passed through\nfrom the provider to the AI SDK and enable provider-specific\nresults that can be fully encapsulated in the provider.\n   */\n  readonly providerMetadata: ProviderMetadata | undefined;\n};\n\nexport class DefaultStepResult<TOOLS extends ToolSet>\n  implements StepResult<TOOLS>\n{\n  readonly content: StepResult<TOOLS>['content'];\n  readonly finishReason: StepResult<TOOLS>['finishReason'];\n  readonly rawFinishReason: StepResult<TOOLS>['rawFinishReason'];\n  readonly usage: StepResult<TOOLS>['usage'];\n  readonly warnings: StepResult<TOOLS>['warnings'];\n  readonly request: StepResult<TOOLS>['request'];\n  readonly response: StepResult<TOOLS>['response'];\n  readonly providerMetadata: StepResult<TOOLS>['providerMetadata'];\n\n  constructor({\n    content,\n    finishReason,\n    rawFinishReason,\n    usage,\n    warnings,\n    request,\n    response,\n    providerMetadata,\n  }: {\n    content: StepResult<TOOLS>['content'];\n    finishReason: StepResult<TOOLS>['finishReason'];\n    rawFinishReason: StepResult<TOOLS>['rawFinishReason'];\n    usage: StepResult<TOOLS>['usage'];\n    warnings: StepResult<TOOLS>['warnings'];\n    request: StepResult<TOOLS>['request'];\n    response: StepResult<TOOLS>['response'];\n    providerMetadata: StepResult<TOOLS>['providerMetadata'];\n  }) {\n    this.content = content;\n    this.finishReason = finishReason;\n    this.rawFinishReason = rawFinishReason;\n    this.usage = usage;\n    this.warnings = warnings;\n    this.request = request;\n    this.response = response;\n    this.providerMetadata = providerMetadata;\n  }\n\n  get text() {\n    return this.content\n      .filter(part => part.type === 'text')\n      .map(part => part.text)\n      .join('');\n  }\n\n  get reasoning() {\n    return this.content.filter(part => part.type === 'reasoning');\n  }\n\n  get reasoningText() {\n    return this.reasoning.length === 0\n      ? undefined\n      : this.reasoning.map(part => part.text).join('');\n  }\n\n  get files() {\n    return this.content\n      .filter(part => part.type === 'file')\n      .map(part => part.file);\n  }\n\n  get sources() {\n    return this.content.filter(part => part.type === 'source');\n  }\n\n  get toolCalls() {\n    return this.content.filter(part => part.type === 'tool-call');\n  }\n\n  get staticToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall): toolCall is StaticToolCall<TOOLS> =>\n        toolCall.dynamic !== true,\n    );\n  }\n\n  get dynamicToolCalls() {\n    return this.toolCalls.filter(\n      (toolCall): toolCall is DynamicToolCall => toolCall.dynamic === true,\n    );\n  }\n\n  get toolResults() {\n    return this.content.filter(part => part.type === 'tool-result');\n  }\n\n  get staticToolResults() {\n    return this.toolResults.filter(\n      (toolResult): toolResult is StaticToolResult<TOOLS> =>\n        toolResult.dynamic !== true,\n    );\n  }\n\n  get dynamicToolResults() {\n    return this.toolResults.filter(\n      (toolResult): toolResult is DynamicToolResult =>\n        toolResult.dynamic === true,\n    );\n  }\n}\n","import { StepResult } from './step-result';\nimport { ToolSet } from './tool-set';\n\nexport type StopCondition<TOOLS extends ToolSet> = (options: {\n  steps: Array<StepResult<TOOLS>>;\n}) => PromiseLike<boolean> | boolean;\n\nexport function stepCountIs(stepCount: number): StopCondition<any> {\n  return ({ steps }) => steps.length === stepCount;\n}\n\nexport function hasToolCall(toolName: string): StopCondition<any> {\n  return ({ steps }) =>\n    steps[steps.length - 1]?.toolCalls?.some(\n      toolCall => toolCall.toolName === toolName,\n    ) ?? false;\n}\n\nexport async function isStopConditionMet<TOOLS extends ToolSet>({\n  stopConditions,\n  steps,\n}: {\n  stopConditions: Array<StopCondition<TOOLS>>;\n  steps: Array<StepResult<TOOLS>>;\n}): Promise<boolean> {\n  return (\n    await Promise.all(stopConditions.map(condition => condition({ steps })))\n  ).some(result => result);\n}\n","import {\n  AssistantContent,\n  AssistantModelMessage,\n  ToolContent,\n  ToolModelMessage,\n} from '../prompt';\nimport { createToolModelOutput } from '../prompt/create-tool-model-output';\nimport { ContentPart } from './content-part';\nimport { ToolSet } from './tool-set';\n\n/**\nConverts the result of a `generateText` or `streamText` call to a list of response messages.\n */\nexport async function toResponseMessages<TOOLS extends ToolSet>({\n  content: inputContent,\n  tools,\n}: {\n  content: Array<ContentPart<TOOLS>>;\n  tools: TOOLS | undefined;\n}): Promise<Array<AssistantModelMessage | ToolModelMessage>> {\n  const responseMessages: Array<AssistantModelMessage | ToolModelMessage> = [];\n\n  const content: AssistantContent = [];\n  for (const part of inputContent) {\n    // Skip sources - they are response-only content that no provider expects back\n    if (part.type === 'source') {\n      continue;\n    }\n\n    // Skip non-provider-executed tool results/errors (they go in the tool message)\n    if (\n      (part.type === 'tool-result' || part.type === 'tool-error') &&\n      !part.providerExecuted\n    ) {\n      continue;\n    }\n\n    // Skip empty text\n    if (part.type === 'text' && part.text.length === 0) {\n      continue;\n    }\n\n    switch (part.type) {\n      case 'text':\n        content.push({\n          type: 'text',\n          text: part.text,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      case 'reasoning':\n        content.push({\n          type: 'reasoning',\n          text: part.text,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      case 'file':\n        content.push({\n          type: 'file',\n          data: part.file.base64,\n          mediaType: part.file.mediaType,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      case 'tool-call':\n        content.push({\n          type: 'tool-call',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          input: part.input,\n          providerExecuted: part.providerExecuted,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      case 'tool-result': {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools?.[part.toolName],\n          output: part.output,\n          errorMode: 'none',\n        });\n        content.push({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      }\n      case 'tool-error': {\n        const output = await createToolModelOutput({\n          toolCallId: part.toolCallId,\n          input: part.input,\n          tool: tools?.[part.toolName],\n          output: part.error,\n          errorMode: 'json',\n        });\n        content.push({\n          type: 'tool-result',\n          toolCallId: part.toolCallId,\n          toolName: part.toolName,\n          output,\n          providerOptions: part.providerMetadata,\n        });\n        break;\n      }\n      case 'tool-approval-request':\n        content.push({\n          type: 'tool-approval-request',\n          approvalId: part.approvalId,\n          toolCallId: part.toolCall.toolCallId,\n        });\n        break;\n    }\n  }\n\n  if (content.length > 0) {\n    responseMessages.push({\n      role: 'assistant',\n      content,\n    });\n  }\n\n  const toolResultContent: ToolContent = [];\n  for (const part of inputContent) {\n    if (\n      !(part.type === 'tool-result' || part.type === 'tool-error') ||\n      part.providerExecuted\n    ) {\n      continue;\n    }\n\n    const output = await createToolModelOutput({\n      toolCallId: part.toolCallId,\n      input: part.input,\n      tool: tools?.[part.toolName],\n      output: part.type === 'tool-result' ? part.output : part.error,\n      errorMode: part.type === 'tool-error' ? 'text' : 'none',\n    });\n\n    toolResultContent.push({\n      type: 'tool-result',\n      toolCallId: part.toolCallId,\n      toolName: part.toolName,\n      output,\n      ...(part.providerMetadata != null\n        ? { providerOptions: part.providerMetadata }\n        : {}),\n    });\n  }\n\n  if (toolResultContent.length > 0) {\n    responseMessages.push({\n      role: 'tool',\n      content: toolResultContent,\n    });\n  }\n\n  return responseMessages;\n}\n","import {\n  getErrorMessage,\n  LanguageModelV3,\n  LanguageModelV3FinishReason,\n  SharedV3Warning,\n} from '@ai-sdk/provider';\nimport {\n  createIdGenerator,\n  DelayedPromise,\n  IdGenerator,\n  isAbortError,\n  ProviderOptions,\n  ToolApprovalResponse,\n  ToolContent,\n} from '@ai-sdk/provider-utils';\nimport { Span } from '@opentelemetry/api';\nimport { ServerResponse } from 'node:http';\nimport { NoOutputGeneratedError } from '../error';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveLanguageModel } from '../model/resolve-model';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { createToolModelOutput } from '../prompt/create-tool-model-output';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { prepareToolsAndToolChoice } from '../prompt/prepare-tools-and-tool-choice';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { wrapGatewayError } from '../prompt/wrap-gateway-error';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { stringifyForTelemetry } from '../telemetry/stringify-for-telemetry';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { createTextStreamResponse } from '../text-stream/create-text-stream-response';\nimport { pipeTextStreamToResponse } from '../text-stream/pipe-text-stream-to-response';\nimport { LanguageModelRequestMetadata } from '../types';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n  ToolChoice,\n} from '../types/language-model';\nimport { ProviderMetadata } from '../types/provider-metadata';\nimport {\n  addLanguageModelUsage,\n  createNullLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { UIMessage } from '../ui';\nimport { createUIMessageStreamResponse } from '../ui-message-stream/create-ui-message-stream-response';\nimport { getResponseUIMessageId } from '../ui-message-stream/get-response-ui-message-id';\nimport { handleUIMessageStreamFinish } from '../ui-message-stream/handle-ui-message-stream-finish';\nimport { pipeUIMessageStreamToResponse } from '../ui-message-stream/pipe-ui-message-stream-to-response';\nimport {\n  InferUIMessageChunk,\n  UIMessageChunk,\n} from '../ui-message-stream/ui-message-chunks';\nimport { UIMessageStreamResponseInit } from '../ui-message-stream/ui-message-stream-response-init';\nimport { InferUIMessageData, InferUIMessageMetadata } from '../ui/ui-messages';\nimport { asArray } from '../util/as-array';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { consumeStream } from '../util/consume-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { DownloadFunction } from '../util/download/download-function';\nimport { mergeObjects } from '../util/merge-objects';\nimport { now as originalNow } from '../util/now';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { collectToolApprovals } from './collect-tool-approvals';\nimport { ContentPart } from './content-part';\nimport { executeToolCall } from './execute-tool-call';\nimport { Output, text } from './output';\nimport { InferCompleteOutput, InferPartialOutput } from './output-utils';\nimport { PrepareStepFunction } from './prepare-step';\nimport { ResponseMessage } from './response-message';\nimport {\n  runToolsTransformation,\n  SingleRequestTextStreamPart,\n} from './run-tools-transformation';\nimport { DefaultStepResult, StepResult } from './step-result';\nimport {\n  isStopConditionMet,\n  stepCountIs,\n  StopCondition,\n} from './stop-condition';\nimport {\n  ConsumeStreamOptions,\n  StreamTextResult,\n  TextStreamPart,\n  UIMessageStreamOptions,\n} from './stream-text-result';\nimport { toResponseMessages } from './to-response-messages';\nimport { TypedToolCall } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair-function';\nimport { ToolOutput } from './tool-output';\nimport { StaticToolOutputDenied } from './tool-output-denied';\nimport { ToolSet } from './tool-set';\n\nconst originalGenerateId = createIdGenerator({\n  prefix: 'aitxt',\n  size: 24,\n});\n\n/**\nA transformation that is applied to the stream.\n\n@param stopStream - A function that stops the source stream.\n@param tools - The tools that are accessible to and can be called by the model. The model needs to support calling tools.\n */\nexport type StreamTextTransform<TOOLS extends ToolSet> = (options: {\n  tools: TOOLS; // for type inference\n  stopStream: () => void;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>;\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnErrorCallback = (event: {\n  error: unknown;\n}) => PromiseLike<void> | void;\n\n/**\nCallback that is set using the `onStepFinish` option.\n\n@param stepResult - The result of the step.\n */\nexport type StreamTextOnStepFinishCallback<TOOLS extends ToolSet> = (\n  stepResult: StepResult<TOOLS>,\n) => PromiseLike<void> | void;\n\n/**\nCallback that is set using the `onChunk` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnChunkCallback<TOOLS extends ToolSet> = (event: {\n  chunk: Extract<\n    TextStreamPart<TOOLS>,\n    {\n      type:\n        | 'text-delta'\n        | 'reasoning-delta'\n        | 'source'\n        | 'tool-call'\n        | 'tool-input-start'\n        | 'tool-input-delta'\n        | 'tool-result'\n        | 'raw';\n    }\n  >;\n}) => PromiseLike<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnFinishCallback<TOOLS extends ToolSet> = (\n  event: StepResult<TOOLS> & {\n    /**\n     * Details for all steps.\n     */\n    readonly steps: StepResult<TOOLS>[];\n\n    /**\n     * Total usage for all steps. This is the sum of the usage of all steps.\n     */\n    readonly totalUsage: LanguageModelUsage;\n\n    /**\n     * Context that is passed into tool execution.\n     *\n     * Experimental (can break in patch releases).\n     *\n     * @default undefined\n     */\n    experimental_context: unknown;\n  },\n) => PromiseLike<void> | void;\n\n/**\nCallback that is set using the `onAbort` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamTextOnAbortCallback<TOOLS extends ToolSet> = (event: {\n  /**\nDetails for all previously finished steps.\n   */\n  readonly steps: StepResult<TOOLS>[];\n}) => PromiseLike<void> | void;\n\n/**\nGenerate a text and call tools for a given prompt using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateText` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxOutputTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param onChunk - Callback that is called for each chunk of the stream. The stream processing will pause until the callback promise is resolved.\n@param onError - Callback that is called when an error occurs during streaming. You can use it to log errors.\n@param onStepFinish - Callback that is called when each step (LLM call) is finished, including intermediate steps.\n@param onFinish - Callback that is called when all steps are finished and the response is complete.\n\n@return\nA result object for accessing different stream types and additional information.\n */\nexport function streamText<\n  TOOLS extends ToolSet,\n  OUTPUT extends Output = Output<string, string>,\n>({\n  model,\n  tools,\n  toolChoice,\n  system,\n  prompt,\n  messages,\n  maxRetries,\n  abortSignal,\n  headers,\n  stopWhen = stepCountIs(1),\n  experimental_output,\n  output = experimental_output,\n  experimental_telemetry: telemetry,\n  prepareStep,\n  providerOptions,\n  experimental_activeTools,\n  activeTools = experimental_activeTools,\n  experimental_repairToolCall: repairToolCall,\n  experimental_transform: transform,\n  experimental_download: download,\n  includeRawChunks = false,\n  onChunk,\n  onError = ({ error }) => {\n    console.error(error);\n  },\n  onFinish,\n  onAbort,\n  onStepFinish,\n  experimental_context,\n  _internal: {\n    now = originalNow,\n    generateId = originalGenerateId,\n    currentDate = () => new Date(),\n  } = {},\n  ...settings\n}: CallSettings &\n  Prompt & {\n    /**\nThe language model to use.\n     */\n    model: LanguageModel;\n\n    /**\nThe tools that the model can call. The model needs to support calling tools.\n    */\n    tools?: TOOLS;\n\n    /**\nThe tool choice strategy. Default: 'auto'.\n     */\n    toolChoice?: ToolChoice<TOOLS>;\n\n    /**\nCondition for stopping the generation when there are tool results in the last step.\nWhen the condition is an array, any of the conditions can be met to stop the generation.\n\n@default stepCountIs(1)\n     */\n    stopWhen?:\n      | StopCondition<NoInfer<TOOLS>>\n      | Array<StopCondition<NoInfer<TOOLS>>>;\n\n    /**\nOptional telemetry configuration (experimental).\n     */\n    experimental_telemetry?: TelemetrySettings;\n\n    /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n    providerOptions?: ProviderOptions;\n\n    /**\n     * @deprecated Use `activeTools` instead.\n     */\n    experimental_activeTools?: Array<keyof NoInfer<TOOLS>>;\n\n    /**\n   Limits the tools that are available for the model to call without\n   changing the tool call and result types in the result.\n        */\n    activeTools?: Array<keyof NoInfer<TOOLS>>;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n     */\n    output?: OUTPUT;\n\n    /**\nOptional specification for parsing structured outputs from the LLM response.\n\n@deprecated Use `output` instead.\n */\n    experimental_output?: OUTPUT;\n\n    /**\nOptional function that you can use to provide different settings for a step.\n\n@param options - The options for the step.\n@param options.steps - The steps that have been executed so far.\n@param options.stepNumber - The number of the step that is being executed.\n@param options.model - The model that is being used.\n\n@returns An object that contains the settings for the step.\nIf you return undefined (or for undefined settings), the settings from the outer level will be used.\n    */\n    prepareStep?: PrepareStepFunction<NoInfer<TOOLS>>;\n\n    /**\nA function that attempts to repair a tool call that failed to parse.\n     */\n    experimental_repairToolCall?: ToolCallRepairFunction<TOOLS>;\n\n    /**\nOptional stream transformations.\nThey are applied in the order they are provided.\nThe stream transformations must maintain the stream structure for streamText to work correctly.\n     */\n    experimental_transform?:\n      | StreamTextTransform<TOOLS>\n      | Array<StreamTextTransform<TOOLS>>;\n\n    /**\nCustom download function to use for URLs.\n\nBy default, files are downloaded if the model does not support the URL for the given media type.\n     */\n    experimental_download?: DownloadFunction | undefined;\n\n    /**\nWhether to include raw chunks from the provider in the stream.\nWhen enabled, you will receive raw chunks with type 'raw' that contain the unprocessed data from the provider.\nThis allows access to cutting-edge provider features not yet wrapped by the AI SDK.\nDefaults to false.\n     */\n    includeRawChunks?: boolean;\n\n    /**\nCallback that is called for each chunk of the stream.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onChunk?: StreamTextOnChunkCallback<TOOLS>;\n\n    /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n    onError?: StreamTextOnErrorCallback;\n\n    /**\nCallback that is called when the LLM response and all request tool executions\n(for tools that have an `execute` function) are finished.\n\nThe usage is the combined usage of all steps.\n     */\n    onFinish?: StreamTextOnFinishCallback<TOOLS>;\n\n    onAbort?: StreamTextOnAbortCallback<TOOLS>;\n\n    /**\nCallback that is called when each step (LLM call) is finished, including intermediate steps.\n    */\n    onStepFinish?: StreamTextOnStepFinishCallback<TOOLS>;\n\n    /**\n     * Context that is passed into tool execution.\n     *\n     * Experimental (can break in patch releases).\n     *\n     * @default undefined\n     */\n    experimental_context?: unknown;\n\n    /**\nInternal. For test use only. May change without notice.\n     */\n    _internal?: {\n      now?: () => number;\n      generateId?: IdGenerator;\n      currentDate?: () => Date;\n    };\n  }): StreamTextResult<TOOLS, OUTPUT> {\n  return new DefaultStreamTextResult<TOOLS, OUTPUT>({\n    model: resolveLanguageModel(model),\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms: asArray(transform),\n    activeTools,\n    repairToolCall,\n    stopConditions: asArray(stopWhen),\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    now,\n    currentDate,\n    generateId,\n    experimental_context,\n    download,\n  });\n}\n\ntype EnrichedStreamPart<TOOLS extends ToolSet, PARTIAL_OUTPUT> = {\n  part: TextStreamPart<TOOLS>;\n  partialOutput: PARTIAL_OUTPUT | undefined;\n};\n\nfunction createOutputTransformStream<\n  TOOLS extends ToolSet,\n  OUTPUT extends Output,\n>(\n  output: OUTPUT,\n): TransformStream<\n  TextStreamPart<TOOLS>,\n  EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>\n> {\n  let firstTextChunkId: string | undefined = undefined;\n  let text = '';\n  let textChunk = '';\n  let textProviderMetadata: ProviderMetadata | undefined = undefined;\n  let lastPublishedJson = '';\n\n  function publishTextChunk({\n    controller,\n    partialOutput = undefined,\n  }: {\n    controller: TransformStreamDefaultController<\n      EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>\n    >;\n    partialOutput?: InferPartialOutput<OUTPUT>;\n  }) {\n    controller.enqueue({\n      part: {\n        type: 'text-delta',\n        id: firstTextChunkId!,\n        text: textChunk,\n        providerMetadata: textProviderMetadata,\n      },\n      partialOutput,\n    });\n    textChunk = '';\n  }\n\n  return new TransformStream<\n    TextStreamPart<TOOLS>,\n    EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>\n  >({\n    async transform(chunk, controller) {\n      // ensure that we publish the last text chunk before the step finish:\n      if (chunk.type === 'finish-step' && textChunk.length > 0) {\n        publishTextChunk({ controller });\n      }\n\n      if (\n        chunk.type !== 'text-delta' &&\n        chunk.type !== 'text-start' &&\n        chunk.type !== 'text-end'\n      ) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      // we have to pick a text chunk which contains the json text\n      // since we are streaming, we have to pick the first text chunk\n      if (firstTextChunkId == null) {\n        firstTextChunkId = chunk.id;\n      } else if (chunk.id !== firstTextChunkId) {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      if (chunk.type === 'text-start') {\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      if (chunk.type === 'text-end') {\n        if (textChunk.length > 0) {\n          publishTextChunk({ controller });\n        }\n        controller.enqueue({ part: chunk, partialOutput: undefined });\n        return;\n      }\n\n      text += chunk.text;\n      textChunk += chunk.text;\n      textProviderMetadata = chunk.providerMetadata ?? textProviderMetadata;\n\n      // only publish if partial json can be parsed:\n      const result = await output.parsePartialOutput({ text });\n\n      // null should be allowed (valid JSON value) but undefined should not:\n      if (result !== undefined) {\n        // only send new json if it has changed:\n        const currentJson = JSON.stringify(result.partial);\n        if (currentJson !== lastPublishedJson) {\n          publishTextChunk({ controller, partialOutput: result.partial });\n          lastPublishedJson = currentJson;\n        }\n      }\n    },\n  });\n}\n\nclass DefaultStreamTextResult<TOOLS extends ToolSet, OUTPUT extends Output>\n  implements StreamTextResult<TOOLS, OUTPUT>\n{\n  private readonly _totalUsage = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, OUTPUT>['usage']>\n  >();\n  private readonly _finishReason = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, OUTPUT>['finishReason']>\n  >();\n  private readonly _rawFinishReason = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, OUTPUT>['rawFinishReason']>\n  >();\n  private readonly _steps = new DelayedPromise<\n    Awaited<StreamTextResult<TOOLS, OUTPUT>['steps']>\n  >();\n\n  private readonly addStream: (\n    stream: ReadableStream<TextStreamPart<TOOLS>>,\n  ) => void;\n\n  private readonly closeStream: () => void;\n\n  private baseStream: ReadableStream<\n    EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>\n  >;\n\n  private outputSpecification: OUTPUT | undefined;\n\n  private includeRawChunks: boolean;\n\n  private tools: TOOLS | undefined;\n\n  constructor({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    system,\n    prompt,\n    messages,\n    tools,\n    toolChoice,\n    transforms,\n    activeTools,\n    repairToolCall,\n    stopConditions,\n    output,\n    providerOptions,\n    prepareStep,\n    includeRawChunks,\n    now,\n    currentDate,\n    generateId,\n    onChunk,\n    onError,\n    onFinish,\n    onAbort,\n    onStepFinish,\n    experimental_context,\n    download,\n  }: {\n    model: LanguageModelV3;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    tools: TOOLS | undefined;\n    toolChoice: ToolChoice<TOOLS> | undefined;\n    transforms: Array<StreamTextTransform<TOOLS>>;\n    activeTools: Array<keyof TOOLS> | undefined;\n    repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n    stopConditions: Array<StopCondition<NoInfer<TOOLS>>>;\n    output: OUTPUT | undefined;\n    providerOptions: ProviderOptions | undefined;\n    prepareStep: PrepareStepFunction<NoInfer<TOOLS>> | undefined;\n    includeRawChunks: boolean;\n    now: () => number;\n    currentDate: () => Date;\n    generateId: () => string;\n    experimental_context: unknown;\n    download: DownloadFunction | undefined;\n\n    // callbacks:\n    onChunk: undefined | StreamTextOnChunkCallback<TOOLS>;\n    onError: StreamTextOnErrorCallback;\n    onFinish: undefined | StreamTextOnFinishCallback<TOOLS>;\n    onAbort: undefined | StreamTextOnAbortCallback<TOOLS>;\n    onStepFinish: undefined | StreamTextOnStepFinishCallback<TOOLS>;\n  }) {\n    this.outputSpecification = output;\n    this.includeRawChunks = includeRawChunks;\n    this.tools = tools;\n\n    // promise to ensure that the step has been fully processed by the event processor\n    // before a new step is started. This is required because the continuation condition\n    // needs the updated steps to determine if another step is needed.\n    let stepFinish!: DelayedPromise<void>;\n\n    let recordedContent: Array<ContentPart<TOOLS>> = [];\n    const recordedResponseMessages: Array<ResponseMessage> = [];\n    let recordedFinishReason: FinishReason | undefined = undefined;\n    let recordedRawFinishReason: string | undefined = undefined;\n    let recordedTotalUsage: LanguageModelUsage | undefined = undefined;\n    let recordedRequest: LanguageModelRequestMetadata = {};\n    let recordedWarnings: Array<CallWarning> = [];\n    const recordedSteps: StepResult<TOOLS>[] = [];\n\n    // Track provider-executed tool calls that support deferred results\n    // (e.g., code_execution in programmatic tool calling scenarios).\n    // These tools may not return their results in the same turn as their call.\n    const pendingDeferredToolCalls = new Map<string, { toolName: string }>();\n\n    let rootSpan!: Span;\n\n    let activeTextContent: Record<\n      string,\n      {\n        type: 'text';\n        text: string;\n        providerMetadata: ProviderMetadata | undefined;\n      }\n    > = {};\n\n    let activeReasoningContent: Record<\n      string,\n      {\n        type: 'reasoning';\n        text: string;\n        providerMetadata: ProviderMetadata | undefined;\n      }\n    > = {};\n\n    const eventProcessor = new TransformStream<\n      EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>,\n      EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>\n    >({\n      async transform(chunk, controller) {\n        controller.enqueue(chunk); // forward the chunk to the next stream\n\n        const { part } = chunk;\n\n        if (\n          part.type === 'text-delta' ||\n          part.type === 'reasoning-delta' ||\n          part.type === 'source' ||\n          part.type === 'tool-call' ||\n          part.type === 'tool-result' ||\n          part.type === 'tool-input-start' ||\n          part.type === 'tool-input-delta' ||\n          part.type === 'raw'\n        ) {\n          await onChunk?.({ chunk: part });\n        }\n\n        if (part.type === 'error') {\n          await onError({ error: wrapGatewayError(part.error) });\n        }\n\n        if (part.type === 'text-start') {\n          activeTextContent[part.id] = {\n            type: 'text',\n            text: '',\n            providerMetadata: part.providerMetadata,\n          };\n\n          recordedContent.push(activeTextContent[part.id]);\n        }\n\n        if (part.type === 'text-delta') {\n          const activeText = activeTextContent[part.id];\n\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: 'error',\n                error: `text part ${part.id} not found`,\n              },\n              partialOutput: undefined,\n            });\n            return;\n          }\n\n          activeText.text += part.text;\n          activeText.providerMetadata =\n            part.providerMetadata ?? activeText.providerMetadata;\n        }\n\n        if (part.type === 'text-end') {\n          const activeText = activeTextContent[part.id];\n\n          if (activeText == null) {\n            controller.enqueue({\n              part: {\n                type: 'error',\n                error: `text part ${part.id} not found`,\n              },\n              partialOutput: undefined,\n            });\n            return;\n          }\n\n          activeText.providerMetadata =\n            part.providerMetadata ?? activeText.providerMetadata;\n\n          delete activeTextContent[part.id];\n        }\n\n        if (part.type === 'reasoning-start') {\n          activeReasoningContent[part.id] = {\n            type: 'reasoning',\n            text: '',\n            providerMetadata: part.providerMetadata,\n          };\n\n          recordedContent.push(activeReasoningContent[part.id]);\n        }\n\n        if (part.type === 'reasoning-delta') {\n          const activeReasoning = activeReasoningContent[part.id];\n\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: 'error',\n                error: `reasoning part ${part.id} not found`,\n              },\n              partialOutput: undefined,\n            });\n            return;\n          }\n\n          activeReasoning.text += part.text;\n          activeReasoning.providerMetadata =\n            part.providerMetadata ?? activeReasoning.providerMetadata;\n        }\n\n        if (part.type === 'reasoning-end') {\n          const activeReasoning = activeReasoningContent[part.id];\n\n          if (activeReasoning == null) {\n            controller.enqueue({\n              part: {\n                type: 'error',\n                error: `reasoning part ${part.id} not found`,\n              },\n              partialOutput: undefined,\n            });\n            return;\n          }\n\n          activeReasoning.providerMetadata =\n            part.providerMetadata ?? activeReasoning.providerMetadata;\n\n          delete activeReasoningContent[part.id];\n        }\n\n        if (part.type === 'file') {\n          recordedContent.push({ type: 'file', file: part.file });\n        }\n\n        if (part.type === 'source') {\n          recordedContent.push(part);\n        }\n\n        if (part.type === 'tool-call') {\n          recordedContent.push(part);\n        }\n\n        if (part.type === 'tool-result' && !part.preliminary) {\n          recordedContent.push(part);\n        }\n\n        if (part.type === 'tool-approval-request') {\n          recordedContent.push(part);\n        }\n\n        if (part.type === 'tool-error') {\n          recordedContent.push(part);\n        }\n\n        if (part.type === 'start-step') {\n          // reset the recorded data when a new step starts:\n          recordedContent = [];\n          activeReasoningContent = {};\n          activeTextContent = {};\n\n          recordedRequest = part.request;\n          recordedWarnings = part.warnings;\n        }\n\n        if (part.type === 'finish-step') {\n          const stepMessages = await toResponseMessages({\n            content: recordedContent,\n            tools,\n          });\n\n          // Add step information (after response messages are updated):\n          const currentStepResult: StepResult<TOOLS> = new DefaultStepResult({\n            content: recordedContent,\n            finishReason: part.finishReason,\n            rawFinishReason: part.rawFinishReason,\n            usage: part.usage,\n            warnings: recordedWarnings,\n            request: recordedRequest,\n            response: {\n              ...part.response,\n              messages: [...recordedResponseMessages, ...stepMessages],\n            },\n            providerMetadata: part.providerMetadata,\n          });\n\n          await onStepFinish?.(currentStepResult);\n\n          logWarnings({\n            warnings: recordedWarnings,\n            provider: model.provider,\n            model: model.modelId,\n          });\n\n          recordedSteps.push(currentStepResult);\n\n          recordedResponseMessages.push(...stepMessages);\n\n          // resolve the promise to signal that the step has been fully processed\n          // by the event processor:\n          stepFinish.resolve();\n        }\n\n        if (part.type === 'finish') {\n          recordedTotalUsage = part.totalUsage;\n          recordedFinishReason = part.finishReason;\n          recordedRawFinishReason = part.rawFinishReason;\n        }\n      },\n\n      async flush(controller) {\n        try {\n          if (recordedSteps.length === 0) {\n            const error = new NoOutputGeneratedError({\n              message: 'No output generated. Check the stream for errors.',\n            });\n\n            self._finishReason.reject(error);\n            self._rawFinishReason.reject(error);\n            self._totalUsage.reject(error);\n            self._steps.reject(error);\n\n            return; // no steps recorded (e.g. in error scenario)\n          }\n\n          // derived:\n          const finishReason = recordedFinishReason ?? 'other';\n          const totalUsage =\n            recordedTotalUsage ?? createNullLanguageModelUsage();\n\n          // from finish:\n          self._finishReason.resolve(finishReason);\n          self._rawFinishReason.resolve(recordedRawFinishReason);\n          self._totalUsage.resolve(totalUsage);\n\n          // aggregate results:\n          self._steps.resolve(recordedSteps);\n\n          // call onFinish callback:\n          const finalStep = recordedSteps[recordedSteps.length - 1];\n          await onFinish?.({\n            finishReason: finalStep.finishReason,\n            rawFinishReason: finalStep.rawFinishReason,\n            totalUsage,\n            usage: finalStep.usage,\n            content: finalStep.content,\n            text: finalStep.text,\n            reasoningText: finalStep.reasoningText,\n            reasoning: finalStep.reasoning,\n            files: finalStep.files,\n            sources: finalStep.sources,\n            toolCalls: finalStep.toolCalls,\n            staticToolCalls: finalStep.staticToolCalls,\n            dynamicToolCalls: finalStep.dynamicToolCalls,\n            toolResults: finalStep.toolResults,\n            staticToolResults: finalStep.staticToolResults,\n            dynamicToolResults: finalStep.dynamicToolResults,\n            request: finalStep.request,\n            response: finalStep.response,\n            warnings: finalStep.warnings,\n            providerMetadata: finalStep.providerMetadata,\n            steps: recordedSteps,\n            experimental_context,\n          });\n\n          // Add response information to the root span:\n          rootSpan.setAttributes(\n            await selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                'ai.response.finishReason': finishReason,\n                'ai.response.text': { output: () => finalStep.text },\n                'ai.response.toolCalls': {\n                  output: () =>\n                    finalStep.toolCalls?.length\n                      ? JSON.stringify(finalStep.toolCalls)\n                      : undefined,\n                },\n                'ai.response.providerMetadata': JSON.stringify(\n                  finalStep.providerMetadata,\n                ),\n\n                'ai.usage.inputTokens': totalUsage.inputTokens,\n                'ai.usage.outputTokens': totalUsage.outputTokens,\n                'ai.usage.totalTokens': totalUsage.totalTokens,\n                'ai.usage.reasoningTokens': totalUsage.reasoningTokens,\n                'ai.usage.cachedInputTokens': totalUsage.cachedInputTokens,\n              },\n            }),\n          );\n        } catch (error) {\n          controller.error(error);\n        } finally {\n          rootSpan.end();\n        }\n      },\n    });\n\n    // initialize the stitchable stream and the transformed stream:\n    const stitchableStream = createStitchableStream<TextStreamPart<TOOLS>>();\n    this.addStream = stitchableStream.addStream;\n    this.closeStream = stitchableStream.close;\n\n    // resilient stream that handles abort signals and errors:\n    const reader = stitchableStream.stream.getReader();\n    let stream = new ReadableStream<TextStreamPart<TOOLS>>({\n      async start(controller) {\n        // send start event:\n        controller.enqueue({ type: 'start' });\n      },\n\n      async pull(controller) {\n        // abort handling:\n        function abort() {\n          onAbort?.({ steps: recordedSteps });\n          controller.enqueue({ type: 'abort' });\n          controller.close();\n        }\n\n        try {\n          const { done, value } = await reader.read();\n\n          if (done) {\n            controller.close();\n            return;\n          }\n\n          if (abortSignal?.aborted) {\n            abort();\n            return;\n          }\n\n          controller.enqueue(value);\n        } catch (error) {\n          if (isAbortError(error) && abortSignal?.aborted) {\n            abort();\n          } else {\n            controller.error(error);\n          }\n        }\n      },\n\n      cancel(reason) {\n        return stitchableStream.stream.cancel(reason);\n      },\n    });\n\n    // transform the stream before output parsing\n    // to enable replacement of stream segments:\n    for (const transform of transforms) {\n      stream = stream.pipeThrough(\n        transform({\n          tools: tools as TOOLS,\n          stopStream() {\n            stitchableStream.terminate();\n          },\n        }),\n      );\n    }\n\n    this.baseStream = stream\n      .pipeThrough(createOutputTransformStream(output ?? text()))\n      .pipeThrough(eventProcessor);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal,\n    });\n\n    const tracer = getTracer(telemetry);\n\n    const callSettings = prepareCallSettings(settings);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries },\n    });\n\n    const self = this;\n\n    recordSpan({\n      name: 'ai.streamText',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({ operationId: 'ai.streamText', telemetry }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpanArg => {\n        rootSpan = rootSpanArg;\n\n        const initialPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages,\n        } as Prompt);\n\n        const initialMessages = initialPrompt.messages;\n        const initialResponseMessages: Array<ResponseMessage> = [];\n\n        const { approvedToolApprovals, deniedToolApprovals } =\n          collectToolApprovals<TOOLS>({ messages: initialMessages });\n\n        // initial tool execution step stream\n        if (\n          deniedToolApprovals.length > 0 ||\n          approvedToolApprovals.length > 0\n        ) {\n          const providerExecutedToolApprovals = [\n            ...approvedToolApprovals,\n            ...deniedToolApprovals,\n          ].filter(toolApproval => toolApproval.toolCall.providerExecuted);\n\n          const localApprovedToolApprovals = approvedToolApprovals.filter(\n            toolApproval => !toolApproval.toolCall.providerExecuted,\n          );\n          const localDeniedToolApprovals = deniedToolApprovals.filter(\n            toolApproval => !toolApproval.toolCall.providerExecuted,\n          );\n\n          const deniedProviderExecutedToolApprovals =\n            deniedToolApprovals.filter(\n              toolApproval => toolApproval.toolCall.providerExecuted,\n            );\n\n          let toolExecutionStepStreamController:\n            | ReadableStreamDefaultController<TextStreamPart<TOOLS>>\n            | undefined;\n          const toolExecutionStepStream = new ReadableStream<\n            TextStreamPart<TOOLS>\n          >({\n            start(controller) {\n              toolExecutionStepStreamController = controller;\n            },\n          });\n\n          self.addStream(toolExecutionStepStream);\n\n          try {\n            for (const toolApproval of [\n              ...localDeniedToolApprovals,\n              ...deniedProviderExecutedToolApprovals,\n            ]) {\n              toolExecutionStepStreamController?.enqueue({\n                type: 'tool-output-denied',\n                toolCallId: toolApproval.toolCall.toolCallId,\n                toolName: toolApproval.toolCall.toolName,\n              } as StaticToolOutputDenied<TOOLS>);\n            }\n\n            const toolOutputs: Array<ToolOutput<TOOLS>> = [];\n\n            await Promise.all(\n              localApprovedToolApprovals.map(async toolApproval => {\n                const result = await executeToolCall({\n                  toolCall: toolApproval.toolCall,\n                  tools,\n                  tracer,\n                  telemetry,\n                  messages: initialMessages,\n                  abortSignal,\n                  experimental_context,\n                  onPreliminaryToolResult: result => {\n                    toolExecutionStepStreamController?.enqueue(result);\n                  },\n                });\n\n                if (result != null) {\n                  toolExecutionStepStreamController?.enqueue(result);\n                  toolOutputs.push(result);\n                }\n              }),\n            );\n\n            // forward provider-executed approval responses to the provider (do not execute locally):\n            if (providerExecutedToolApprovals.length > 0) {\n              initialResponseMessages.push({\n                role: 'tool',\n                content: providerExecutedToolApprovals.map(\n                  toolApproval =>\n                    ({\n                      type: 'tool-approval-response',\n                      approvalId: toolApproval.approvalResponse.approvalId,\n                      approved: toolApproval.approvalResponse.approved,\n                      reason: toolApproval.approvalResponse.reason,\n                      providerExecuted: true,\n                    }) satisfies ToolApprovalResponse,\n                ),\n              });\n            }\n\n            // Local tool results (approved + denied) are sent as tool results:\n            if (toolOutputs.length > 0 || localDeniedToolApprovals.length > 0) {\n              const localToolContent: ToolContent = [];\n\n              // add regular tool results for approved tool calls:\n              for (const output of toolOutputs) {\n                localToolContent.push({\n                  type: 'tool-result' as const,\n                  toolCallId: output.toolCallId,\n                  toolName: output.toolName,\n                  output: await createToolModelOutput({\n                    toolCallId: output.toolCallId,\n                    input: output.input,\n                    tool: tools?.[output.toolName],\n                    output:\n                      output.type === 'tool-result'\n                        ? output.output\n                        : output.error,\n                    errorMode: output.type === 'tool-error' ? 'json' : 'none',\n                  }),\n                });\n              }\n\n              // add execution denied tool results for denied local tool approvals:\n              for (const toolApproval of localDeniedToolApprovals) {\n                localToolContent.push({\n                  type: 'tool-result' as const,\n                  toolCallId: toolApproval.toolCall.toolCallId,\n                  toolName: toolApproval.toolCall.toolName,\n                  output: {\n                    type: 'execution-denied' as const,\n                    reason: toolApproval.approvalResponse.reason,\n                  },\n                });\n              }\n\n              initialResponseMessages.push({\n                role: 'tool',\n                content: localToolContent,\n              });\n            }\n          } finally {\n            toolExecutionStepStreamController?.close();\n          }\n        }\n\n        recordedResponseMessages.push(...initialResponseMessages);\n\n        async function streamStep({\n          currentStep,\n          responseMessages,\n          usage,\n        }: {\n          currentStep: number;\n          responseMessages: Array<ResponseMessage>;\n          usage: LanguageModelUsage;\n        }) {\n          const includeRawChunks = self.includeRawChunks;\n\n          stepFinish = new DelayedPromise<void>();\n\n          const stepInputMessages = [...initialMessages, ...responseMessages];\n\n          const prepareStepResult = await prepareStep?.({\n            model,\n            steps: recordedSteps,\n            stepNumber: recordedSteps.length,\n            messages: stepInputMessages,\n            experimental_context,\n          });\n\n          const stepModel = resolveLanguageModel(\n            prepareStepResult?.model ?? model,\n          );\n\n          const promptMessages = await convertToLanguageModelPrompt({\n            prompt: {\n              system: prepareStepResult?.system ?? initialPrompt.system,\n              messages: prepareStepResult?.messages ?? stepInputMessages,\n            },\n            supportedUrls: await stepModel.supportedUrls,\n            download,\n          });\n\n          const { toolChoice: stepToolChoice, tools: stepTools } =\n            await prepareToolsAndToolChoice({\n              tools,\n              toolChoice: prepareStepResult?.toolChoice ?? toolChoice,\n              activeTools: prepareStepResult?.activeTools ?? activeTools,\n            });\n\n          experimental_context =\n            prepareStepResult?.experimental_context ?? experimental_context;\n\n          const stepProviderOptions = mergeObjects(\n            providerOptions,\n            prepareStepResult?.providerOptions,\n          );\n          const {\n            result: { stream, response, request },\n            doStreamSpan,\n            startTimestampMs,\n          } = await retry(() =>\n            recordSpan({\n              name: 'ai.streamText.doStream',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.streamText.doStream',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  // model:\n                  'ai.model.provider': stepModel.provider,\n                  'ai.model.id': stepModel.modelId,\n                  // prompt:\n                  'ai.prompt.messages': {\n                    input: () => stringifyForTelemetry(promptMessages),\n                  },\n                  'ai.prompt.tools': {\n                    // convert the language model level tools:\n                    input: () => stepTools?.map(tool => JSON.stringify(tool)),\n                  },\n                  'ai.prompt.toolChoice': {\n                    input: () =>\n                      stepToolChoice != null\n                        ? JSON.stringify(stepToolChoice)\n                        : undefined,\n                  },\n\n                  // standardized gen-ai llm span attributes:\n                  'gen_ai.system': stepModel.provider,\n                  'gen_ai.request.model': stepModel.modelId,\n                  'gen_ai.request.frequency_penalty':\n                    callSettings.frequencyPenalty,\n                  'gen_ai.request.max_tokens': callSettings.maxOutputTokens,\n                  'gen_ai.request.presence_penalty':\n                    callSettings.presencePenalty,\n                  'gen_ai.request.stop_sequences': callSettings.stopSequences,\n                  'gen_ai.request.temperature': callSettings.temperature,\n                  'gen_ai.request.top_k': callSettings.topK,\n                  'gen_ai.request.top_p': callSettings.topP,\n                },\n              }),\n              tracer,\n              endWhenDone: false,\n              fn: async doStreamSpan => ({\n                startTimestampMs: now(), // get before the call\n                doStreamSpan,\n                result: await stepModel.doStream({\n                  ...callSettings,\n                  tools: stepTools,\n                  toolChoice: stepToolChoice,\n                  responseFormat: await output?.responseFormat,\n                  prompt: promptMessages,\n                  providerOptions: stepProviderOptions,\n                  abortSignal,\n                  headers,\n                  includeRawChunks,\n                }),\n              }),\n            }),\n          );\n\n          const streamWithToolResults = runToolsTransformation({\n            tools,\n            generatorStream: stream,\n            tracer,\n            telemetry,\n            system,\n            messages: stepInputMessages,\n            repairToolCall,\n            abortSignal,\n            experimental_context,\n            generateId,\n          });\n\n          const stepRequest = request ?? {};\n          const stepToolCalls: TypedToolCall<TOOLS>[] = [];\n          const stepToolOutputs: ToolOutput<TOOLS>[] = [];\n          let warnings: SharedV3Warning[] | undefined;\n\n          const activeToolCallToolNames: Record<string, string> = {};\n\n          let stepFinishReason: FinishReason = 'other';\n          let stepRawFinishReason: string | undefined = undefined;\n\n          let stepUsage: LanguageModelUsage = createNullLanguageModelUsage();\n          let stepProviderMetadata: ProviderMetadata | undefined;\n          let stepFirstChunk = true;\n          let stepResponse: { id: string; timestamp: Date; modelId: string } = {\n            id: generateId(),\n            timestamp: currentDate(),\n            modelId: model.modelId,\n          };\n\n          // raw text as it comes from the provider. recorded for telemetry.\n          let activeText = '';\n\n          self.addStream(\n            streamWithToolResults.pipeThrough(\n              new TransformStream<\n                SingleRequestTextStreamPart<TOOLS>,\n                TextStreamPart<TOOLS>\n              >({\n                async transform(chunk, controller): Promise<void> {\n                  if (chunk.type === 'stream-start') {\n                    warnings = chunk.warnings;\n                    return; // stream start chunks are sent immediately and do not count as first chunk\n                  }\n\n                  if (stepFirstChunk) {\n                    // Telemetry for first chunk:\n                    const msToFirstChunk = now() - startTimestampMs;\n\n                    stepFirstChunk = false;\n\n                    doStreamSpan.addEvent('ai.stream.firstChunk', {\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    doStreamSpan.setAttributes({\n                      'ai.response.msToFirstChunk': msToFirstChunk,\n                    });\n\n                    // Step start:\n                    controller.enqueue({\n                      type: 'start-step',\n                      request: stepRequest,\n                      warnings: warnings ?? [],\n                    });\n                  }\n\n                  const chunkType = chunk.type;\n                  switch (chunkType) {\n                    case 'tool-approval-request':\n                    case 'text-start':\n                    case 'text-end': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'text-delta': {\n                      if (chunk.delta.length > 0) {\n                        controller.enqueue({\n                          type: 'text-delta',\n                          id: chunk.id,\n                          text: chunk.delta,\n                          providerMetadata: chunk.providerMetadata,\n                        });\n                        activeText += chunk.delta;\n                      }\n                      break;\n                    }\n\n                    case 'reasoning-start':\n                    case 'reasoning-end': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'reasoning-delta': {\n                      controller.enqueue({\n                        type: 'reasoning-delta',\n                        id: chunk.id,\n                        text: chunk.delta,\n                        providerMetadata: chunk.providerMetadata,\n                      });\n                      break;\n                    }\n\n                    case 'tool-call': {\n                      controller.enqueue(chunk);\n                      // store tool calls for onFinish callback and toolCalls promise:\n                      stepToolCalls.push(chunk);\n                      break;\n                    }\n\n                    case 'tool-result': {\n                      controller.enqueue(chunk);\n\n                      if (!chunk.preliminary) {\n                        stepToolOutputs.push(chunk);\n                      }\n\n                      break;\n                    }\n\n                    case 'tool-error': {\n                      controller.enqueue(chunk);\n                      stepToolOutputs.push(chunk);\n                      break;\n                    }\n\n                    case 'response-metadata': {\n                      stepResponse = {\n                        id: chunk.id ?? stepResponse.id,\n                        timestamp: chunk.timestamp ?? stepResponse.timestamp,\n                        modelId: chunk.modelId ?? stepResponse.modelId,\n                      };\n                      break;\n                    }\n\n                    case 'finish': {\n                      // Note: tool executions might not be finished yet when the finish event is emitted.\n                      // store usage and finish reason for promises and onFinish callback:\n                      stepUsage = chunk.usage;\n                      stepFinishReason = chunk.finishReason;\n                      stepRawFinishReason = chunk.rawFinishReason;\n                      stepProviderMetadata = chunk.providerMetadata;\n\n                      // Telemetry for finish event timing\n                      // (since tool executions can take longer and distort calculations)\n                      const msToFinish = now() - startTimestampMs;\n                      doStreamSpan.addEvent('ai.stream.finish');\n                      doStreamSpan.setAttributes({\n                        'ai.response.msToFinish': msToFinish,\n                        'ai.response.avgOutputTokensPerSecond':\n                          (1000 * (stepUsage.outputTokens ?? 0)) / msToFinish,\n                      });\n\n                      break;\n                    }\n\n                    case 'file': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'source': {\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'tool-input-start': {\n                      activeToolCallToolNames[chunk.id] = chunk.toolName;\n\n                      const tool = tools?.[chunk.toolName];\n                      if (tool?.onInputStart != null) {\n                        await tool.onInputStart({\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context,\n                        });\n                      }\n\n                      controller.enqueue({\n                        ...chunk,\n                        dynamic: chunk.dynamic ?? tool?.type === 'dynamic',\n                        title: tool?.title,\n                      });\n                      break;\n                    }\n\n                    case 'tool-input-end': {\n                      delete activeToolCallToolNames[chunk.id];\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'tool-input-delta': {\n                      const toolName = activeToolCallToolNames[chunk.id];\n                      const tool = tools?.[toolName];\n\n                      if (tool?.onInputDelta != null) {\n                        await tool.onInputDelta({\n                          inputTextDelta: chunk.delta,\n                          toolCallId: chunk.id,\n                          messages: stepInputMessages,\n                          abortSignal,\n                          experimental_context,\n                        });\n                      }\n\n                      controller.enqueue(chunk);\n                      break;\n                    }\n\n                    case 'error': {\n                      controller.enqueue(chunk);\n                      stepFinishReason = 'error';\n                      break;\n                    }\n\n                    case 'raw': {\n                      if (includeRawChunks) {\n                        controller.enqueue(chunk);\n                      }\n                      break;\n                    }\n\n                    default: {\n                      const exhaustiveCheck: never = chunkType;\n                      throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                    }\n                  }\n                },\n\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush(controller) {\n                  const stepToolCallsJson =\n                    stepToolCalls.length > 0\n                      ? JSON.stringify(stepToolCalls)\n                      : undefined;\n\n                  // record telemetry information first to ensure best effort timing\n                  try {\n                    doStreamSpan.setAttributes(\n                      await selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                          'ai.response.finishReason': stepFinishReason,\n                          'ai.response.text': {\n                            output: () => activeText,\n                          },\n                          'ai.response.toolCalls': {\n                            output: () => stepToolCallsJson,\n                          },\n                          'ai.response.id': stepResponse.id,\n                          'ai.response.model': stepResponse.modelId,\n                          'ai.response.timestamp':\n                            stepResponse.timestamp.toISOString(),\n                          'ai.response.providerMetadata':\n                            JSON.stringify(stepProviderMetadata),\n\n                          'ai.usage.inputTokens': stepUsage.inputTokens,\n                          'ai.usage.outputTokens': stepUsage.outputTokens,\n                          'ai.usage.totalTokens': stepUsage.totalTokens,\n                          'ai.usage.reasoningTokens': stepUsage.reasoningTokens,\n                          'ai.usage.cachedInputTokens':\n                            stepUsage.cachedInputTokens,\n\n                          // standardized gen-ai llm span attributes:\n                          'gen_ai.response.finish_reasons': [stepFinishReason],\n                          'gen_ai.response.id': stepResponse.id,\n                          'gen_ai.response.model': stepResponse.modelId,\n                          'gen_ai.usage.input_tokens': stepUsage.inputTokens,\n                          'gen_ai.usage.output_tokens': stepUsage.outputTokens,\n                        },\n                      }),\n                    );\n                  } catch (error) {\n                    // ignore error setting telemetry attributes\n                  } finally {\n                    // finish doStreamSpan before other operations for correct timing:\n                    doStreamSpan.end();\n                  }\n\n                  controller.enqueue({\n                    type: 'finish-step',\n                    finishReason: stepFinishReason,\n                    rawFinishReason: stepRawFinishReason,\n                    usage: stepUsage,\n                    providerMetadata: stepProviderMetadata,\n                    response: {\n                      ...stepResponse,\n                      headers: response?.headers,\n                    },\n                  });\n\n                  const combinedUsage = addLanguageModelUsage(usage, stepUsage);\n\n                  // wait for the step to be fully processed by the event processor\n                  // to ensure that the recorded steps are complete:\n                  await stepFinish.promise;\n\n                  const clientToolCalls = stepToolCalls.filter(\n                    toolCall => toolCall.providerExecuted !== true,\n                  );\n                  const clientToolOutputs = stepToolOutputs.filter(\n                    toolOutput => toolOutput.providerExecuted !== true,\n                  );\n\n                  // Track provider-executed tool calls that support deferred results.\n                  // In programmatic tool calling, a server tool (e.g., code_execution) may\n                  // trigger a client tool, and the server tool's result is deferred until\n                  // the client tool's result is sent back.\n                  for (const toolCall of stepToolCalls) {\n                    if (toolCall.providerExecuted !== true) continue;\n                    const tool = tools?.[toolCall.toolName];\n                    if (\n                      tool?.type === 'provider' &&\n                      tool.supportsDeferredResults\n                    ) {\n                      // Check if this tool call already has a result in the current step\n                      const hasResultInStep = stepToolOutputs.some(\n                        output =>\n                          output.type === 'tool-result' &&\n                          output.toolCallId === toolCall.toolCallId,\n                      );\n                      if (!hasResultInStep) {\n                        pendingDeferredToolCalls.set(toolCall.toolCallId, {\n                          toolName: toolCall.toolName,\n                        });\n                      }\n                    }\n                  }\n\n                  // Mark deferred tool calls as resolved when we receive their results\n                  for (const output of stepToolOutputs) {\n                    if (output.type === 'tool-result') {\n                      pendingDeferredToolCalls.delete(output.toolCallId);\n                    }\n                  }\n\n                  if (\n                    // Continue if:\n                    // 1. There are client tool calls that have all been executed, OR\n                    // 2. There are pending deferred results from provider-executed tools\n                    ((clientToolCalls.length > 0 &&\n                      clientToolOutputs.length === clientToolCalls.length) ||\n                      pendingDeferredToolCalls.size > 0) &&\n                    // continue until a stop condition is met:\n                    !(await isStopConditionMet({\n                      stopConditions,\n                      steps: recordedSteps,\n                    }))\n                  ) {\n                    // append to messages for the next step:\n                    responseMessages.push(\n                      ...(await toResponseMessages({\n                        content:\n                          // use transformed content to create the messages for the next step:\n                          recordedSteps[recordedSteps.length - 1].content,\n                        tools,\n                      })),\n                    );\n\n                    try {\n                      await streamStep({\n                        currentStep: currentStep + 1,\n                        responseMessages,\n                        usage: combinedUsage,\n                      });\n                    } catch (error) {\n                      controller.enqueue({\n                        type: 'error',\n                        error,\n                      });\n\n                      self.closeStream();\n                    }\n                  } else {\n                    controller.enqueue({\n                      type: 'finish',\n                      finishReason: stepFinishReason,\n                      rawFinishReason: stepRawFinishReason,\n                      totalUsage: combinedUsage,\n                    });\n\n                    self.closeStream(); // close the stitchable stream\n                  }\n                },\n              }),\n            ),\n          );\n        }\n\n        // add the initial stream to the stitchable stream\n        await streamStep({\n          currentStep: 0,\n          responseMessages: initialResponseMessages,\n          usage: createNullLanguageModelUsage(),\n        });\n      },\n    }).catch(error => {\n      // add an error stream part and close the streams:\n      self.addStream(\n        new ReadableStream({\n          start(controller) {\n            controller.enqueue({ type: 'error', error });\n            controller.close();\n          },\n        }),\n      );\n      self.closeStream();\n    });\n  }\n\n  get steps() {\n    // when any of the promises are accessed, the stream is consumed\n    // so it resolves without needing to consume the stream separately\n    this.consumeStream();\n\n    return this._steps.promise;\n  }\n\n  private get finalStep() {\n    return this.steps.then(steps => steps[steps.length - 1]);\n  }\n\n  get content() {\n    return this.finalStep.then(step => step.content);\n  }\n\n  get warnings() {\n    return this.finalStep.then(step => step.warnings);\n  }\n\n  get providerMetadata() {\n    return this.finalStep.then(step => step.providerMetadata);\n  }\n\n  get text() {\n    return this.finalStep.then(step => step.text);\n  }\n\n  get reasoningText() {\n    return this.finalStep.then(step => step.reasoningText);\n  }\n\n  get reasoning() {\n    return this.finalStep.then(step => step.reasoning);\n  }\n\n  get sources() {\n    return this.finalStep.then(step => step.sources);\n  }\n\n  get files() {\n    return this.finalStep.then(step => step.files);\n  }\n\n  get toolCalls() {\n    return this.finalStep.then(step => step.toolCalls);\n  }\n\n  get staticToolCalls() {\n    return this.finalStep.then(step => step.staticToolCalls);\n  }\n\n  get dynamicToolCalls() {\n    return this.finalStep.then(step => step.dynamicToolCalls);\n  }\n\n  get toolResults() {\n    return this.finalStep.then(step => step.toolResults);\n  }\n\n  get staticToolResults() {\n    return this.finalStep.then(step => step.staticToolResults);\n  }\n\n  get dynamicToolResults() {\n    return this.finalStep.then(step => step.dynamicToolResults);\n  }\n\n  get usage() {\n    return this.finalStep.then(step => step.usage);\n  }\n\n  get request() {\n    return this.finalStep.then(step => step.request);\n  }\n\n  get response() {\n    return this.finalStep.then(step => step.response);\n  }\n\n  get totalUsage() {\n    // when any of the promises are accessed, the stream is consumed\n    // so it resolves without needing to consume the stream separately\n    this.consumeStream();\n\n    return this._totalUsage.promise;\n  }\n\n  get finishReason() {\n    // when any of the promises are accessed, the stream is consumed\n    // so it resolves without needing to consume the stream separately\n    this.consumeStream();\n\n    return this._finishReason.promise;\n  }\n\n  get rawFinishReason() {\n    // when any of the promises are accessed, the stream is consumed\n    // so it resolves without needing to consume the stream separately\n    this.consumeStream();\n\n    return this._rawFinishReason.promise;\n  }\n\n  /**\nSplit out a new stream from the original stream.\nThe original stream is replaced to allow for further splitting,\nsince we do not know how many times the stream will be split.\n\nNote: this leads to buffering the stream content on the server.\nHowever, the LLM results are expected to be small enough to not cause issues.\n   */\n  private teeStream() {\n    const [stream1, stream2] = this.baseStream.tee();\n    this.baseStream = stream2;\n    return stream1;\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>,\n          string\n        >({\n          transform({ part }, controller) {\n            if (part.type === 'text-delta') {\n              controller.enqueue(part.text);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<TextStreamPart<TOOLS>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>,\n          TextStreamPart<TOOLS>\n        >({\n          transform({ part }, controller) {\n            controller.enqueue(part);\n          },\n        }),\n      ),\n    );\n  }\n\n  async consumeStream(options?: ConsumeStreamOptions): Promise<void> {\n    try {\n      await consumeStream({\n        stream: this.fullStream,\n        onError: options?.onError,\n      });\n    } catch (error) {\n      options?.onError?.(error);\n    }\n  }\n\n  get experimental_partialOutputStream(): AsyncIterableStream<\n    InferPartialOutput<OUTPUT>\n  > {\n    return this.partialOutputStream;\n  }\n\n  get partialOutputStream(): AsyncIterableStream<InferPartialOutput<OUTPUT>> {\n    return createAsyncIterableStream(\n      this.teeStream().pipeThrough(\n        new TransformStream<\n          EnrichedStreamPart<TOOLS, InferPartialOutput<OUTPUT>>,\n          InferPartialOutput<OUTPUT>\n        >({\n          transform({ partialOutput }, controller) {\n            if (partialOutput != null) {\n              controller.enqueue(partialOutput);\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get output(): Promise<InferCompleteOutput<OUTPUT>> {\n    return this.finalStep.then(step => {\n      const output = this.outputSpecification ?? text();\n      return output.parseCompleteOutput(\n        { text: step.text },\n        {\n          response: step.response,\n          usage: step.usage,\n          finishReason: step.finishReason,\n        },\n      );\n    });\n  }\n\n  toUIMessageStream<UI_MESSAGE extends UIMessage>({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning = true,\n    sendSources = false,\n    sendStart = true,\n    sendFinish = true,\n    onError = getErrorMessage,\n  }: UIMessageStreamOptions<UI_MESSAGE> = {}): AsyncIterableStream<\n    InferUIMessageChunk<UI_MESSAGE>\n  > {\n    const responseMessageId =\n      generateMessageId != null\n        ? getResponseUIMessageId({\n            originalMessages,\n            responseMessageId: generateMessageId,\n          })\n        : undefined;\n\n    // TODO simplify once dynamic is no longer needed for invalid tool inputs\n    const isDynamic = (part: { toolName: string; dynamic?: boolean }) => {\n      const tool = this.tools?.[part.toolName];\n\n      // provider-executed, dynamic tools are not listed in the tools object\n      if (tool == null) {\n        return part.dynamic;\n      }\n\n      return tool?.type === 'dynamic' ? true : undefined;\n    };\n\n    const baseStream = this.fullStream.pipeThrough(\n      new TransformStream<\n        TextStreamPart<TOOLS>,\n        UIMessageChunk<\n          InferUIMessageMetadata<UI_MESSAGE>,\n          InferUIMessageData<UI_MESSAGE>\n        >\n      >({\n        transform: async (part, controller) => {\n          const messageMetadataValue = messageMetadata?.({ part });\n\n          const partType = part.type;\n          switch (partType) {\n            case 'text-start': {\n              controller.enqueue({\n                type: 'text-start',\n                id: part.id,\n                ...(part.providerMetadata != null\n                  ? { providerMetadata: part.providerMetadata }\n                  : {}),\n              });\n              break;\n            }\n\n            case 'text-delta': {\n              controller.enqueue({\n                type: 'text-delta',\n                id: part.id,\n                delta: part.text,\n                ...(part.providerMetadata != null\n                  ? { providerMetadata: part.providerMetadata }\n                  : {}),\n              });\n              break;\n            }\n\n            case 'text-end': {\n              controller.enqueue({\n                type: 'text-end',\n                id: part.id,\n                ...(part.providerMetadata != null\n                  ? { providerMetadata: part.providerMetadata }\n                  : {}),\n              });\n              break;\n            }\n\n            case 'reasoning-start': {\n              controller.enqueue({\n                type: 'reasoning-start',\n                id: part.id,\n                ...(part.providerMetadata != null\n                  ? { providerMetadata: part.providerMetadata }\n                  : {}),\n              });\n              break;\n            }\n\n            case 'reasoning-delta': {\n              if (sendReasoning) {\n                controller.enqueue({\n                  type: 'reasoning-delta',\n                  id: part.id,\n                  delta: part.text,\n                  ...(part.providerMetadata != null\n                    ? { providerMetadata: part.providerMetadata }\n                    : {}),\n                });\n              }\n              break;\n            }\n\n            case 'reasoning-end': {\n              controller.enqueue({\n                type: 'reasoning-end',\n                id: part.id,\n                ...(part.providerMetadata != null\n                  ? { providerMetadata: part.providerMetadata }\n                  : {}),\n              });\n              break;\n            }\n\n            case 'file': {\n              controller.enqueue({\n                type: 'file',\n                mediaType: part.file.mediaType,\n                url: `data:${part.file.mediaType};base64,${part.file.base64}`,\n              });\n              break;\n            }\n\n            case 'source': {\n              if (sendSources && part.sourceType === 'url') {\n                controller.enqueue({\n                  type: 'source-url',\n                  sourceId: part.id,\n                  url: part.url,\n                  title: part.title,\n                  ...(part.providerMetadata != null\n                    ? { providerMetadata: part.providerMetadata }\n                    : {}),\n                });\n              }\n\n              if (sendSources && part.sourceType === 'document') {\n                controller.enqueue({\n                  type: 'source-document',\n                  sourceId: part.id,\n                  mediaType: part.mediaType,\n                  title: part.title,\n                  filename: part.filename,\n                  ...(part.providerMetadata != null\n                    ? { providerMetadata: part.providerMetadata }\n                    : {}),\n                });\n              }\n              break;\n            }\n\n            case 'tool-input-start': {\n              const dynamic = isDynamic(part);\n\n              controller.enqueue({\n                type: 'tool-input-start',\n                toolCallId: part.id,\n                toolName: part.toolName,\n                ...(part.providerExecuted != null\n                  ? { providerExecuted: part.providerExecuted }\n                  : {}),\n                ...(dynamic != null ? { dynamic } : {}),\n                ...(part.title != null ? { title: part.title } : {}),\n              });\n              break;\n            }\n\n            case 'tool-input-delta': {\n              controller.enqueue({\n                type: 'tool-input-delta',\n                toolCallId: part.id,\n                inputTextDelta: part.delta,\n              });\n              break;\n            }\n\n            case 'tool-call': {\n              const dynamic = isDynamic(part);\n\n              if (part.invalid) {\n                controller.enqueue({\n                  type: 'tool-input-error',\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...(part.providerExecuted != null\n                    ? { providerExecuted: part.providerExecuted }\n                    : {}),\n                  ...(part.providerMetadata != null\n                    ? { providerMetadata: part.providerMetadata }\n                    : {}),\n                  ...(dynamic != null ? { dynamic } : {}),\n                  errorText: onError(part.error),\n                  ...(part.title != null ? { title: part.title } : {}),\n                });\n              } else {\n                controller.enqueue({\n                  type: 'tool-input-available',\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  ...(part.providerExecuted != null\n                    ? { providerExecuted: part.providerExecuted }\n                    : {}),\n                  ...(part.providerMetadata != null\n                    ? { providerMetadata: part.providerMetadata }\n                    : {}),\n                  ...(dynamic != null ? { dynamic } : {}),\n                  ...(part.title != null ? { title: part.title } : {}),\n                });\n              }\n\n              break;\n            }\n\n            case 'tool-approval-request': {\n              controller.enqueue({\n                type: 'tool-approval-request',\n                approvalId: part.approvalId,\n                toolCallId: part.toolCall.toolCallId,\n              });\n              break;\n            }\n\n            case 'tool-result': {\n              const dynamic = isDynamic(part);\n\n              controller.enqueue({\n                type: 'tool-output-available',\n                toolCallId: part.toolCallId,\n                output: part.output,\n                ...(part.providerExecuted != null\n                  ? { providerExecuted: part.providerExecuted }\n                  : {}),\n                ...(part.preliminary != null\n                  ? { preliminary: part.preliminary }\n                  : {}),\n                ...(dynamic != null ? { dynamic } : {}),\n              });\n              break;\n            }\n\n            case 'tool-error': {\n              const dynamic = isDynamic(part);\n\n              controller.enqueue({\n                type: 'tool-output-error',\n                toolCallId: part.toolCallId,\n                errorText: onError(part.error),\n                ...(part.providerExecuted != null\n                  ? { providerExecuted: part.providerExecuted }\n                  : {}),\n                ...(dynamic != null ? { dynamic } : {}),\n              });\n              break;\n            }\n\n            case 'tool-output-denied': {\n              controller.enqueue({\n                type: 'tool-output-denied',\n                toolCallId: part.toolCallId,\n              });\n              break;\n            }\n\n            case 'error': {\n              controller.enqueue({\n                type: 'error',\n                errorText: onError(part.error),\n              });\n              break;\n            }\n\n            case 'start-step': {\n              controller.enqueue({ type: 'start-step' });\n              break;\n            }\n\n            case 'finish-step': {\n              controller.enqueue({ type: 'finish-step' });\n              break;\n            }\n\n            case 'start': {\n              if (sendStart) {\n                controller.enqueue({\n                  type: 'start',\n                  ...(messageMetadataValue != null\n                    ? { messageMetadata: messageMetadataValue }\n                    : {}),\n                  ...(responseMessageId != null\n                    ? { messageId: responseMessageId }\n                    : {}),\n                });\n              }\n              break;\n            }\n\n            case 'finish': {\n              if (sendFinish) {\n                controller.enqueue({\n                  type: 'finish',\n                  finishReason: part.finishReason,\n                  ...(messageMetadataValue != null\n                    ? { messageMetadata: messageMetadataValue }\n                    : {}),\n                });\n              }\n              break;\n            }\n\n            case 'abort': {\n              controller.enqueue(part);\n              break;\n            }\n\n            case 'tool-input-end': {\n              break;\n            }\n\n            case 'raw': {\n              // Raw chunks are not included in UI message streams\n              // as they contain provider-specific data for developer use\n              break;\n            }\n\n            default: {\n              const exhaustiveCheck: never = partType;\n              throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n            }\n          }\n\n          // start and finish events already have metadata\n          // so we only need to send metadata for other parts\n          if (\n            messageMetadataValue != null &&\n            partType !== 'start' &&\n            partType !== 'finish'\n          ) {\n            controller.enqueue({\n              type: 'message-metadata',\n              messageMetadata: messageMetadataValue,\n            });\n          }\n        },\n      }),\n    );\n\n    return createAsyncIterableStream(\n      handleUIMessageStreamFinish<UI_MESSAGE>({\n        stream: baseStream,\n        messageId: responseMessageId ?? generateMessageId?.(),\n        originalMessages,\n        onFinish,\n        onError,\n      }),\n    );\n  }\n\n  pipeUIMessageStreamToResponse<UI_MESSAGE extends UIMessage>(\n    response: ServerResponse,\n    {\n      originalMessages,\n      generateMessageId,\n      onFinish,\n      messageMetadata,\n      sendReasoning,\n      sendSources,\n      sendFinish,\n      sendStart,\n      onError,\n      ...init\n    }: UIMessageStreamResponseInit & UIMessageStreamOptions<UI_MESSAGE> = {},\n  ) {\n    pipeUIMessageStreamToResponse({\n      response,\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError,\n      }),\n      ...init,\n    });\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init,\n    });\n  }\n\n  toUIMessageStreamResponse<UI_MESSAGE extends UIMessage>({\n    originalMessages,\n    generateMessageId,\n    onFinish,\n    messageMetadata,\n    sendReasoning,\n    sendSources,\n    sendFinish,\n    sendStart,\n    onError,\n    ...init\n  }: UIMessageStreamResponseInit &\n    UIMessageStreamOptions<UI_MESSAGE> = {}): Response {\n    return createUIMessageStreamResponse({\n      stream: this.toUIMessageStream({\n        originalMessages,\n        generateMessageId,\n        onFinish,\n        messageMetadata,\n        sendReasoning,\n        sendSources,\n        sendFinish,\n        sendStart,\n        onError,\n      }),\n      ...init,\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init,\n    });\n  }\n}\n","export function prepareHeaders(\n  headers: HeadersInit | undefined,\n  defaultHeaders: Record<string, string>,\n): Headers {\n  const responseHeaders = new Headers(headers ?? {});\n\n  for (const [key, value] of Object.entries(defaultHeaders)) {\n    if (!responseHeaders.has(key)) {\n      responseHeaders.set(key, value);\n    }\n  }\n\n  return responseHeaders;\n}\n","import { prepareHeaders } from '../util/prepare-headers';\n\nexport function createTextStreamResponse({\n  status,\n  statusText,\n  headers,\n  textStream,\n}: ResponseInit & {\n  textStream: ReadableStream<string>;\n}): Response {\n  return new Response(textStream.pipeThrough(new TextEncoderStream()), {\n    status: status ?? 200,\n    statusText,\n    headers: prepareHeaders(headers, {\n      'content-type': 'text/plain; charset=utf-8',\n    }),\n  });\n}\n","import { ServerResponse } from 'node:http';\n\n/**\n * Writes the content of a stream to a server response.\n */\nexport function writeToServerResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n}: {\n  response: ServerResponse;\n  status?: number;\n  statusText?: string;\n  headers?: Record<string, string | number | string[]>;\n  stream: ReadableStream<Uint8Array>;\n}): void {\n  const statusCode = status ?? 200;\n  if (statusText !== undefined) {\n    response.writeHead(statusCode, statusText, headers);\n  } else {\n    response.writeHead(statusCode, headers);\n  }\n\n  const reader = stream.getReader();\n  const read = async () => {\n    try {\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) break;\n\n        // Respect backpressure: if write() returns false, wait for 'drain' event\n        const canContinue = response.write(value);\n        if (!canContinue) {\n          await new Promise<void>(resolve => {\n            response.once('drain', resolve);\n          });\n        }\n      }\n    } catch (error) {\n      throw error;\n    } finally {\n      response.end();\n    }\n  };\n\n  read();\n}\n","import { ServerResponse } from 'node:http';\nimport { prepareHeaders } from '../util/prepare-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\n\nexport function pipeTextStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  textStream,\n}: {\n  response: ServerResponse;\n  textStream: ReadableStream<string>;\n} & ResponseInit): void {\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, {\n        'content-type': 'text/plain; charset=utf-8',\n      }).entries(),\n    ),\n    stream: textStream.pipeThrough(new TextEncoderStream()),\n  });\n}\n","export class JsonToSseTransformStream extends TransformStream<unknown, string> {\n  constructor() {\n    super({\n      transform(part, controller) {\n        controller.enqueue(`data: ${JSON.stringify(part)}\\n\\n`);\n      },\n      flush(controller) {\n        controller.enqueue('data: [DONE]\\n\\n');\n      },\n    });\n  }\n}\n","export const UI_MESSAGE_STREAM_HEADERS = {\n  'content-type': 'text/event-stream',\n  'cache-control': 'no-cache',\n  connection: 'keep-alive',\n  'x-vercel-ai-ui-message-stream': 'v1',\n  'x-accel-buffering': 'no', // disable nginx buffering\n};\n","import { prepareHeaders } from '../util/prepare-headers';\nimport { JsonToSseTransformStream } from './json-to-sse-transform-stream';\nimport { UI_MESSAGE_STREAM_HEADERS } from './ui-message-stream-headers';\nimport { UIMessageChunk } from './ui-message-chunks';\nimport { UIMessageStreamResponseInit } from './ui-message-stream-response-init';\n\nexport function createUIMessageStreamResponse({\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream,\n}: UIMessageStreamResponseInit & {\n  stream: ReadableStream<UIMessageChunk>;\n}): Response {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n\n  // when the consumeSseStream is provided, we need to tee the stream\n  // and send the second part to the consumeSseStream function\n  // so that it can be consumed by the client independently\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 }); // no await (do not block the response)\n  }\n\n  return new Response(sseStream.pipeThrough(new TextEncoderStream()), {\n    status,\n    statusText,\n    headers: prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS),\n  });\n}\n","import { IdGenerator } from '@ai-sdk/provider-utils';\nimport { UIMessage } from '../ui/ui-messages';\n\nexport function getResponseUIMessageId({\n  originalMessages,\n  responseMessageId,\n}: {\n  originalMessages: UIMessage[] | undefined;\n  responseMessageId: string | IdGenerator;\n}) {\n  // when there are no original messages (i.e. no persistence),\n  // the assistant message id generation is handled on the client side.\n  if (originalMessages == null) {\n    return undefined;\n  }\n\n  const lastMessage = originalMessages[originalMessages.length - 1];\n\n  return lastMessage?.role === 'assistant'\n    ? lastMessage.id\n    : typeof responseMessageId === 'function'\n      ? responseMessageId()\n      : responseMessageId;\n}\n","import { FlexibleSchema, validateTypes } from '@ai-sdk/provider-utils';\nimport { ProviderMetadata } from '../types';\nimport { FinishReason } from '../types/language-model';\nimport {\n  DataUIMessageChunk,\n  InferUIMessageChunk,\n  isDataUIMessageChunk,\n  UIMessageChunk,\n} from '../ui-message-stream/ui-message-chunks';\nimport { ErrorHandler } from '../util/error-handler';\nimport { mergeObjects } from '../util/merge-objects';\nimport { parsePartialJson } from '../util/parse-partial-json';\nimport { UIDataTypesToSchemas } from './chat';\nimport {\n  DataUIPart,\n  DynamicToolUIPart,\n  getStaticToolName,\n  InferUIMessageData,\n  InferUIMessageMetadata,\n  InferUIMessageToolCall,\n  InferUIMessageTools,\n  isStaticToolUIPart,\n  isToolUIPart,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolUIPart,\n  UIMessage,\n  UIMessagePart,\n} from './ui-messages';\n\nexport type StreamingUIMessageState<UI_MESSAGE extends UIMessage> = {\n  message: UI_MESSAGE;\n  activeTextParts: Record<string, TextUIPart>;\n  activeReasoningParts: Record<string, ReasoningUIPart>;\n  partialToolCalls: Record<\n    string,\n    {\n      text: string;\n      index: number;\n      toolName: string;\n      dynamic?: boolean;\n      title?: string;\n    }\n  >;\n  finishReason?: FinishReason;\n};\n\nexport function createStreamingUIMessageState<UI_MESSAGE extends UIMessage>({\n  lastMessage,\n  messageId,\n}: {\n  lastMessage: UI_MESSAGE | undefined;\n  messageId: string;\n}): StreamingUIMessageState<UI_MESSAGE> {\n  return {\n    message:\n      lastMessage?.role === 'assistant'\n        ? lastMessage\n        : ({\n            id: messageId,\n            metadata: undefined,\n            role: 'assistant',\n            parts: [] as UIMessagePart<\n              InferUIMessageData<UI_MESSAGE>,\n              InferUIMessageTools<UI_MESSAGE>\n            >[],\n          } as UI_MESSAGE),\n    activeTextParts: {},\n    activeReasoningParts: {},\n    partialToolCalls: {},\n  };\n}\n\nexport function processUIMessageStream<UI_MESSAGE extends UIMessage>({\n  stream,\n  messageMetadataSchema,\n  dataPartSchemas,\n  runUpdateMessageJob,\n  onError,\n  onToolCall,\n  onData,\n}: {\n  // input stream is not fully typed yet:\n  stream: ReadableStream<UIMessageChunk>;\n  messageMetadataSchema?: FlexibleSchema<InferUIMessageMetadata<UI_MESSAGE>>;\n  dataPartSchemas?: UIDataTypesToSchemas<InferUIMessageData<UI_MESSAGE>>;\n  onToolCall?: (options: {\n    toolCall: InferUIMessageToolCall<UI_MESSAGE>;\n  }) => void | PromiseLike<void>;\n  onData?: (dataPart: DataUIPart<InferUIMessageData<UI_MESSAGE>>) => void;\n  runUpdateMessageJob: (\n    job: (options: {\n      state: StreamingUIMessageState<UI_MESSAGE>;\n      write: () => void;\n    }) => Promise<void>,\n  ) => Promise<void>;\n  onError: ErrorHandler;\n}): ReadableStream<InferUIMessageChunk<UI_MESSAGE>> {\n  return stream.pipeThrough(\n    new TransformStream<UIMessageChunk, InferUIMessageChunk<UI_MESSAGE>>({\n      async transform(chunk, controller) {\n        await runUpdateMessageJob(async ({ state, write }) => {\n          function getToolInvocation(toolCallId: string) {\n            const toolInvocations = state.message.parts.filter(isToolUIPart);\n\n            const toolInvocation = toolInvocations.find(\n              invocation => invocation.toolCallId === toolCallId,\n            );\n\n            if (toolInvocation == null) {\n              throw new Error(\n                `no tool invocation found for tool call ${toolCallId}`,\n              );\n            }\n\n            return toolInvocation;\n          }\n\n          function updateToolPart(\n            options: {\n              toolName: keyof InferUIMessageTools<UI_MESSAGE> & string;\n              toolCallId: string;\n              providerExecuted?: boolean;\n              title?: string;\n            } & (\n              | {\n                  state: 'input-streaming';\n                  input: unknown;\n                  providerExecuted?: boolean;\n                }\n              | {\n                  state: 'input-available';\n                  input: unknown;\n                  providerExecuted?: boolean;\n                  providerMetadata?: ProviderMetadata;\n                }\n              | {\n                  state: 'output-available';\n                  input: unknown;\n                  output: unknown;\n                  providerExecuted?: boolean;\n                  preliminary?: boolean;\n                }\n              | {\n                  state: 'output-error';\n                  input: unknown;\n                  rawInput?: unknown;\n                  errorText: string;\n                  providerExecuted?: boolean;\n                  providerMetadata?: ProviderMetadata;\n                }\n            ),\n          ) {\n            const part = state.message.parts.find(\n              part =>\n                isStaticToolUIPart(part) &&\n                part.toolCallId === options.toolCallId,\n            ) as ToolUIPart<InferUIMessageTools<UI_MESSAGE>> | undefined;\n\n            const anyOptions = options as any;\n            const anyPart = part as any;\n\n            if (part != null) {\n              part.state = options.state;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== undefined) {\n                anyPart.title = options.title;\n              }\n              // once providerExecuted is set, it stays for streaming\n              anyPart.providerExecuted =\n                anyOptions.providerExecuted ?? part.providerExecuted;\n\n              if (\n                anyOptions.providerMetadata != null &&\n                part.state === 'input-available'\n              ) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: `tool-${options.toolName}`,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                title: options.title,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                rawInput: anyOptions.rawInput,\n                errorText: anyOptions.errorText,\n                providerExecuted: anyOptions.providerExecuted,\n                preliminary: anyOptions.preliminary,\n                ...(anyOptions.providerMetadata != null\n                  ? { callProviderMetadata: anyOptions.providerMetadata }\n                  : {}),\n              } as ToolUIPart<InferUIMessageTools<UI_MESSAGE>>);\n            }\n          }\n\n          function updateDynamicToolPart(\n            options: {\n              toolName: keyof InferUIMessageTools<UI_MESSAGE> & string;\n              toolCallId: string;\n              providerExecuted?: boolean;\n              title?: string;\n            } & (\n              | {\n                  state: 'input-streaming';\n                  input: unknown;\n                }\n              | {\n                  state: 'input-available';\n                  input: unknown;\n                  providerMetadata?: ProviderMetadata;\n                }\n              | {\n                  state: 'output-available';\n                  input: unknown;\n                  output: unknown;\n                  preliminary: boolean | undefined;\n                }\n              | {\n                  state: 'output-error';\n                  input: unknown;\n                  errorText: string;\n                  providerMetadata?: ProviderMetadata;\n                }\n            ),\n          ) {\n            const part = state.message.parts.find(\n              part =>\n                part.type === 'dynamic-tool' &&\n                part.toolCallId === options.toolCallId,\n            ) as DynamicToolUIPart | undefined;\n\n            const anyOptions = options as any;\n            const anyPart = part as any;\n\n            if (part != null) {\n              part.state = options.state;\n              anyPart.toolName = options.toolName;\n              anyPart.input = anyOptions.input;\n              anyPart.output = anyOptions.output;\n              anyPart.errorText = anyOptions.errorText;\n              anyPart.rawInput = anyOptions.rawInput ?? anyPart.rawInput;\n              anyPart.preliminary = anyOptions.preliminary;\n              if (options.title !== undefined) {\n                anyPart.title = options.title;\n              }\n              // once providerExecuted is set, it stays for streaming\n              anyPart.providerExecuted =\n                anyOptions.providerExecuted ?? part.providerExecuted;\n\n              if (\n                anyOptions.providerMetadata != null &&\n                part.state === 'input-available'\n              ) {\n                part.callProviderMetadata = anyOptions.providerMetadata;\n              }\n            } else {\n              state.message.parts.push({\n                type: 'dynamic-tool',\n                toolName: options.toolName,\n                toolCallId: options.toolCallId,\n                state: options.state,\n                input: anyOptions.input,\n                output: anyOptions.output,\n                errorText: anyOptions.errorText,\n                preliminary: anyOptions.preliminary,\n                providerExecuted: anyOptions.providerExecuted,\n                title: options.title,\n                ...(anyOptions.providerMetadata != null\n                  ? { callProviderMetadata: anyOptions.providerMetadata }\n                  : {}),\n              } as DynamicToolUIPart);\n            }\n          }\n\n          async function updateMessageMetadata(metadata: unknown) {\n            if (metadata != null) {\n              const mergedMetadata =\n                state.message.metadata != null\n                  ? mergeObjects(state.message.metadata, metadata)\n                  : metadata;\n\n              if (messageMetadataSchema != null) {\n                await validateTypes({\n                  value: mergedMetadata,\n                  schema: messageMetadataSchema,\n                });\n              }\n\n              state.message.metadata =\n                mergedMetadata as InferUIMessageMetadata<UI_MESSAGE>;\n            }\n          }\n\n          switch (chunk.type) {\n            case 'text-start': {\n              const textPart: TextUIPart = {\n                type: 'text',\n                text: '',\n                providerMetadata: chunk.providerMetadata,\n                state: 'streaming',\n              };\n              state.activeTextParts[chunk.id] = textPart;\n              state.message.parts.push(textPart);\n              write();\n              break;\n            }\n\n            case 'text-delta': {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.text += chunk.delta;\n              textPart.providerMetadata =\n                chunk.providerMetadata ?? textPart.providerMetadata;\n              write();\n              break;\n            }\n\n            case 'text-end': {\n              const textPart = state.activeTextParts[chunk.id];\n              textPart.state = 'done';\n              textPart.providerMetadata =\n                chunk.providerMetadata ?? textPart.providerMetadata;\n              delete state.activeTextParts[chunk.id];\n              write();\n              break;\n            }\n\n            case 'reasoning-start': {\n              const reasoningPart: ReasoningUIPart = {\n                type: 'reasoning',\n                text: '',\n                providerMetadata: chunk.providerMetadata,\n                state: 'streaming',\n              };\n              state.activeReasoningParts[chunk.id] = reasoningPart;\n              state.message.parts.push(reasoningPart);\n              write();\n              break;\n            }\n\n            case 'reasoning-delta': {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.text += chunk.delta;\n              reasoningPart.providerMetadata =\n                chunk.providerMetadata ?? reasoningPart.providerMetadata;\n              write();\n              break;\n            }\n\n            case 'reasoning-end': {\n              const reasoningPart = state.activeReasoningParts[chunk.id];\n              reasoningPart.providerMetadata =\n                chunk.providerMetadata ?? reasoningPart.providerMetadata;\n              reasoningPart.state = 'done';\n              delete state.activeReasoningParts[chunk.id];\n\n              write();\n              break;\n            }\n\n            case 'file': {\n              state.message.parts.push({\n                type: 'file',\n                mediaType: chunk.mediaType,\n                url: chunk.url,\n              });\n\n              write();\n              break;\n            }\n\n            case 'source-url': {\n              state.message.parts.push({\n                type: 'source-url',\n                sourceId: chunk.sourceId,\n                url: chunk.url,\n                title: chunk.title,\n                providerMetadata: chunk.providerMetadata,\n              });\n\n              write();\n              break;\n            }\n\n            case 'source-document': {\n              state.message.parts.push({\n                type: 'source-document',\n                sourceId: chunk.sourceId,\n                mediaType: chunk.mediaType,\n                title: chunk.title,\n                filename: chunk.filename,\n                providerMetadata: chunk.providerMetadata,\n              });\n\n              write();\n              break;\n            }\n\n            case 'tool-input-start': {\n              const toolInvocations =\n                state.message.parts.filter(isStaticToolUIPart);\n\n              // add the partial tool call to the map\n              state.partialToolCalls[chunk.toolCallId] = {\n                text: '',\n                toolName: chunk.toolName,\n                index: toolInvocations.length,\n                dynamic: chunk.dynamic,\n                title: chunk.title,\n              };\n\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'input-streaming',\n                  input: undefined,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'input-streaming',\n                  input: undefined,\n                  providerExecuted: chunk.providerExecuted,\n                  title: chunk.title,\n                });\n              }\n\n              write();\n              break;\n            }\n\n            case 'tool-input-delta': {\n              const partialToolCall = state.partialToolCalls[chunk.toolCallId];\n\n              partialToolCall.text += chunk.inputTextDelta;\n\n              const { value: partialArgs } = await parsePartialJson(\n                partialToolCall.text,\n              );\n\n              if (partialToolCall.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: 'input-streaming',\n                  input: partialArgs,\n                  title: partialToolCall.title,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: partialToolCall.toolName,\n                  state: 'input-streaming',\n                  input: partialArgs,\n                  title: partialToolCall.title,\n                });\n              }\n\n              write();\n              break;\n            }\n\n            case 'tool-input-available': {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'input-available',\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'input-available',\n                  input: chunk.input,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                  title: chunk.title,\n                });\n              }\n\n              write();\n\n              // invoke the onToolCall callback if it exists. This is blocking.\n              // In the future we should make this non-blocking, which\n              // requires additional state management for error handling etc.\n              // Skip calling onToolCall for provider-executed tools since they are already executed\n              if (onToolCall && !chunk.providerExecuted) {\n                await onToolCall({\n                  toolCall: chunk as InferUIMessageToolCall<UI_MESSAGE>,\n                });\n              }\n              break;\n            }\n\n            case 'tool-input-error': {\n              if (chunk.dynamic) {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'output-error',\n                  input: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: chunk.toolName,\n                  state: 'output-error',\n                  input: undefined,\n                  rawInput: chunk.input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  providerMetadata: chunk.providerMetadata,\n                });\n              }\n\n              write();\n              break;\n            }\n\n            case 'tool-approval-request': {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = 'approval-requested';\n              toolInvocation.approval = { id: chunk.approvalId };\n              write();\n              break;\n            }\n\n            case 'tool-output-denied': {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n              toolInvocation.state = 'output-denied';\n              write();\n              break;\n            }\n\n            case 'tool-output-available': {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n\n              if (toolInvocation.type === 'dynamic-tool') {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: 'output-available',\n                  input: (toolInvocation as any).input,\n                  output: chunk.output,\n                  preliminary: chunk.preliminary,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: 'output-available',\n                  input: (toolInvocation as any).input,\n                  output: chunk.output,\n                  providerExecuted: chunk.providerExecuted,\n                  preliminary: chunk.preliminary,\n                  title: toolInvocation.title,\n                });\n              }\n\n              write();\n              break;\n            }\n\n            case 'tool-output-error': {\n              const toolInvocation = getToolInvocation(chunk.toolCallId);\n\n              if (toolInvocation.type === 'dynamic-tool') {\n                updateDynamicToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: toolInvocation.toolName,\n                  state: 'output-error',\n                  input: (toolInvocation as any).input,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title,\n                });\n              } else {\n                updateToolPart({\n                  toolCallId: chunk.toolCallId,\n                  toolName: getStaticToolName(toolInvocation),\n                  state: 'output-error',\n                  input: (toolInvocation as any).input,\n                  rawInput: (toolInvocation as any).rawInput,\n                  errorText: chunk.errorText,\n                  providerExecuted: chunk.providerExecuted,\n                  title: toolInvocation.title,\n                });\n              }\n\n              write();\n              break;\n            }\n\n            case 'start-step': {\n              // add a step boundary part to the message\n              state.message.parts.push({ type: 'step-start' });\n              break;\n            }\n\n            case 'finish-step': {\n              // reset the current text and reasoning parts\n              state.activeTextParts = {};\n              state.activeReasoningParts = {};\n              break;\n            }\n\n            case 'start': {\n              if (chunk.messageId != null) {\n                state.message.id = chunk.messageId;\n              }\n\n              await updateMessageMetadata(chunk.messageMetadata);\n\n              if (chunk.messageId != null || chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n\n            case 'finish': {\n              if (chunk.finishReason != null) {\n                state.finishReason = chunk.finishReason;\n              }\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n\n            case 'message-metadata': {\n              await updateMessageMetadata(chunk.messageMetadata);\n              if (chunk.messageMetadata != null) {\n                write();\n              }\n              break;\n            }\n\n            case 'error': {\n              onError?.(new Error(chunk.errorText));\n              break;\n            }\n\n            default: {\n              if (isDataUIMessageChunk(chunk)) {\n                // validate data chunk if dataPartSchemas is provided\n                if (dataPartSchemas?.[chunk.type] != null) {\n                  await validateTypes({\n                    value: chunk.data,\n                    schema: dataPartSchemas[chunk.type],\n                  });\n                }\n\n                // cast, validation is done above\n                const dataChunk = chunk as DataUIMessageChunk<\n                  InferUIMessageData<UI_MESSAGE>\n                >;\n\n                // transient parts are not added to the message state\n                if (dataChunk.transient) {\n                  onData?.(dataChunk);\n                  break;\n                }\n\n                const existingUIPart =\n                  dataChunk.id != null\n                    ? (state.message.parts.find(\n                        chunkArg =>\n                          dataChunk.type === chunkArg.type &&\n                          dataChunk.id === chunkArg.id,\n                      ) as\n                        | DataUIPart<InferUIMessageData<UI_MESSAGE>>\n                        | undefined)\n                    : undefined;\n\n                if (existingUIPart != null) {\n                  existingUIPart.data = dataChunk.data;\n                } else {\n                  state.message.parts.push(dataChunk);\n                }\n\n                onData?.(dataChunk);\n\n                write();\n              }\n            }\n          }\n\n          controller.enqueue(chunk as InferUIMessageChunk<UI_MESSAGE>);\n        });\n      },\n    }),\n  );\n}\n","import { z } from 'zod/v4';\nimport {\n  ProviderMetadata,\n  providerMetadataSchema,\n} from '../types/provider-metadata';\nimport { FinishReason } from '../types/language-model';\nimport {\n  InferUIMessageData,\n  InferUIMessageMetadata,\n  UIDataTypes,\n  UIMessage,\n} from '../ui/ui-messages';\nimport { ValueOf } from '../util/value-of';\nimport { lazySchema, zodSchema } from '@ai-sdk/provider-utils';\n\nexport const uiMessageChunkSchema = lazySchema(() =>\n  zodSchema(\n    z.union([\n      z.strictObject({\n        type: z.literal('text-start'),\n        id: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('text-delta'),\n        id: z.string(),\n        delta: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('text-end'),\n        id: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('error'),\n        errorText: z.string(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-input-start'),\n        toolCallId: z.string(),\n        toolName: z.string(),\n        providerExecuted: z.boolean().optional(),\n        dynamic: z.boolean().optional(),\n        title: z.string().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-input-delta'),\n        toolCallId: z.string(),\n        inputTextDelta: z.string(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-input-available'),\n        toolCallId: z.string(),\n        toolName: z.string(),\n        input: z.unknown(),\n        providerExecuted: z.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: z.boolean().optional(),\n        title: z.string().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-input-error'),\n        toolCallId: z.string(),\n        toolName: z.string(),\n        input: z.unknown(),\n        providerExecuted: z.boolean().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n        dynamic: z.boolean().optional(),\n        errorText: z.string(),\n        title: z.string().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-approval-request'),\n        approvalId: z.string(),\n        toolCallId: z.string(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-output-available'),\n        toolCallId: z.string(),\n        output: z.unknown(),\n        providerExecuted: z.boolean().optional(),\n        dynamic: z.boolean().optional(),\n        preliminary: z.boolean().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-output-error'),\n        toolCallId: z.string(),\n        errorText: z.string(),\n        providerExecuted: z.boolean().optional(),\n        dynamic: z.boolean().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('tool-output-denied'),\n        toolCallId: z.string(),\n      }),\n      z.strictObject({\n        type: z.literal('reasoning-start'),\n        id: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('reasoning-delta'),\n        id: z.string(),\n        delta: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('reasoning-end'),\n        id: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('source-url'),\n        sourceId: z.string(),\n        url: z.string(),\n        title: z.string().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('source-document'),\n        sourceId: z.string(),\n        mediaType: z.string(),\n        title: z.string(),\n        filename: z.string().optional(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.literal('file'),\n        url: z.string(),\n        mediaType: z.string(),\n        providerMetadata: providerMetadataSchema.optional(),\n      }),\n      z.strictObject({\n        type: z.custom<`data-${string}`>(\n          (value): value is `data-${string}` =>\n            typeof value === 'string' && value.startsWith('data-'),\n          { message: 'Type must start with \"data-\"' },\n        ),\n        id: z.string().optional(),\n        data: z.unknown(),\n        transient: z.boolean().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('start-step'),\n      }),\n      z.strictObject({\n        type: z.literal('finish-step'),\n      }),\n      z.strictObject({\n        type: z.literal('start'),\n        messageId: z.string().optional(),\n        messageMetadata: z.unknown().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('finish'),\n        finishReason: z\n          .enum([\n            'stop',\n            'length',\n            'content-filter',\n            'tool-calls',\n            'error',\n            'other',\n          ] as const satisfies readonly FinishReason[])\n          .optional(),\n        messageMetadata: z.unknown().optional(),\n      }),\n      z.strictObject({\n        type: z.literal('abort'),\n      }),\n      z.strictObject({\n        type: z.literal('message-metadata'),\n        messageMetadata: z.unknown(),\n      }),\n    ]),\n  ),\n);\n\nexport type DataUIMessageChunk<DATA_TYPES extends UIDataTypes> = ValueOf<{\n  [NAME in keyof DATA_TYPES & string]: {\n    type: `data-${NAME}`;\n    id?: string;\n    data: DATA_TYPES[NAME];\n    transient?: boolean;\n  };\n}>;\n\nexport type UIMessageChunk<\n  METADATA = unknown,\n  DATA_TYPES extends UIDataTypes = UIDataTypes,\n> =\n  | {\n      type: 'text-start';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'text-delta';\n      delta: string;\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'text-end';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'reasoning-start';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'reasoning-delta';\n      id: string;\n      delta: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'reasoning-end';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'error';\n      errorText: string;\n    }\n  | {\n      type: 'tool-input-available';\n      toolCallId: string;\n      toolName: string;\n      input: unknown;\n      providerExecuted?: boolean;\n      providerMetadata?: ProviderMetadata;\n      dynamic?: boolean;\n      title?: string;\n    }\n  | {\n      type: 'tool-input-error';\n      toolCallId: string;\n      toolName: string;\n      input: unknown;\n      providerExecuted?: boolean;\n      providerMetadata?: ProviderMetadata;\n      dynamic?: boolean;\n      errorText: string;\n      title?: string;\n    }\n  | {\n      type: 'tool-approval-request';\n      approvalId: string;\n      toolCallId: string;\n    }\n  | {\n      type: 'tool-output-available';\n      toolCallId: string;\n      output: unknown;\n      providerExecuted?: boolean;\n      dynamic?: boolean;\n      preliminary?: boolean;\n    }\n  | {\n      type: 'tool-output-error';\n      toolCallId: string;\n      errorText: string;\n      providerExecuted?: boolean;\n      dynamic?: boolean;\n    }\n  | {\n      type: 'tool-output-denied';\n      toolCallId: string;\n    }\n  | {\n      type: 'tool-input-start';\n      toolCallId: string;\n      toolName: string;\n      providerExecuted?: boolean;\n      dynamic?: boolean;\n      title?: string;\n    }\n  | {\n      type: 'tool-input-delta';\n      toolCallId: string;\n      inputTextDelta: string;\n    }\n  | {\n      type: 'source-url';\n      sourceId: string;\n      url: string;\n      title?: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'source-document';\n      sourceId: string;\n      mediaType: string;\n      title: string;\n      filename?: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'file';\n      url: string;\n      mediaType: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | DataUIMessageChunk<DATA_TYPES>\n  | {\n      type: 'start-step';\n    }\n  | {\n      type: 'finish-step';\n    }\n  | {\n      type: 'start';\n      messageId?: string;\n      messageMetadata?: METADATA;\n    }\n  | {\n      type: 'finish';\n      finishReason?: FinishReason;\n      messageMetadata?: METADATA;\n    }\n  | {\n      type: 'abort';\n    }\n  | {\n      type: 'message-metadata';\n      messageMetadata: METADATA;\n    };\n\nexport function isDataUIMessageChunk(\n  chunk: UIMessageChunk,\n): chunk is DataUIMessageChunk<UIDataTypes> {\n  return chunk.type.startsWith('data-');\n}\n\nexport type InferUIMessageChunk<T extends UIMessage> = UIMessageChunk<\n  InferUIMessageMetadata<T>,\n  InferUIMessageData<T>\n>;\n","import {\n  InferToolInput,\n  InferToolOutput,\n  Tool,\n  ToolCall,\n} from '@ai-sdk/provider-utils';\nimport { ToolSet } from '../generate-text';\nimport { ProviderMetadata } from '../types/provider-metadata';\nimport { DeepPartial } from '../util/deep-partial';\nimport { ValueOf } from '../util/value-of';\n\n/**\nThe data types that can be used in the UI message for the UI message data parts.\n */\nexport type UIDataTypes = Record<string, unknown>;\n\nexport type UITool = {\n  input: unknown;\n  output: unknown | undefined;\n};\n\n/**\n * Infer the input and output types of a tool so it can be used as a UI tool.\n */\nexport type InferUITool<TOOL extends Tool> = {\n  input: InferToolInput<TOOL>;\n  output: InferToolOutput<TOOL>;\n};\n\n/**\n * Infer the input and output types of a tool set so it can be used as a UI tool set.\n */\nexport type InferUITools<TOOLS extends ToolSet> = {\n  [NAME in keyof TOOLS & string]: InferUITool<TOOLS[NAME]>;\n};\n\nexport type UITools = Record<string, UITool>;\n\n/**\nAI SDK UI Messages. They are used in the client and to communicate between the frontend and the API routes.\n */\nexport interface UIMessage<\n  METADATA = unknown,\n  DATA_PARTS extends UIDataTypes = UIDataTypes,\n  TOOLS extends UITools = UITools,\n> {\n  /**\nA unique identifier for the message.\n   */\n  id: string;\n\n  /**\nThe role of the message.\n   */\n  role: 'system' | 'user' | 'assistant';\n\n  /**\nThe metadata of the message.\n   */\n  metadata?: METADATA;\n\n  /**\nThe parts of the message. Use this for rendering the message in the UI.\n\nSystem messages should be avoided (set the system prompt on the server instead).\nThey can have text parts.\n\nUser messages can have text parts and file parts.\n\nAssistant messages can have text, reasoning, tool invocation, and file parts.\n   */\n  parts: Array<UIMessagePart<DATA_PARTS, TOOLS>>;\n}\n\nexport type UIMessagePart<\n  DATA_TYPES extends UIDataTypes,\n  TOOLS extends UITools,\n> =\n  | TextUIPart\n  | ReasoningUIPart\n  | ToolUIPart<TOOLS>\n  | DynamicToolUIPart\n  | SourceUrlUIPart\n  | SourceDocumentUIPart\n  | FileUIPart\n  | DataUIPart<DATA_TYPES>\n  | StepStartUIPart;\n\n/**\n * A text part of a message.\n */\nexport type TextUIPart = {\n  type: 'text';\n\n  /**\n   * The text content.\n   */\n  text: string;\n\n  /**\n   * The state of the text part.\n   */\n  state?: 'streaming' | 'done';\n\n  /**\n   * The provider metadata.\n   */\n  providerMetadata?: ProviderMetadata;\n};\n\n/**\n * A reasoning part of a message.\n */\nexport type ReasoningUIPart = {\n  type: 'reasoning';\n\n  /**\n   * The reasoning text.\n   */\n  text: string;\n\n  /**\n   * The state of the reasoning part.\n   */\n  state?: 'streaming' | 'done';\n\n  /**\n   * The provider metadata.\n   */\n  providerMetadata?: ProviderMetadata;\n};\n\n/**\n * A source part of a message.\n */\nexport type SourceUrlUIPart = {\n  type: 'source-url';\n  sourceId: string;\n  url: string;\n  title?: string;\n  providerMetadata?: ProviderMetadata;\n};\n\n/**\n * A document source part of a message.\n */\nexport type SourceDocumentUIPart = {\n  type: 'source-document';\n  sourceId: string;\n  mediaType: string;\n  title: string;\n  filename?: string;\n  providerMetadata?: ProviderMetadata;\n};\n\n/**\n * A file part of a message.\n */\nexport type FileUIPart = {\n  type: 'file';\n\n  /**\n   * IANA media type of the file.\n   *\n   * @see https://www.iana.org/assignments/media-types/media-types.xhtml\n   */\n  mediaType: string;\n\n  /**\n   * Optional filename of the file.\n   */\n  filename?: string;\n\n  /**\n   * The URL of the file.\n   * It can either be a URL to a hosted file or a [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs).\n   */\n  url: string;\n\n  /**\n   * The provider metadata.\n   */\n  providerMetadata?: ProviderMetadata;\n};\n\n/**\n * A step boundary part of a message.\n */\nexport type StepStartUIPart = {\n  type: 'step-start';\n};\n\nexport type DataUIPart<DATA_TYPES extends UIDataTypes> = ValueOf<{\n  [NAME in keyof DATA_TYPES & string]: {\n    type: `data-${NAME}`;\n    id?: string;\n    data: DATA_TYPES[NAME];\n  };\n}>;\n\ntype asUITool<TOOL extends UITool | Tool> = TOOL extends Tool\n  ? InferUITool<TOOL>\n  : TOOL;\n\n/**\n * Check if a message part is a data part.\n */\nexport function isDataUIPart<DATA_TYPES extends UIDataTypes>(\n  part: UIMessagePart<DATA_TYPES, UITools>,\n): part is DataUIPart<DATA_TYPES> {\n  return part.type.startsWith('data-');\n}\n\n/**\n * A UI tool invocation contains all the information needed to render a tool invocation in the UI.\n * It can be derived from a tool without knowing the tool name, and can be used to define\n * UI components for the tool.\n */\nexport type UIToolInvocation<TOOL extends UITool | Tool> = {\n  /**\n   * ID of the tool call.\n   */\n  toolCallId: string;\n  title?: string;\n\n  /**\n   * Whether the tool call was executed by the provider.\n   */\n  providerExecuted?: boolean;\n} & (\n  | {\n      state: 'input-streaming';\n      input: DeepPartial<asUITool<TOOL>['input']> | undefined;\n      output?: never;\n      errorText?: never;\n      approval?: never;\n    }\n  | {\n      state: 'input-available';\n      input: asUITool<TOOL>['input'];\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval?: never;\n    }\n  | {\n      state: 'approval-requested';\n      input: asUITool<TOOL>['input'];\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved?: never;\n        reason?: never;\n      };\n    }\n  | {\n      state: 'approval-responded';\n      input: asUITool<TOOL>['input'];\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved: boolean;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-available';\n      input: asUITool<TOOL>['input'];\n      output: asUITool<TOOL>['output'];\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      preliminary?: boolean;\n      approval?: {\n        id: string;\n        approved: true;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-error'; // TODO AI SDK 6: change to 'error' state\n      input: asUITool<TOOL>['input'] | undefined;\n      rawInput?: unknown; // TODO AI SDK 6: remove this field, input should be unknown\n      output?: never;\n      errorText: string;\n      callProviderMetadata?: ProviderMetadata;\n      approval?: {\n        id: string;\n        approved: true;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-denied';\n      input: asUITool<TOOL>['input'];\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved: false;\n        reason?: string;\n      };\n    }\n);\n\nexport type ToolUIPart<TOOLS extends UITools = UITools> = ValueOf<{\n  [NAME in keyof TOOLS & string]: {\n    type: `tool-${NAME}`;\n  } & UIToolInvocation<TOOLS[NAME]>;\n}>;\n\nexport type DynamicToolUIPart = {\n  type: 'dynamic-tool';\n\n  /**\n   * Name of the tool that is being called.\n   */\n  toolName: string;\n\n  /**\n   * ID of the tool call.\n   */\n  toolCallId: string;\n  title?: string;\n\n  /**\n   * Whether the tool call was executed by the provider.\n   */\n  providerExecuted?: boolean;\n} & (\n  | {\n      state: 'input-streaming';\n      input: unknown | undefined;\n      output?: never;\n      errorText?: never;\n      approval?: never;\n    }\n  | {\n      state: 'input-available';\n      input: unknown;\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval?: never;\n    }\n  | {\n      state: 'approval-requested';\n      input: unknown;\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved?: never;\n        reason?: never;\n      };\n    }\n  | {\n      state: 'approval-responded';\n      input: unknown;\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved: boolean;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-available';\n      input: unknown;\n      output: unknown;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      preliminary?: boolean;\n      approval?: {\n        id: string;\n        approved: true;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-error'; // TODO AI SDK 6: change to 'error' state\n      input: unknown;\n      output?: never;\n      errorText: string;\n      callProviderMetadata?: ProviderMetadata;\n      approval?: {\n        id: string;\n        approved: true;\n        reason?: string;\n      };\n    }\n  | {\n      state: 'output-denied';\n      input: unknown;\n      output?: never;\n      errorText?: never;\n      callProviderMetadata?: ProviderMetadata;\n      approval: {\n        id: string;\n        approved: false;\n        reason?: string;\n      };\n    }\n);\n\n/**\n * Type guard to check if a message part is a text part.\n */\nexport function isTextUIPart(\n  part: UIMessagePart<UIDataTypes, UITools>,\n): part is TextUIPart {\n  return part.type === 'text';\n}\n\n/**\n * Type guard to check if a message part is a file part.\n */\nexport function isFileUIPart(\n  part: UIMessagePart<UIDataTypes, UITools>,\n): part is FileUIPart {\n  return part.type === 'file';\n}\n\n/**\n * Type guard to check if a message part is a reasoning part.\n */\nexport function isReasoningUIPart(\n  part: UIMessagePart<UIDataTypes, UITools>,\n): part is ReasoningUIPart {\n  return part.type === 'reasoning';\n}\n\n/**\n * Check if a message part is a static tool part.\n *\n * Static tools are tools for which the types are known at development time.\n */\nexport function isStaticToolUIPart<TOOLS extends UITools>(\n  part: UIMessagePart<UIDataTypes, TOOLS>,\n): part is ToolUIPart<TOOLS> {\n  return part.type.startsWith('tool-');\n}\n\n/**\n * Check if a message part is a dynamic tool part.\n *\n * Dynamic tools are tools for which the input and output types are unknown.\n */\nexport function isDynamicToolUIPart(\n  part: UIMessagePart<UIDataTypes, UITools>,\n): part is DynamicToolUIPart {\n  return part.type === 'dynamic-tool';\n}\n\n/**\n * Check if a message part is a tool part.\n *\n * Tool parts are either static or dynamic tools.\n *\n * Use `isStaticToolUIPart` or `isDynamicToolUIPart` to check the type of the tool.\n */\nexport function isToolUIPart<TOOLS extends UITools>(\n  part: UIMessagePart<UIDataTypes, TOOLS>,\n): part is ToolUIPart<TOOLS> | DynamicToolUIPart {\n  return isStaticToolUIPart(part) || isDynamicToolUIPart(part);\n}\n\n/**\n * @deprecated Use isToolUIPart instead.\n */\nexport const isToolOrDynamicToolUIPart = isToolUIPart;\n\n/**\n * Returns the name of the static tool.\n *\n * The possible values are the keys of the tool set.\n */\nexport function getStaticToolName<TOOLS extends UITools>(\n  part: ToolUIPart<TOOLS>,\n): keyof TOOLS {\n  return part.type.split('-').slice(1).join('-') as keyof TOOLS;\n}\n\n/**\n * Returns the name of the tool (static or dynamic).\n *\n * This function will not restrict the name to the keys of the tool set.\n * If you need to restrict the name to the keys of the tool set, use `getStaticToolName` instead.\n */\nexport function getToolName(\n  part: ToolUIPart<UITools> | DynamicToolUIPart,\n): string {\n  return isDynamicToolUIPart(part) ? part.toolName : getStaticToolName(part);\n}\n\n/**\n * @deprecated Use getToolName instead.\n */\nexport const getToolOrDynamicToolName = getToolName;\n\nexport type InferUIMessageMetadata<T extends UIMessage> =\n  T extends UIMessage<infer METADATA> ? METADATA : unknown;\n\nexport type InferUIMessageData<T extends UIMessage> =\n  T extends UIMessage<unknown, infer DATA_TYPES> ? DATA_TYPES : UIDataTypes;\n\nexport type InferUIMessageTools<T extends UIMessage> =\n  T extends UIMessage<unknown, UIDataTypes, infer TOOLS> ? TOOLS : UITools;\n\nexport type InferUIMessageToolOutputs<UI_MESSAGE extends UIMessage> =\n  InferUIMessageTools<UI_MESSAGE>[keyof InferUIMessageTools<UI_MESSAGE>]['output'];\n\nexport type InferUIMessageToolCall<UI_MESSAGE extends UIMessage> =\n  | ValueOf<{\n      [NAME in keyof InferUIMessageTools<UI_MESSAGE>]: ToolCall<\n        NAME & string,\n        InferUIMessageTools<UI_MESSAGE>[NAME] extends { input: infer INPUT }\n          ? INPUT\n          : never\n      > & { dynamic?: false };\n    }>\n  | (ToolCall<string, unknown> & { dynamic: true });\n\nexport type InferUIMessagePart<UI_MESSAGE extends UIMessage> = UIMessagePart<\n  InferUIMessageData<UI_MESSAGE>,\n  InferUIMessageTools<UI_MESSAGE>\n>;\n","import {\n  createStreamingUIMessageState,\n  processUIMessageStream,\n  StreamingUIMessageState,\n} from '../ui/process-ui-message-stream';\nimport { UIMessage } from '../ui/ui-messages';\nimport { ErrorHandler } from '../util/error-handler';\nimport { InferUIMessageChunk, UIMessageChunk } from './ui-message-chunks';\nimport { UIMessageStreamOnFinishCallback } from './ui-message-stream-on-finish-callback';\n\nexport function handleUIMessageStreamFinish<UI_MESSAGE extends UIMessage>({\n  messageId,\n  originalMessages = [],\n  onFinish,\n  onError,\n  stream,\n}: {\n  stream: ReadableStream<InferUIMessageChunk<UI_MESSAGE>>;\n\n  /**\n   * The message ID to use for the response message.\n   * If not provided, no id will be set for the response message.\n   */\n  messageId?: string;\n\n  /**\n   * The original messages.\n   */\n  originalMessages?: UI_MESSAGE[];\n\n  onError: ErrorHandler;\n\n  onFinish?: UIMessageStreamOnFinishCallback<UI_MESSAGE>;\n}): ReadableStream<InferUIMessageChunk<UI_MESSAGE>> {\n  // last message is only relevant for assistant messages\n  let lastMessage: UI_MESSAGE | undefined =\n    originalMessages?.[originalMessages.length - 1];\n  if (lastMessage?.role !== 'assistant') {\n    lastMessage = undefined;\n  } else {\n    // appending to the last message, so we need to use the same id\n    messageId = lastMessage.id;\n  }\n\n  let isAborted = false;\n\n  const idInjectedStream = stream.pipeThrough(\n    new TransformStream<\n      InferUIMessageChunk<UI_MESSAGE>,\n      InferUIMessageChunk<UI_MESSAGE>\n    >({\n      transform(chunk, controller) {\n        // when there is no messageId in the start chunk,\n        // but the user checked for persistence,\n        // inject the messageId into the chunk\n        if (chunk.type === 'start') {\n          const startChunk = chunk as UIMessageChunk & { type: 'start' };\n          if (startChunk.messageId == null && messageId != null) {\n            startChunk.messageId = messageId;\n          }\n        }\n\n        if (chunk.type === 'abort') {\n          isAborted = true;\n        }\n\n        controller.enqueue(chunk);\n      },\n    }),\n  );\n\n  if (onFinish == null) {\n    return idInjectedStream;\n  }\n\n  const state = createStreamingUIMessageState<UI_MESSAGE>({\n    lastMessage: lastMessage\n      ? (structuredClone(lastMessage) as UI_MESSAGE)\n      : undefined,\n    messageId: messageId ?? '', // will be overridden by the stream\n  });\n\n  const runUpdateMessageJob = async (\n    job: (options: {\n      state: StreamingUIMessageState<UI_MESSAGE>;\n      write: () => void;\n    }) => Promise<void>,\n  ) => {\n    await job({ state, write: () => {} });\n  };\n\n  let finishCalled = false;\n\n  const callOnFinish = async () => {\n    if (finishCalled || !onFinish) {\n      return;\n    }\n    finishCalled = true;\n\n    const isContinuation = state.message.id === lastMessage?.id;\n    await onFinish({\n      isAborted,\n      isContinuation,\n      responseMessage: state.message as UI_MESSAGE,\n      messages: [\n        ...(isContinuation ? originalMessages.slice(0, -1) : originalMessages),\n        state.message,\n      ] as UI_MESSAGE[],\n      finishReason: state.finishReason,\n    });\n  };\n\n  return processUIMessageStream<UI_MESSAGE>({\n    stream: idInjectedStream,\n    runUpdateMessageJob,\n    onError,\n  }).pipeThrough(\n    new TransformStream<\n      InferUIMessageChunk<UI_MESSAGE>,\n      InferUIMessageChunk<UI_MESSAGE>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n      },\n      // @ts-expect-error cancel is still new and missing from types https://developer.mozilla.org/en-US/docs/Web/API/TransformStream#browser_compatibility\n      async cancel() {\n        await callOnFinish();\n      },\n\n      async flush() {\n        await callOnFinish();\n      },\n    }),\n  );\n}\n","import { ServerResponse } from 'node:http';\nimport { prepareHeaders } from '../util/prepare-headers';\nimport { writeToServerResponse } from '../util/write-to-server-response';\nimport { JsonToSseTransformStream } from './json-to-sse-transform-stream';\nimport { UI_MESSAGE_STREAM_HEADERS } from './ui-message-stream-headers';\nimport { UIMessageChunk } from './ui-message-chunks';\nimport { UIMessageStreamResponseInit } from './ui-message-stream-response-init';\n\nexport function pipeUIMessageStreamToResponse({\n  response,\n  status,\n  statusText,\n  headers,\n  stream,\n  consumeSseStream,\n}: {\n  response: ServerResponse;\n  stream: ReadableStream<UIMessageChunk>;\n} & UIMessageStreamResponseInit): void {\n  let sseStream = stream.pipeThrough(new JsonToSseTransformStream());\n\n  // when the consumeSseStream is provided, we need to tee the stream\n  // and send the second part to the consumeSseStream function\n  // so that it can be consumed by the client independently\n  if (consumeSseStream) {\n    const [stream1, stream2] = sseStream.tee();\n    sseStream = stream1;\n    consumeSseStream({ stream: stream2 }); // no await (do not block the response)\n  }\n\n  writeToServerResponse({\n    response,\n    status,\n    statusText,\n    headers: Object.fromEntries(\n      prepareHeaders(headers, UI_MESSAGE_STREAM_HEADERS).entries(),\n    ),\n    stream: sseStream.pipeThrough(new TextEncoderStream()),\n  });\n}\n","/**\n * A type that combines AsyncIterable and ReadableStream.\n * This allows a ReadableStream to be consumed using for-await-of syntax.\n */\nexport type AsyncIterableStream<T> = AsyncIterable<T> & ReadableStream<T>;\n\n/**\n * Wraps a ReadableStream and returns an object that is both a ReadableStream and an AsyncIterable.\n * This enables consumption of the stream using for-await-of, with proper resource cleanup on early exit or error.\n *\n * @template T The type of the stream's chunks.\n * @param source The source ReadableStream to wrap.\n * @returns An AsyncIterableStream that can be used as both a ReadableStream and an AsyncIterable.\n */\nexport function createAsyncIterableStream<T>(\n  source: ReadableStream<T>,\n): AsyncIterableStream<T> {\n  // Pipe through a TransformStream to ensure a fresh, unlocked stream.\n  const stream = source.pipeThrough(new TransformStream<T, T>());\n\n  /**\n   * Implements the async iterator protocol for the stream.\n   * Ensures proper cleanup (cancelling and releasing the reader) on completion, early exit, or error.\n   */\n  (stream as AsyncIterableStream<T>)[Symbol.asyncIterator] = function (\n    this: ReadableStream<T>,\n  ): AsyncIterator<T> {\n    const reader = this.getReader();\n\n    let finished = false;\n\n    /**\n     * Cleans up the reader by cancelling and releasing the lock.\n     */\n    async function cleanup(cancelStream: boolean) {\n      finished = true;\n      try {\n        if (cancelStream) {\n          await reader.cancel?.();\n        }\n      } finally {\n        try {\n          reader.releaseLock();\n        } catch {}\n      }\n    }\n\n    return {\n      /**\n       * Reads the next chunk from the stream.\n       * @returns A promise resolving to the next IteratorResult.\n       */\n      async next(): Promise<IteratorResult<T>> {\n        if (finished) {\n          return { done: true, value: undefined };\n        }\n\n        const { done, value } = await reader.read();\n\n        if (done) {\n          await cleanup(true);\n          return { done: true, value: undefined };\n        }\n\n        return { done: false, value };\n      },\n\n      /**\n       * Called on early exit (e.g., break from for-await).\n       * Ensures the stream is cancelled and resources are released.\n       * @returns A promise resolving to a completed IteratorResult.\n       */\n      async return(): Promise<IteratorResult<T>> {\n        await cleanup(true);\n        return { done: true, value: undefined };\n      },\n\n      /**\n       * Called on early exit with error.\n       * Ensures the stream is cancelled and resources are released, then rethrows the error.\n       * @param err The error to throw.\n       * @returns A promise that rejects with the provided error.\n       */\n      async throw(err: unknown): Promise<IteratorResult<T>> {\n        await cleanup(true);\n        throw err;\n      },\n    };\n  };\n\n  return stream as AsyncIterableStream<T>;\n}\n","/**\n * Consumes a ReadableStream until it's fully read.\n *\n * This function reads the stream chunk by chunk until the stream is exhausted.\n * It doesn't process or return the data from the stream; it simply ensures\n * that the entire stream is read.\n *\n * @param {ReadableStream} stream - The ReadableStream to be consumed.\n * @returns {Promise<void>} A promise that resolves when the stream is fully consumed.\n */\nexport async function consumeStream({\n  stream,\n  onError,\n}: {\n  stream: ReadableStream;\n  onError?: (error: unknown) => void;\n}): Promise<void> {\n  const reader = stream.getReader();\n  try {\n    while (true) {\n      const { done } = await reader.read();\n      if (done) break;\n    }\n  } catch (error) {\n    onError?.(error);\n  } finally {\n    reader.releaseLock();\n  }\n}\n","import { ErrorHandler } from './error-handler';\n\n/**\n * Creates a Promise with externally accessible resolve and reject functions.\n *\n * @template T - The type of the value that the Promise will resolve to.\n * @returns An object containing:\n *   - promise: A Promise that can be resolved or rejected externally.\n *   - resolve: A function to resolve the Promise with a value of type T.\n *   - reject: A function to reject the Promise with an error.\n */\nexport function createResolvablePromise<T = any>(): {\n  promise: Promise<T>;\n  resolve: (value: T) => void;\n  reject: ErrorHandler;\n} {\n  let resolve: (value: T) => void;\n  let reject: ErrorHandler;\n\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n\n  return {\n    promise,\n    resolve: resolve!,\n    reject: reject!,\n  };\n}\n","import { createResolvablePromise } from './create-resolvable-promise';\n\n/**\n * Creates a stitchable stream that can pipe one stream at a time.\n *\n * @template T - The type of values emitted by the streams.\n * @returns {Object} An object containing the stitchable stream and control methods.\n */\nexport function createStitchableStream<T>(): {\n  stream: ReadableStream<T>;\n  addStream: (innerStream: ReadableStream<T>) => void;\n  close: () => void;\n  terminate: () => void;\n} {\n  let innerStreamReaders: ReadableStreamDefaultReader<T>[] = [];\n  let controller: ReadableStreamDefaultController<T> | null = null;\n  let isClosed = false;\n  let waitForNewStream = createResolvablePromise<void>();\n\n  const terminate = () => {\n    isClosed = true;\n    waitForNewStream.resolve();\n\n    innerStreamReaders.forEach(reader => reader.cancel());\n    innerStreamReaders = [];\n    controller?.close();\n  };\n\n  const processPull = async () => {\n    // Case 1: Outer stream is closed and no more inner streams\n    if (isClosed && innerStreamReaders.length === 0) {\n      controller?.close();\n      return;\n    }\n\n    // Case 2: No inner streams available, but outer stream is open\n    // wait for a new inner stream to be added or the outer stream to close\n    if (innerStreamReaders.length === 0) {\n      waitForNewStream = createResolvablePromise<void>();\n      await waitForNewStream.promise;\n      return processPull();\n    }\n\n    try {\n      const { value, done } = await innerStreamReaders[0].read();\n\n      if (done) {\n        // Case 3: Current inner stream is done\n        innerStreamReaders.shift(); // Remove the finished stream\n\n        if (innerStreamReaders.length === 0 && isClosed) {\n          // when closed and no more inner streams, stop pulling\n          controller?.close();\n        } else {\n          // continue pulling from the next stream\n          await processPull();\n        }\n      } else {\n        // Case 4: Current inner stream returns an item\n        controller?.enqueue(value);\n      }\n    } catch (error) {\n      // Case 5: Current inner stream throws an error\n      controller?.error(error);\n      innerStreamReaders.shift(); // Remove the errored stream\n      terminate(); // we have errored, terminate all streams\n    }\n  };\n\n  return {\n    stream: new ReadableStream<T>({\n      start(controllerParam) {\n        controller = controllerParam;\n      },\n      pull: processPull,\n      async cancel() {\n        for (const reader of innerStreamReaders) {\n          await reader.cancel();\n        }\n        innerStreamReaders = [];\n        isClosed = true;\n      },\n    }),\n    addStream: (innerStream: ReadableStream<T>) => {\n      if (isClosed) {\n        throw new Error('Cannot add inner stream: outer stream is closed');\n      }\n\n      innerStreamReaders.push(innerStream.getReader());\n      waitForNewStream.resolve();\n    },\n\n    /**\n     * Gracefully close the outer stream. This will let the inner streams\n     * finish processing and then close the outer stream.\n     */\n    close: () => {\n      isClosed = true;\n      waitForNewStream.resolve();\n\n      if (innerStreamReaders.length === 0) {\n        controller?.close();\n      }\n    },\n\n    /**\n     * Immediately close the outer stream. This will cancel all inner streams\n     * and close the outer stream.\n     */\n    terminate,\n  };\n}\n","// Shim for performance.now() to support environments that don't have it:\nexport function now(): number {\n  return globalThis?.performance?.now() ?? Date.now();\n}\n","import { LanguageModelV3StreamPart, SharedV3Warning } from '@ai-sdk/provider';\nimport {\n  getErrorMessage,\n  IdGenerator,\n  ModelMessage,\n  SystemModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { Tracer } from '@opentelemetry/api';\nimport { ToolCallNotFoundForApprovalError } from '../error/tool-call-not-found-for-approval-error';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { FinishReason, LanguageModelUsage, ProviderMetadata } from '../types';\nimport { Source } from '../types/language-model';\nimport { asLanguageModelUsage } from '../types/usage';\nimport { executeToolCall } from './execute-tool-call';\nimport { DefaultGeneratedFileWithType, GeneratedFile } from './generated-file';\nimport { isApprovalNeeded } from './is-approval-needed';\nimport { parseToolCall } from './parse-tool-call';\nimport { ToolApprovalRequestOutput } from './tool-approval-request-output';\nimport { TypedToolCall } from './tool-call';\nimport { ToolCallRepairFunction } from './tool-call-repair-function';\nimport { TypedToolError } from './tool-error';\nimport { TypedToolResult } from './tool-result';\nimport { ToolSet } from './tool-set';\n\nexport type SingleRequestTextStreamPart<TOOLS extends ToolSet> =\n  // Text blocks:\n  | {\n      type: 'text-start';\n      providerMetadata?: ProviderMetadata;\n      id: string;\n    }\n  | {\n      type: 'text-delta';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n      delta: string;\n    }\n  | {\n      type: 'text-end';\n      providerMetadata?: ProviderMetadata;\n      id: string;\n    }\n\n  // Reasoning blocks:\n  | {\n      type: 'reasoning-start';\n      providerMetadata?: ProviderMetadata;\n      id: string;\n    }\n  | {\n      type: 'reasoning-delta';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n      delta: string;\n    }\n  | {\n      type: 'reasoning-end';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n\n  // Tool calls:\n  | {\n      type: 'tool-input-start';\n      id: string;\n      toolName: string;\n      providerMetadata?: ProviderMetadata;\n      dynamic?: boolean;\n      title?: string;\n    }\n  | {\n      type: 'tool-input-delta';\n      id: string;\n      delta: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | {\n      type: 'tool-input-end';\n      id: string;\n      providerMetadata?: ProviderMetadata;\n    }\n  | ToolApprovalRequestOutput<TOOLS>\n\n  // Other types:\n  | ({ type: 'source' } & Source)\n  | { type: 'file'; file: GeneratedFile } // different because of GeneratedFile object\n  | ({ type: 'tool-call' } & TypedToolCall<TOOLS>)\n  | ({ type: 'tool-result' } & TypedToolResult<TOOLS>)\n  | ({ type: 'tool-error' } & TypedToolError<TOOLS>)\n  | { type: 'file'; file: GeneratedFile } // different because of GeneratedFile object\n  | { type: 'stream-start'; warnings: SharedV3Warning[] }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: FinishReason;\n      rawFinishReason: string | undefined;\n      usage: LanguageModelUsage;\n      providerMetadata?: ProviderMetadata;\n    }\n  | { type: 'error'; error: unknown }\n  | { type: 'raw'; rawValue: unknown };\n\nexport function runToolsTransformation<TOOLS extends ToolSet>({\n  tools,\n  generatorStream,\n  tracer,\n  telemetry,\n  system,\n  messages,\n  abortSignal,\n  repairToolCall,\n  experimental_context,\n  generateId,\n}: {\n  tools: TOOLS | undefined;\n  generatorStream: ReadableStream<LanguageModelV3StreamPart>;\n  tracer: Tracer;\n  telemetry: TelemetrySettings | undefined;\n  system: string | SystemModelMessage | Array<SystemModelMessage> | undefined;\n  messages: ModelMessage[];\n  abortSignal: AbortSignal | undefined;\n  repairToolCall: ToolCallRepairFunction<TOOLS> | undefined;\n  experimental_context: unknown;\n  generateId: IdGenerator;\n}): ReadableStream<SingleRequestTextStreamPart<TOOLS>> {\n  // tool results stream\n  let toolResultsStreamController: ReadableStreamDefaultController<\n    SingleRequestTextStreamPart<TOOLS>\n  > | null = null;\n  const toolResultsStream = new ReadableStream<\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    start(controller) {\n      toolResultsStreamController = controller;\n    },\n  });\n\n  // keep track of outstanding tool results for stream closing:\n  const outstandingToolResults = new Set<string>();\n\n  // keep track of tool inputs for provider-side tool results\n  const toolInputs = new Map<string, unknown>();\n\n  // keep track of parsed tool calls so provider-emitted approval requests can reference them\n  const toolCallsByToolCallId = new Map<string, TypedToolCall<TOOLS>>();\n\n  let canClose = false;\n  let finishChunk:\n    | (SingleRequestTextStreamPart<TOOLS> & { type: 'finish' })\n    | undefined = undefined;\n\n  function attemptClose() {\n    // close the tool results controller if no more outstanding tool calls\n    if (canClose && outstandingToolResults.size === 0) {\n      // we delay sending the finish chunk until all tool results (incl. delayed ones)\n      // are received to ensure that the frontend receives tool results before a message\n      // finish event arrives.\n      if (finishChunk != null) {\n        toolResultsStreamController!.enqueue(finishChunk);\n      }\n\n      toolResultsStreamController!.close();\n    }\n  }\n\n  // forward stream\n  const forwardStream = new TransformStream<\n    LanguageModelV3StreamPart,\n    SingleRequestTextStreamPart<TOOLS>\n  >({\n    async transform(\n      chunk: LanguageModelV3StreamPart,\n      controller: TransformStreamDefaultController<\n        SingleRequestTextStreamPart<TOOLS>\n      >,\n    ) {\n      const chunkType = chunk.type;\n\n      switch (chunkType) {\n        // forward:\n        case 'stream-start':\n        case 'text-start':\n        case 'text-delta':\n        case 'text-end':\n        case 'reasoning-start':\n        case 'reasoning-delta':\n        case 'reasoning-end':\n        case 'tool-input-start':\n        case 'tool-input-delta':\n        case 'tool-input-end':\n        case 'source':\n        case 'response-metadata':\n        case 'error':\n        case 'raw': {\n          controller.enqueue(chunk);\n          break;\n        }\n\n        case 'file': {\n          controller.enqueue({\n            type: 'file',\n            file: new DefaultGeneratedFileWithType({\n              data: chunk.data,\n              mediaType: chunk.mediaType,\n            }),\n          });\n          break;\n        }\n\n        case 'finish': {\n          finishChunk = {\n            type: 'finish',\n            finishReason: chunk.finishReason.unified,\n            rawFinishReason: chunk.finishReason.raw,\n            usage: asLanguageModelUsage(chunk.usage),\n            providerMetadata: chunk.providerMetadata,\n          };\n          break;\n        }\n\n        case 'tool-approval-request': {\n          const toolCall = toolCallsByToolCallId.get(chunk.toolCallId);\n          if (toolCall == null) {\n            toolResultsStreamController!.enqueue({\n              type: 'error',\n              error: new ToolCallNotFoundForApprovalError({\n                toolCallId: chunk.toolCallId,\n                approvalId: chunk.approvalId,\n              }),\n            });\n            break;\n          }\n\n          controller.enqueue({\n            type: 'tool-approval-request',\n            approvalId: chunk.approvalId,\n            toolCall,\n          });\n          break;\n        }\n\n        // process tool call:\n        case 'tool-call': {\n          try {\n            const toolCall = await parseToolCall({\n              toolCall: chunk,\n              tools,\n              repairToolCall,\n              system,\n              messages,\n            });\n\n            toolCallsByToolCallId.set(toolCall.toolCallId, toolCall);\n            controller.enqueue(toolCall);\n\n            if (toolCall.invalid) {\n              toolResultsStreamController!.enqueue({\n                type: 'tool-error',\n                toolCallId: toolCall.toolCallId,\n                toolName: toolCall.toolName,\n                input: toolCall.input,\n                error: getErrorMessage(toolCall.error!),\n                dynamic: true,\n                title: toolCall.title,\n              });\n              break;\n            }\n\n            const tool = tools?.[toolCall.toolName];\n\n            if (tool == null) {\n              // ignore tool calls for tools that are not available,\n              // e.g. provider-executed dynamic tools\n              break;\n            }\n\n            if (tool.onInputAvailable != null) {\n              await tool.onInputAvailable({\n                input: toolCall.input,\n                toolCallId: toolCall.toolCallId,\n                messages,\n                abortSignal,\n                experimental_context,\n              });\n            }\n\n            if (\n              await isApprovalNeeded({\n                tool,\n                toolCall,\n                messages,\n                experimental_context,\n              })\n            ) {\n              toolResultsStreamController!.enqueue({\n                type: 'tool-approval-request',\n                approvalId: generateId(),\n                toolCall,\n              });\n              break;\n            }\n\n            toolInputs.set(toolCall.toolCallId, toolCall.input);\n\n            // Only execute tools that are not provider-executed:\n            if (tool.execute != null && toolCall.providerExecuted !== true) {\n              const toolExecutionId = generateId(); // use our own id to guarantee uniqueness\n              outstandingToolResults.add(toolExecutionId);\n\n              // Note: we don't await the tool execution here (by leaving out 'await' on recordSpan),\n              // because we want to process the next chunk as soon as possible.\n              // This is important for the case where the tool execution takes a long time.\n              executeToolCall({\n                toolCall,\n                tools,\n                tracer,\n                telemetry,\n                messages,\n                abortSignal,\n                experimental_context,\n                onPreliminaryToolResult: result => {\n                  toolResultsStreamController!.enqueue(result);\n                },\n              }).then(result => {\n                toolResultsStreamController!.enqueue(result);\n                outstandingToolResults.delete(toolExecutionId);\n                attemptClose();\n              });\n            }\n          } catch (error) {\n            toolResultsStreamController!.enqueue({ type: 'error', error });\n          }\n\n          break;\n        }\n\n        case 'tool-result': {\n          const toolName = chunk.toolName as keyof TOOLS & string;\n\n          if (chunk.isError) {\n            toolResultsStreamController!.enqueue({\n              type: 'tool-error',\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              providerExecuted: true,\n              error: chunk.result,\n              dynamic: chunk.dynamic,\n            } as TypedToolError<TOOLS>);\n          } else {\n            controller.enqueue({\n              type: 'tool-result',\n              toolCallId: chunk.toolCallId,\n              toolName,\n              input: toolInputs.get(chunk.toolCallId),\n              output: chunk.result,\n              providerExecuted: true,\n              dynamic: chunk.dynamic,\n            } as TypedToolResult<TOOLS>);\n          }\n          break;\n        }\n\n        default: {\n          const _exhaustiveCheck: never = chunkType;\n          throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n        }\n      }\n    },\n\n    flush() {\n      canClose = true;\n      attemptClose();\n    },\n  });\n\n  // combine the generator stream and the tool results stream\n  return new ReadableStream<SingleRequestTextStreamPart<TOOLS>>({\n    async start(controller) {\n      // need to wait for both pipes so there are no dangling promises that\n      // can cause uncaught promise rejections when the stream is aborted\n      return Promise.all([\n        generatorStream.pipeThrough(forwardStream).pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              // the generator stream controller is automatically closed when it's consumed\n            },\n          }),\n        ),\n        toolResultsStream.pipeTo(\n          new WritableStream({\n            write(chunk) {\n              controller.enqueue(chunk);\n            },\n            close() {\n              controller.close();\n            },\n          }),\n        ),\n      ]);\n    },\n  });\n}\n","import { generateText } from '../generate-text/generate-text';\nimport { GenerateTextResult } from '../generate-text/generate-text-result';\nimport { Output } from '../generate-text/output';\nimport { stepCountIs } from '../generate-text/stop-condition';\nimport { streamText } from '../generate-text/stream-text';\nimport { StreamTextResult } from '../generate-text/stream-text-result';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { Prompt } from '../prompt';\nimport { Agent, AgentCallParameters, AgentStreamParameters } from './agent';\nimport { ToolLoopAgentSettings } from './tool-loop-agent-settings';\n\n/**\n * A tool loop agent is an agent that runs tools in a loop. In each step,\n * it calls the LLM, and if there are tool calls, it executes the tools\n * and calls the LLM again in a new step with the tool results.\n *\n * The loop continues until:\n * - A finish reasoning other than tool-calls is returned, or\n * - A tool that is invoked does not have an execute function, or\n * - A tool call needs approval, or\n * - A stop condition is met (default stop condition is stepCountIs(20))\n */\nexport class ToolLoopAgent<\n  CALL_OPTIONS = never,\n  TOOLS extends ToolSet = {},\n  OUTPUT extends Output = never,\n> implements Agent<CALL_OPTIONS, TOOLS, OUTPUT>\n{\n  readonly version = 'agent-v1';\n\n  private readonly settings: ToolLoopAgentSettings<CALL_OPTIONS, TOOLS, OUTPUT>;\n\n  constructor(settings: ToolLoopAgentSettings<CALL_OPTIONS, TOOLS, OUTPUT>) {\n    this.settings = settings;\n  }\n\n  /**\n   * The id of the agent.\n   */\n  get id(): string | undefined {\n    return this.settings.id;\n  }\n\n  /**\n   * The tools that the agent can use.\n   */\n  get tools(): TOOLS {\n    return this.settings.tools as TOOLS;\n  }\n\n  private async prepareCall(\n    options: AgentCallParameters<CALL_OPTIONS>,\n  ): Promise<\n    Omit<\n      ToolLoopAgentSettings<CALL_OPTIONS, TOOLS, OUTPUT>,\n      'prepareCall' | 'instructions'\n    > &\n      Prompt\n  > {\n    const baseCallArgs = {\n      ...this.settings,\n      stopWhen: this.settings.stopWhen ?? stepCountIs(20),\n      ...options,\n    };\n\n    const preparedCallArgs =\n      (await this.settings.prepareCall?.(baseCallArgs)) ?? baseCallArgs;\n\n    const { instructions, messages, prompt, ...callArgs } = preparedCallArgs;\n\n    return {\n      ...callArgs,\n\n      // restore prompt types\n      ...({ system: instructions, messages, prompt } as Prompt),\n    };\n  }\n\n  /**\n   * Generates an output from the agent (non-streaming).\n   */\n  async generate({\n    abortSignal,\n    ...options\n  }: AgentCallParameters<CALL_OPTIONS>): Promise<\n    GenerateTextResult<TOOLS, OUTPUT>\n  > {\n    return generateText({\n      ...(await this.prepareCall(options)),\n      abortSignal,\n    });\n  }\n\n  /**\n   * Streams an output from the agent (streaming).\n   */\n  async stream({\n    abortSignal,\n    experimental_transform,\n    ...options\n  }: AgentStreamParameters<CALL_OPTIONS, TOOLS>): Promise<\n    StreamTextResult<TOOLS, OUTPUT>\n  > {\n    return streamText({\n      ...(await this.prepareCall(options)),\n      abortSignal,\n      experimental_transform,\n    });\n  }\n}\n","import {\n  generateId as generateIdFunc,\n  getErrorMessage,\n  IdGenerator,\n} from '@ai-sdk/provider-utils';\nimport { UIMessage } from '../ui/ui-messages';\nimport { handleUIMessageStreamFinish } from './handle-ui-message-stream-finish';\nimport { InferUIMessageChunk } from './ui-message-chunks';\nimport { UIMessageStreamOnFinishCallback } from './ui-message-stream-on-finish-callback';\nimport { UIMessageStreamWriter } from './ui-message-stream-writer';\n\nexport function createUIMessageStream<UI_MESSAGE extends UIMessage>({\n  execute,\n  onError = getErrorMessage,\n  originalMessages,\n  onFinish,\n  generateId = generateIdFunc,\n}: {\n  execute: (options: {\n    writer: UIMessageStreamWriter<UI_MESSAGE>;\n  }) => Promise<void> | void;\n  onError?: (error: unknown) => string;\n\n  /**\n   * The original messages. If they are provided, persistence mode is assumed,\n   * and a message ID is provided for the response message.\n   */\n  originalMessages?: UI_MESSAGE[];\n\n  onFinish?: UIMessageStreamOnFinishCallback<UI_MESSAGE>;\n\n  generateId?: IdGenerator;\n}): ReadableStream<InferUIMessageChunk<UI_MESSAGE>> {\n  let controller!: ReadableStreamDefaultController<\n    InferUIMessageChunk<UI_MESSAGE>\n  >;\n\n  const ongoingStreamPromises: Promise<void>[] = [];\n\n  const stream = new ReadableStream({\n    start(controllerArg) {\n      controller = controllerArg;\n    },\n  });\n\n  function safeEnqueue(data: InferUIMessageChunk<UI_MESSAGE>) {\n    try {\n      controller.enqueue(data);\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  }\n\n  try {\n    const result = execute({\n      writer: {\n        write(part: InferUIMessageChunk<UI_MESSAGE>) {\n          safeEnqueue(part);\n        },\n        merge(streamArg) {\n          ongoingStreamPromises.push(\n            (async () => {\n              const reader = streamArg.getReader();\n              while (true) {\n                const { done, value } = await reader.read();\n                if (done) break;\n                safeEnqueue(value);\n              }\n            })().catch(error => {\n              safeEnqueue({\n                type: 'error',\n                errorText: onError(error),\n              } as InferUIMessageChunk<UI_MESSAGE>);\n            }),\n          );\n        },\n        onError,\n      },\n    });\n\n    if (result) {\n      ongoingStreamPromises.push(\n        result.catch(error => {\n          safeEnqueue({\n            type: 'error',\n            errorText: onError(error),\n          } as InferUIMessageChunk<UI_MESSAGE>);\n        }),\n      );\n    }\n  } catch (error) {\n    safeEnqueue({\n      type: 'error',\n      errorText: onError(error),\n    } as InferUIMessageChunk<UI_MESSAGE>);\n  }\n\n  // Wait until all ongoing streams are done. This approach enables merging\n  // streams even after execute has returned, as long as there is still an\n  // open merged stream. This is important to e.g. forward new streams and\n  // from callbacks.\n  const waitForStreams: Promise<void> = new Promise(async resolve => {\n    while (ongoingStreamPromises.length > 0) {\n      await ongoingStreamPromises.shift();\n    }\n    resolve();\n  });\n\n  waitForStreams.finally(() => {\n    try {\n      controller.close();\n    } catch (error) {\n      // suppress errors when the stream has been closed\n    }\n  });\n\n  return handleUIMessageStreamFinish<UI_MESSAGE>({\n    stream,\n    messageId: generateId(),\n    originalMessages,\n    onFinish,\n    onError,\n  });\n}\n","import { UIMessage } from '../ui/ui-messages';\nimport { UIMessageChunk } from './ui-message-chunks';\nimport {\n  createStreamingUIMessageState,\n  processUIMessageStream,\n  StreamingUIMessageState,\n} from '../ui/process-ui-message-stream';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { consumeStream } from '../util/consume-stream';\n\n/**\n * Transforms a stream of `UIMessageChunk`s into an `AsyncIterableStream` of `UIMessage`s.\n *\n * @param options.message - The last assistant message to use as a starting point when the conversation is resumed. Otherwise undefined.\n * @param options.stream - The stream of `UIMessageChunk`s to read.\n * @param options.terminateOnError - Whether to terminate the stream if an error occurs.\n * @param options.onError - A function that is called when an error occurs.\n *\n * @returns An `AsyncIterableStream` of `UIMessage`s. Each stream part is a different state of the same message\n * as it is being completed.\n */\nexport function readUIMessageStream<UI_MESSAGE extends UIMessage>({\n  message,\n  stream,\n  onError,\n  terminateOnError = false,\n}: {\n  message?: UI_MESSAGE;\n  stream: ReadableStream<UIMessageChunk>;\n  onError?: (error: unknown) => void;\n  terminateOnError?: boolean;\n}): AsyncIterableStream<UI_MESSAGE> {\n  let controller: ReadableStreamDefaultController<UI_MESSAGE> | undefined;\n  let hasErrored = false;\n\n  const outputStream = new ReadableStream<UI_MESSAGE>({\n    start(controllerParam) {\n      controller = controllerParam;\n    },\n  });\n\n  const state = createStreamingUIMessageState<UI_MESSAGE>({\n    messageId: message?.id ?? '',\n    lastMessage: message,\n  });\n\n  const handleError = (error: unknown) => {\n    onError?.(error);\n\n    if (!hasErrored && terminateOnError) {\n      hasErrored = true;\n      controller?.error(error);\n    }\n  };\n\n  consumeStream({\n    stream: processUIMessageStream({\n      stream,\n      runUpdateMessageJob(\n        job: (options: {\n          state: StreamingUIMessageState<UI_MESSAGE>;\n          write: () => void;\n        }) => Promise<void>,\n      ) {\n        return job({\n          state,\n          write: () => {\n            controller?.enqueue(structuredClone(state.message));\n          },\n        });\n      },\n      onError: handleError,\n    }),\n    onError: handleError,\n  }).finally(() => {\n    // Only close if no error occurred. Calling close() on an errored controller\n    // throws \"Invalid state: Controller is already closed\" TypeError.\n    if (!hasErrored) {\n      controller?.close();\n    }\n  });\n\n  return createAsyncIterableStream(outputStream);\n}\n","import {\n  AssistantContent,\n  FilePart,\n  isNonNullable,\n  ModelMessage,\n  TextPart,\n  ToolApprovalResponse,\n  ToolResultPart,\n} from '@ai-sdk/provider-utils';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { createToolModelOutput } from '../prompt/create-tool-model-output';\nimport { MessageConversionError } from '../prompt/message-conversion-error';\nimport {\n  DataUIPart,\n  DynamicToolUIPart,\n  FileUIPart,\n  getToolName,\n  InferUIMessageData,\n  InferUIMessageTools,\n  isDataUIPart,\n  isFileUIPart,\n  isReasoningUIPart,\n  isTextUIPart,\n  isToolUIPart,\n  ReasoningUIPart,\n  TextUIPart,\n  ToolUIPart,\n  UIMessage,\n} from './ui-messages';\n\n/**\nConverts an array of UI messages from useChat into an array of ModelMessages that can be used\nwith the AI functions (e.g. `streamText`, `generateText`).\n\n@param messages - The UI messages to convert.\n@param options.tools - The tools to use.\n@param options.ignoreIncompleteToolCalls - Whether to ignore incomplete tool calls. Default is `false`.\n@param options.convertDataPart - Optional function to convert data parts to text or file model message parts. Returns `undefined` if the part should be ignored.\n\n@returns An array of ModelMessages.\n */\nexport async function convertToModelMessages<UI_MESSAGE extends UIMessage>(\n  messages: Array<Omit<UI_MESSAGE, 'id'>>,\n  options?: {\n    tools?: ToolSet;\n    ignoreIncompleteToolCalls?: boolean;\n    convertDataPart?: (\n      part: DataUIPart<InferUIMessageData<UI_MESSAGE>>,\n    ) => TextPart | FilePart | undefined;\n  },\n): Promise<ModelMessage[]> {\n  const modelMessages: ModelMessage[] = [];\n\n  if (options?.ignoreIncompleteToolCalls) {\n    messages = messages.map(message => ({\n      ...message,\n      parts: message.parts.filter(\n        part =>\n          !isToolUIPart(part) ||\n          (part.state !== 'input-streaming' &&\n            part.state !== 'input-available'),\n      ),\n    }));\n  }\n\n  for (const message of messages) {\n    switch (message.role) {\n      case 'system': {\n        const textParts = message.parts.filter(\n          (part): part is TextUIPart => part.type === 'text',\n        );\n\n        const providerMetadata = textParts.reduce((acc, part) => {\n          if (part.providerMetadata != null) {\n            return { ...acc, ...part.providerMetadata };\n          }\n          return acc;\n        }, {});\n\n        modelMessages.push({\n          role: 'system',\n          content: textParts.map(part => part.text).join(''),\n          ...(Object.keys(providerMetadata).length > 0\n            ? { providerOptions: providerMetadata }\n            : {}),\n        });\n        break;\n      }\n\n      case 'user': {\n        modelMessages.push({\n          role: 'user',\n          content: message.parts\n            .map((part): TextPart | FilePart | undefined => {\n              // Process text parts\n              if (isTextUIPart(part)) {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  ...(part.providerMetadata != null\n                    ? { providerOptions: part.providerMetadata }\n                    : {}),\n                };\n              }\n\n              // Process file parts\n              if (isFileUIPart(part)) {\n                return {\n                  type: 'file' as const,\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url,\n                  ...(part.providerMetadata != null\n                    ? { providerOptions: part.providerMetadata }\n                    : {}),\n                };\n              }\n\n              // Process data parts with converter if provided\n              if (isDataUIPart(part)) {\n                return options?.convertDataPart?.(\n                  part as DataUIPart<InferUIMessageData<UI_MESSAGE>>,\n                );\n              }\n            })\n            .filter(isNonNullable),\n        });\n\n        break;\n      }\n\n      case 'assistant': {\n        if (message.parts != null) {\n          let block: Array<\n            | TextUIPart\n            | ToolUIPart<InferUIMessageTools<UI_MESSAGE>>\n            | ReasoningUIPart\n            | FileUIPart\n            | DynamicToolUIPart\n            | DataUIPart<InferUIMessageData<UI_MESSAGE>>\n          > = [];\n\n          async function processBlock() {\n            if (block.length === 0) {\n              return;\n            }\n\n            const content: AssistantContent = [];\n\n            for (const part of block) {\n              if (isTextUIPart(part)) {\n                content.push({\n                  type: 'text' as const,\n                  text: part.text,\n                  ...(part.providerMetadata != null\n                    ? { providerOptions: part.providerMetadata }\n                    : {}),\n                });\n              } else if (isFileUIPart(part)) {\n                content.push({\n                  type: 'file' as const,\n                  mediaType: part.mediaType,\n                  filename: part.filename,\n                  data: part.url,\n                });\n              } else if (isReasoningUIPart(part)) {\n                content.push({\n                  type: 'reasoning' as const,\n                  text: part.text,\n                  providerOptions: part.providerMetadata,\n                });\n              } else if (isToolUIPart(part)) {\n                const toolName = getToolName(part);\n\n                if (part.state !== 'input-streaming') {\n                  content.push({\n                    type: 'tool-call' as const,\n                    toolCallId: part.toolCallId,\n                    toolName,\n                    input:\n                      part.state === 'output-error'\n                        ? (part.input ??\n                          ('rawInput' in part ? part.rawInput : undefined))\n                        : part.input,\n                    providerExecuted: part.providerExecuted,\n                    ...(part.callProviderMetadata != null\n                      ? { providerOptions: part.callProviderMetadata }\n                      : {}),\n                  });\n\n                  if (part.approval != null) {\n                    content.push({\n                      type: 'tool-approval-request' as const,\n                      approvalId: part.approval.id,\n                      toolCallId: part.toolCallId,\n                    });\n                  }\n\n                  if (\n                    part.providerExecuted === true &&\n                    part.state !== 'approval-responded' &&\n                    (part.state === 'output-available' ||\n                      part.state === 'output-error')\n                  ) {\n                    content.push({\n                      type: 'tool-result',\n                      toolCallId: part.toolCallId,\n                      toolName,\n                      output: await createToolModelOutput({\n                        toolCallId: part.toolCallId,\n                        input: part.input,\n                        output:\n                          part.state === 'output-error'\n                            ? part.errorText\n                            : part.output,\n                        tool: options?.tools?.[toolName],\n                        errorMode:\n                          part.state === 'output-error' ? 'json' : 'none',\n                      }),\n                      ...(part.callProviderMetadata != null\n                        ? { providerOptions: part.callProviderMetadata }\n                        : {}),\n                    });\n                  }\n                }\n              } else if (isDataUIPart(part)) {\n                const dataPart = options?.convertDataPart?.(\n                  part as DataUIPart<InferUIMessageData<UI_MESSAGE>>,\n                );\n\n                if (dataPart != null) {\n                  content.push(dataPart);\n                }\n              } else {\n                const _exhaustiveCheck: never = part;\n                throw new Error(`Unsupported part: ${_exhaustiveCheck}`);\n              }\n            }\n\n            modelMessages.push({\n              role: 'assistant',\n              content,\n            });\n\n            // check if there are tool invocations with results in the block\n            // Include non-provider-executed tools, OR provider-executed tools with approval responses\n            const toolParts = block.filter(\n              part =>\n                isToolUIPart(part) &&\n                (part.providerExecuted !== true ||\n                  part.approval?.approved != null),\n            ) as (\n              | ToolUIPart<InferUIMessageTools<UI_MESSAGE>>\n              | DynamicToolUIPart\n            )[];\n\n            // tool message with tool results\n            if (toolParts.length > 0) {\n              {\n                const content: Array<ToolResultPart | ToolApprovalResponse> =\n                  [];\n                for (const toolPart of toolParts) {\n                  // add approval response for approved tool calls:\n                  if (toolPart.approval?.approved != null) {\n                    content.push({\n                      type: 'tool-approval-response' as const,\n                      approvalId: toolPart.approval.id,\n                      approved: toolPart.approval.approved,\n                      reason: toolPart.approval.reason,\n                      providerExecuted: toolPart.providerExecuted,\n                    });\n                  }\n\n                  // For provider-executed tools, the tool result is already in the\n                  // assistant content. Skip adding to tool message to avoid duplicates\n                  // (which would create orphaned function_call_output entries).\n                  if (toolPart.providerExecuted === true) {\n                    continue;\n                  }\n\n                  switch (toolPart.state) {\n                    case 'output-denied': {\n                      content.push({\n                        type: 'tool-result',\n                        toolCallId: toolPart.toolCallId,\n                        toolName: getToolName(toolPart),\n                        output: {\n                          type: 'error-text' as const,\n                          value:\n                            toolPart.approval.reason ??\n                            'Tool execution denied.',\n                        },\n                        ...(toolPart.callProviderMetadata != null\n                          ? { providerOptions: toolPart.callProviderMetadata }\n                          : {}),\n                      });\n                      break;\n                    }\n\n                    case 'output-error':\n                    case 'output-available': {\n                      const toolName = getToolName(toolPart);\n                      content.push({\n                        type: 'tool-result',\n                        toolCallId: toolPart.toolCallId,\n                        toolName,\n                        output: await createToolModelOutput({\n                          toolCallId: toolPart.toolCallId,\n                          input: toolPart.input,\n                          output:\n                            toolPart.state === 'output-error'\n                              ? toolPart.errorText\n                              : toolPart.output,\n                          tool: options?.tools?.[toolName],\n                          errorMode:\n                            toolPart.state === 'output-error' ? 'text' : 'none',\n                        }),\n                        ...(toolPart.callProviderMetadata != null\n                          ? { providerOptions: toolPart.callProviderMetadata }\n                          : {}),\n                      });\n                      break;\n                    }\n                  }\n                }\n\n                if (content.length > 0) {\n                  modelMessages.push({\n                    role: 'tool',\n                    content,\n                  });\n                }\n              }\n            }\n\n            // updates for next block\n            block = [];\n          }\n\n          for (const part of message.parts) {\n            if (\n              isTextUIPart(part) ||\n              isReasoningUIPart(part) ||\n              isFileUIPart(part) ||\n              isToolUIPart(part) ||\n              isDataUIPart(part)\n            ) {\n              block.push(part as (typeof block)[number]);\n            } else if (part.type === 'step-start') {\n              await processBlock();\n            }\n          }\n\n          await processBlock();\n\n          break;\n        }\n\n        break;\n      }\n\n      default: {\n        const _exhaustiveCheck: never = message.role;\n        throw new MessageConversionError({\n          originalMessage: message,\n          message: `Unsupported role: ${_exhaustiveCheck}`,\n        });\n      }\n    }\n  }\n\n  return modelMessages;\n}\n","import { TypeValidationError } from '@ai-sdk/provider';\nimport {\n  FlexibleSchema,\n  lazySchema,\n  StandardSchemaV1,\n  Tool,\n  validateTypes,\n  zodSchema,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { InvalidArgumentError } from '../error';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport {\n  DataUIPart,\n  InferUIMessageData,\n  InferUIMessageTools,\n  ToolUIPart,\n  UIMessage,\n} from './ui-messages';\n\nconst uiMessagesSchema = lazySchema(() =>\n  zodSchema(\n    z\n      .array(\n        z.object({\n          id: z.string(),\n          role: z.enum(['system', 'user', 'assistant']),\n          metadata: z.unknown().optional(),\n          parts: z\n            .array(\n              z.union([\n                z.object({\n                  type: z.literal('text'),\n                  text: z.string(),\n                  state: z.enum(['streaming', 'done']).optional(),\n                  providerMetadata: providerMetadataSchema.optional(),\n                }),\n                z.object({\n                  type: z.literal('reasoning'),\n                  text: z.string(),\n                  state: z.enum(['streaming', 'done']).optional(),\n                  providerMetadata: providerMetadataSchema.optional(),\n                }),\n                z.object({\n                  type: z.literal('source-url'),\n                  sourceId: z.string(),\n                  url: z.string(),\n                  title: z.string().optional(),\n                  providerMetadata: providerMetadataSchema.optional(),\n                }),\n                z.object({\n                  type: z.literal('source-document'),\n                  sourceId: z.string(),\n                  mediaType: z.string(),\n                  title: z.string(),\n                  filename: z.string().optional(),\n                  providerMetadata: providerMetadataSchema.optional(),\n                }),\n                z.object({\n                  type: z.literal('file'),\n                  mediaType: z.string(),\n                  filename: z.string().optional(),\n                  url: z.string(),\n                  providerMetadata: providerMetadataSchema.optional(),\n                }),\n                z.object({\n                  type: z.literal('step-start'),\n                }),\n                z.object({\n                  type: z.string().startsWith('data-'),\n                  id: z.string().optional(),\n                  data: z.unknown(),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('input-streaming'),\n                  input: z.unknown().optional(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  approval: z.never().optional(),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('input-available'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.never().optional(),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('approval-requested'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.never().optional(),\n                    reason: z.never().optional(),\n                  }),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('approval-responded'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.boolean(),\n                    reason: z.string().optional(),\n                  }),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('output-available'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.unknown(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  preliminary: z.boolean().optional(),\n                  approval: z\n                    .object({\n                      id: z.string(),\n                      approved: z.literal(true),\n                      reason: z.string().optional(),\n                    })\n                    .optional(),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('output-error'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.string(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z\n                    .object({\n                      id: z.string(),\n                      approved: z.literal(true),\n                      reason: z.string().optional(),\n                    })\n                    .optional(),\n                }),\n                z.object({\n                  type: z.literal('dynamic-tool'),\n                  toolName: z.string(),\n                  toolCallId: z.string(),\n                  state: z.literal('output-denied'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.literal(false),\n                    reason: z.string().optional(),\n                  }),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('input-streaming'),\n                  providerExecuted: z.boolean().optional(),\n                  input: z.unknown().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  approval: z.never().optional(),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('input-available'),\n                  providerExecuted: z.boolean().optional(),\n                  input: z.unknown(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.never().optional(),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('approval-requested'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.never().optional(),\n                    reason: z.never().optional(),\n                  }),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('approval-responded'),\n                  input: z.unknown(),\n                  providerExecuted: z.boolean().optional(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.boolean(),\n                    reason: z.string().optional(),\n                  }),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('output-available'),\n                  providerExecuted: z.boolean().optional(),\n                  input: z.unknown(),\n                  output: z.unknown(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  preliminary: z.boolean().optional(),\n                  approval: z\n                    .object({\n                      id: z.string(),\n                      approved: z.literal(true),\n                      reason: z.string().optional(),\n                    })\n                    .optional(),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('output-error'),\n                  providerExecuted: z.boolean().optional(),\n                  input: z.unknown(),\n                  output: z.never().optional(),\n                  errorText: z.string(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z\n                    .object({\n                      id: z.string(),\n                      approved: z.literal(true),\n                      reason: z.string().optional(),\n                    })\n                    .optional(),\n                }),\n                z.object({\n                  type: z.string().startsWith('tool-'),\n                  toolCallId: z.string(),\n                  state: z.literal('output-denied'),\n                  providerExecuted: z.boolean().optional(),\n                  input: z.unknown(),\n                  output: z.never().optional(),\n                  errorText: z.never().optional(),\n                  callProviderMetadata: providerMetadataSchema.optional(),\n                  approval: z.object({\n                    id: z.string(),\n                    approved: z.literal(false),\n                    reason: z.string().optional(),\n                  }),\n                }),\n              ]),\n            )\n            .nonempty('Message must contain at least one part'),\n        }),\n      )\n      .nonempty('Messages array must not be empty'),\n  ),\n);\n\nexport type SafeValidateUIMessagesResult<UI_MESSAGE extends UIMessage> =\n  | {\n      success: true;\n      data: Array<UI_MESSAGE>;\n    }\n  | {\n      success: false;\n      error: Error;\n    };\n\n/**\n * Validates a list of UI messages like `validateUIMessages`,\n * but instead of throwing it returns `{ success: true, data }`\n * or `{ success: false, error }`.\n */\nexport async function safeValidateUIMessages<UI_MESSAGE extends UIMessage>({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools,\n}: {\n  messages: unknown;\n  metadataSchema?: FlexibleSchema<UIMessage['metadata']>;\n  dataSchemas?: {\n    [NAME in keyof InferUIMessageData<UI_MESSAGE> & string]?: FlexibleSchema<\n      InferUIMessageData<UI_MESSAGE>[NAME]\n    >;\n  };\n  tools?: {\n    [NAME in keyof InferUIMessageTools<UI_MESSAGE> & string]?: Tool<\n      InferUIMessageTools<UI_MESSAGE>[NAME]['input'],\n      InferUIMessageTools<UI_MESSAGE>[NAME]['output']\n    >;\n  };\n}): Promise<SafeValidateUIMessagesResult<UI_MESSAGE>> {\n  try {\n    if (messages == null) {\n      return {\n        success: false,\n        error: new InvalidArgumentError({\n          parameter: 'messages',\n          value: messages,\n          message: 'messages parameter must be provided',\n        }),\n      };\n    }\n\n    const validatedMessages = await validateTypes({\n      value: messages,\n      schema: uiMessagesSchema,\n    });\n\n    if (metadataSchema) {\n      for (const message of validatedMessages) {\n        await validateTypes({\n          value: message.metadata,\n          schema: metadataSchema,\n        });\n      }\n    }\n\n    if (dataSchemas) {\n      for (const message of validatedMessages) {\n        const dataParts = message.parts.filter(part =>\n          part.type.startsWith('data-'),\n        ) as DataUIPart<InferUIMessageData<UI_MESSAGE>>[];\n\n        for (const dataPart of dataParts) {\n          const dataName = dataPart.type.slice(5);\n          const dataSchema = dataSchemas[dataName];\n\n          if (!dataSchema) {\n            return {\n              success: false,\n              error: new TypeValidationError({\n                value: dataPart.data,\n                cause: `No data schema found for data part ${dataName}`,\n              }),\n            };\n          }\n\n          await validateTypes({\n            value: dataPart.data,\n            schema: dataSchema,\n          });\n        }\n      }\n    }\n\n    if (tools) {\n      for (const message of validatedMessages) {\n        const toolParts = message.parts.filter(part =>\n          part.type.startsWith('tool-'),\n        ) as ToolUIPart<InferUIMessageTools<UI_MESSAGE>>[];\n\n        for (const toolPart of toolParts) {\n          const toolName = toolPart.type.slice(5);\n          const tool = tools[toolName];\n\n          // TODO support dynamic tools\n          if (!tool) {\n            return {\n              success: false,\n              error: new TypeValidationError({\n                value: toolPart.input,\n                cause: `No tool schema found for tool part ${toolName}`,\n              }),\n            };\n          }\n\n          if (\n            toolPart.state === 'input-available' ||\n            toolPart.state === 'output-available' ||\n            (toolPart.state === 'output-error' && toolPart.input !== undefined)\n          ) {\n            await validateTypes({\n              value: toolPart.input,\n              schema: tool.inputSchema,\n            });\n          }\n\n          if (toolPart.state === 'output-available' && tool.outputSchema) {\n            await validateTypes({\n              value: toolPart.output,\n              schema: tool.outputSchema,\n            });\n          }\n        }\n      }\n    }\n\n    return {\n      success: true,\n      data: validatedMessages as Array<UI_MESSAGE>,\n    };\n  } catch (error) {\n    const err = error as Error;\n\n    return {\n      success: false,\n      error: err,\n    };\n  }\n}\n\n/**\n * Validates a list of UI messages.\n *\n * Metadata, data parts, and generic tool call structures are only validated if\n * the corresponding schemas are provided. Otherwise, they are assumed to be\n * valid.\n */\nexport async function validateUIMessages<UI_MESSAGE extends UIMessage>({\n  messages,\n  metadataSchema,\n  dataSchemas,\n  tools,\n}: {\n  messages: unknown;\n  metadataSchema?: FlexibleSchema<UIMessage['metadata']>;\n  dataSchemas?: {\n    [NAME in keyof InferUIMessageData<UI_MESSAGE> & string]?: FlexibleSchema<\n      InferUIMessageData<UI_MESSAGE>[NAME]\n    >;\n  };\n  tools?: {\n    [NAME in keyof InferUIMessageTools<UI_MESSAGE> & string]?: Tool<\n      InferUIMessageTools<UI_MESSAGE>[NAME]['input'],\n      InferUIMessageTools<UI_MESSAGE>[NAME]['output']\n    >;\n  };\n}): Promise<Array<UI_MESSAGE>> {\n  const response = await safeValidateUIMessages({\n    messages,\n    metadataSchema,\n    dataSchemas,\n    tools,\n  });\n\n  if (!response.success) throw response.error;\n\n  return response.data;\n}\n","import { StreamTextTransform, UIMessageStreamOptions } from '../generate-text';\nimport { Output } from '../generate-text/output';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { InferUIMessageChunk } from '../ui-message-stream';\nimport { convertToModelMessages } from '../ui/convert-to-model-messages';\nimport { InferUITools, UIMessage } from '../ui/ui-messages';\nimport { validateUIMessages } from '../ui/validate-ui-messages';\nimport { AsyncIterableStream } from '../util/async-iterable-stream';\nimport { Agent } from './agent';\n\n/**\n * Runs the agent and stream the output as a UI message stream.\n *\n * @param agent - The agent to run.\n * @param uiMessages - The input UI messages.\n * @param abortSignal - The abort signal. Optional.\n * @param options - The options for the agent.\n * @param experimental_transform - The stream transformations. Optional.\n *\n * @returns The UI message stream.\n */\nexport async function createAgentUIStream<\n  CALL_OPTIONS = never,\n  TOOLS extends ToolSet = {},\n  OUTPUT extends Output = never,\n  MESSAGE_METADATA = unknown,\n>({\n  agent,\n  uiMessages,\n  options,\n  abortSignal,\n  experimental_transform,\n  ...uiMessageStreamOptions\n}: {\n  agent: Agent<CALL_OPTIONS, TOOLS, OUTPUT>;\n  uiMessages: unknown[];\n  abortSignal?: AbortSignal;\n  options?: CALL_OPTIONS;\n  experimental_transform?:\n    | StreamTextTransform<TOOLS>\n    | Array<StreamTextTransform<TOOLS>>;\n} & UIMessageStreamOptions<\n  UIMessage<MESSAGE_METADATA, never, InferUITools<TOOLS>>\n>): Promise<\n  AsyncIterableStream<\n    InferUIMessageChunk<UIMessage<MESSAGE_METADATA, never, InferUITools<TOOLS>>>\n  >\n> {\n  const validatedMessages = await validateUIMessages<\n    UIMessage<MESSAGE_METADATA, never, InferUITools<TOOLS>>\n  >({\n    messages: uiMessages,\n    tools: agent.tools,\n  });\n\n  const modelMessages = await convertToModelMessages(validatedMessages, {\n    tools: agent.tools,\n  });\n\n  const result = await agent.stream({\n    prompt: modelMessages,\n    options: options as CALL_OPTIONS,\n    abortSignal,\n    experimental_transform,\n  });\n\n  return result.toUIMessageStream(uiMessageStreamOptions);\n}\n","import { StreamTextTransform, UIMessageStreamOptions } from '../generate-text';\nimport { Output } from '../generate-text/output';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { createUIMessageStreamResponse } from '../ui-message-stream';\nimport { UIMessageStreamResponseInit } from '../ui-message-stream/ui-message-stream-response-init';\nimport { InferUITools, UIMessage } from '../ui/ui-messages';\nimport { Agent } from './agent';\nimport { createAgentUIStream } from './create-agent-ui-stream';\n\n/**\n * Runs the agent and returns a response object with a UI message stream.\n *\n * @param agent - The agent to run.\n * @param uiMessages - The input UI messages.\n *\n * @returns The response object.\n */\nexport async function createAgentUIStreamResponse<\n  CALL_OPTIONS = never,\n  TOOLS extends ToolSet = {},\n  OUTPUT extends Output = never,\n  MESSAGE_METADATA = unknown,\n>({\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}: {\n  agent: Agent<CALL_OPTIONS, TOOLS, OUTPUT>;\n  uiMessages: unknown[];\n  abortSignal?: AbortSignal;\n  options?: CALL_OPTIONS;\n  experimental_transform?:\n    | StreamTextTransform<TOOLS>\n    | Array<StreamTextTransform<TOOLS>>;\n} & UIMessageStreamResponseInit &\n  UIMessageStreamOptions<\n    UIMessage<MESSAGE_METADATA, never, InferUITools<TOOLS>>\n  >): Promise<Response> {\n  return createUIMessageStreamResponse({\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options),\n  });\n}\n","import { ServerResponse } from 'node:http';\nimport { StreamTextTransform, UIMessageStreamOptions } from '../generate-text';\nimport { Output } from '../generate-text/output';\nimport { ToolSet } from '../generate-text/tool-set';\nimport { pipeUIMessageStreamToResponse } from '../ui-message-stream';\nimport { UIMessageStreamResponseInit } from '../ui-message-stream/ui-message-stream-response-init';\nimport { InferUITools, UIMessage } from '../ui/ui-messages';\nimport { Agent } from './agent';\nimport { createAgentUIStream } from './create-agent-ui-stream';\n\n/**\n * Pipes the agent UI message stream to a Node.js ServerResponse object.\n *\n * @param agent - The agent to run.\n * @param uiMessages - The input UI messages.\n */\nexport async function pipeAgentUIStreamToResponse<\n  CALL_OPTIONS = never,\n  TOOLS extends ToolSet = {},\n  OUTPUT extends Output = never,\n  MESSAGE_METADATA = unknown,\n>({\n  response,\n  headers,\n  status,\n  statusText,\n  consumeSseStream,\n  ...options\n}: {\n  response: ServerResponse;\n  agent: Agent<CALL_OPTIONS, TOOLS, OUTPUT>;\n  uiMessages: unknown[];\n  abortSignal?: AbortSignal;\n  options?: CALL_OPTIONS;\n  experimental_transform?:\n    | StreamTextTransform<TOOLS>\n    | Array<StreamTextTransform<TOOLS>>;\n} & UIMessageStreamResponseInit &\n  UIMessageStreamOptions<\n    UIMessage<MESSAGE_METADATA, never, InferUITools<TOOLS>>\n  >): Promise<void> {\n  pipeUIMessageStreamToResponse({\n    response,\n    headers,\n    status,\n    statusText,\n    consumeSseStream,\n    stream: await createAgentUIStream(options),\n  });\n}\n","import { ProviderOptions, withUserAgentSuffix } from '@ai-sdk/provider-utils';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveEmbeddingModel } from '../model/resolve-model';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { EmbeddingModel } from '../types';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { EmbedResult } from './embed-result';\nimport { VERSION } from '../version';\n\n/**\nEmbed a value using an embedding model. The type of the value is defined by the embedding model.\n\n@param model - The embedding model to use.\n@param value - The value that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embedding, the value, and additional information.\n */\nexport async function embed({\n  model: modelArg,\n  value,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel;\n\n  /**\nThe value that should be embedded.\n   */\n  value: string;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n  Additional provider-specific options. They are passed through\n  to the provider from the AI SDK and enable provider-specific\n  functionality that can be fully encapsulated in the provider.\n  */\n  providerOptions?: ProviderOptions;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n}): Promise<EmbedResult> {\n  const model = resolveEmbeddingModel(modelArg);\n\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model: model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embed',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embed', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.value': { input: () => JSON.stringify(value) },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const { embedding, usage, warnings, response, providerMetadata } =\n        await retry(() =>\n          // nested spans to align with the embedMany telemetry data:\n          recordSpan({\n            name: 'ai.embed.doEmbed',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.embed.doEmbed',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.values': { input: () => [JSON.stringify(value)] },\n              },\n            }),\n            tracer,\n            fn: async doEmbedSpan => {\n              const modelResponse = await model.doEmbed({\n                values: [value],\n                abortSignal,\n                headers: headersWithUserAgent,\n                providerOptions,\n              });\n\n              const embedding = modelResponse.embeddings[0];\n              const usage = modelResponse.usage ?? { tokens: NaN };\n\n              doEmbedSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.embeddings': {\n                      output: () =>\n                        modelResponse.embeddings.map(embedding =>\n                          JSON.stringify(embedding),\n                        ),\n                    },\n                    'ai.usage.tokens': usage.tokens,\n                  },\n                }),\n              );\n\n              return {\n                embedding,\n                usage,\n                warnings: modelResponse.warnings,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response,\n              };\n            },\n          }),\n        );\n\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embedding': { output: () => JSON.stringify(embedding) },\n            'ai.usage.tokens': usage.tokens,\n          },\n        }),\n      );\n\n      logWarnings({ warnings, provider: model.provider, model: model.modelId });\n\n      return new DefaultEmbedResult({\n        value,\n        embedding,\n        usage,\n        warnings,\n        providerMetadata,\n        response,\n      });\n    },\n  });\n}\n\nclass DefaultEmbedResult implements EmbedResult {\n  readonly value: EmbedResult['value'];\n  readonly embedding: EmbedResult['embedding'];\n  readonly usage: EmbedResult['usage'];\n  readonly warnings: EmbedResult['warnings'];\n  readonly providerMetadata: EmbedResult['providerMetadata'];\n  readonly response: EmbedResult['response'];\n\n  constructor(options: {\n    value: EmbedResult['value'];\n    embedding: EmbedResult['embedding'];\n    usage: EmbedResult['usage'];\n    warnings: EmbedResult['warnings'];\n    providerMetadata?: EmbedResult['providerMetadata'];\n    response?: EmbedResult['response'];\n  }) {\n    this.value = options.value;\n    this.embedding = options.embedding;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n  }\n}\n","import { ProviderOptions, withUserAgentSuffix } from '@ai-sdk/provider-utils';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveEmbeddingModel } from '../model/resolve-model';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { Embedding, EmbeddingModel, ProviderMetadata } from '../types';\nimport { Warning } from '../types/warning';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { splitArray } from '../util/split-array';\nimport { EmbedManyResult } from './embed-many-result';\nimport { VERSION } from '../version';\n\n/**\nEmbed several values using an embedding model. The type of the value is defined\nby the embedding model.\n\n`embedMany` automatically splits large requests into smaller chunks if the model\nhas a limit on how many embeddings can be generated in a single call.\n\n@param model - The embedding model to use.\n@param values - The values that should be embedded.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the embeddings, the value, and additional information.\n */\nexport async function embedMany({\n  model: modelArg,\n  values,\n  maxParallelCalls = Infinity,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe embedding model to use.\n     */\n  model: EmbeddingModel;\n\n  /**\nThe values that should be embedded.\n   */\n  values: Array<string>;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n\n  /**\n  Additional provider-specific options. They are passed through\n  to the provider from the AI SDK and enable provider-specific\n  functionality that can be fully encapsulated in the provider.\n  */\n  providerOptions?: ProviderOptions;\n\n  /**\n   * Maximum number of concurrent requests.\n   *\n   * @default Infinity\n   */\n  maxParallelCalls?: number;\n}): Promise<EmbedManyResult> {\n  const model = resolveEmbeddingModel(modelArg);\n\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.embedMany',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.embedMany', telemetry }),\n        ...baseTelemetryAttributes,\n        // specific settings that only make sense on the outer level:\n        'ai.values': {\n          input: () => values.map(value => JSON.stringify(value)),\n        },\n      },\n    }),\n    tracer,\n    fn: async span => {\n      const [maxEmbeddingsPerCall, supportsParallelCalls] = await Promise.all([\n        model.maxEmbeddingsPerCall,\n        model.supportsParallelCalls,\n      ]);\n\n      // the model has not specified limits on\n      // how many embeddings can be generated in a single call\n      if (maxEmbeddingsPerCall == null || maxEmbeddingsPerCall === Infinity) {\n        const { embeddings, usage, warnings, response, providerMetadata } =\n          await retry(() => {\n            // nested spans to align with the embedMany telemetry data:\n            return recordSpan({\n              name: 'ai.embedMany.doEmbed',\n              attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                  ...assembleOperationName({\n                    operationId: 'ai.embedMany.doEmbed',\n                    telemetry,\n                  }),\n                  ...baseTelemetryAttributes,\n                  // specific settings that only make sense on the outer level:\n                  'ai.values': {\n                    input: () => values.map(value => JSON.stringify(value)),\n                  },\n                },\n              }),\n              tracer,\n              fn: async doEmbedSpan => {\n                const modelResponse = await model.doEmbed({\n                  values,\n                  abortSignal,\n                  headers: headersWithUserAgent,\n                  providerOptions,\n                });\n\n                const embeddings = modelResponse.embeddings;\n                const usage = modelResponse.usage ?? { tokens: NaN };\n\n                doEmbedSpan.setAttributes(\n                  await selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                      'ai.embeddings': {\n                        output: () =>\n                          embeddings.map(embedding =>\n                            JSON.stringify(embedding),\n                          ),\n                      },\n                      'ai.usage.tokens': usage.tokens,\n                    },\n                  }),\n                );\n\n                return {\n                  embeddings,\n                  usage,\n                  warnings: modelResponse.warnings,\n                  providerMetadata: modelResponse.providerMetadata,\n                  response: modelResponse.response,\n                };\n              },\n            });\n          });\n\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.embeddings': {\n                output: () =>\n                  embeddings.map(embedding => JSON.stringify(embedding)),\n              },\n              'ai.usage.tokens': usage.tokens,\n            },\n          }),\n        );\n\n        logWarnings({\n          warnings,\n          provider: model.provider,\n          model: model.modelId,\n        });\n\n        return new DefaultEmbedManyResult({\n          values,\n          embeddings,\n          usage,\n          warnings,\n          providerMetadata,\n          responses: [response],\n        });\n      }\n\n      // split the values into chunks that are small enough for the model:\n      const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n\n      // serially embed the chunks:\n      const embeddings: Array<Embedding> = [];\n      const warnings: Array<Warning> = [];\n      const responses: Array<\n        | {\n            headers?: Record<string, string>;\n            body?: unknown;\n          }\n        | undefined\n      > = [];\n      let tokens = 0;\n      let providerMetadata: ProviderMetadata | undefined;\n\n      const parallelChunks = splitArray(\n        valueChunks,\n        supportsParallelCalls ? maxParallelCalls : 1,\n      );\n\n      for (const parallelChunk of parallelChunks) {\n        const results = await Promise.all(\n          parallelChunk.map(chunk => {\n            return retry(() => {\n              // nested spans to align with the embedMany telemetry data:\n              return recordSpan({\n                name: 'ai.embedMany.doEmbed',\n                attributes: selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    ...assembleOperationName({\n                      operationId: 'ai.embedMany.doEmbed',\n                      telemetry,\n                    }),\n                    ...baseTelemetryAttributes,\n                    // specific settings that only make sense on the outer level:\n                    'ai.values': {\n                      input: () => chunk.map(value => JSON.stringify(value)),\n                    },\n                  },\n                }),\n                tracer,\n                fn: async doEmbedSpan => {\n                  const modelResponse = await model.doEmbed({\n                    values: chunk,\n                    abortSignal,\n                    headers: headersWithUserAgent,\n                    providerOptions,\n                  });\n\n                  const embeddings = modelResponse.embeddings;\n                  const usage = modelResponse.usage ?? { tokens: NaN };\n\n                  doEmbedSpan.setAttributes(\n                    await selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.embeddings': {\n                          output: () =>\n                            embeddings.map(embedding =>\n                              JSON.stringify(embedding),\n                            ),\n                        },\n                        'ai.usage.tokens': usage.tokens,\n                      },\n                    }),\n                  );\n\n                  return {\n                    embeddings,\n                    usage,\n                    warnings: modelResponse.warnings,\n                    providerMetadata: modelResponse.providerMetadata,\n                    response: modelResponse.response,\n                  };\n                },\n              });\n            });\n          }),\n        );\n\n        for (const result of results) {\n          embeddings.push(...result.embeddings);\n          warnings.push(...result.warnings);\n          responses.push(result.response);\n          tokens += result.usage.tokens;\n          if (result.providerMetadata) {\n            if (!providerMetadata) {\n              providerMetadata = { ...result.providerMetadata };\n            } else {\n              for (const [providerName, metadata] of Object.entries(\n                result.providerMetadata,\n              )) {\n                providerMetadata[providerName] = {\n                  ...(providerMetadata[providerName] ?? {}),\n                  ...metadata,\n                };\n              }\n            }\n          }\n        }\n      }\n\n      span.setAttributes(\n        await selectTelemetryAttributes({\n          telemetry,\n          attributes: {\n            'ai.embeddings': {\n              output: () =>\n                embeddings.map(embedding => JSON.stringify(embedding)),\n            },\n            'ai.usage.tokens': tokens,\n          },\n        }),\n      );\n\n      logWarnings({\n        warnings,\n        provider: model.provider,\n        model: model.modelId,\n      });\n\n      return new DefaultEmbedManyResult({\n        values,\n        embeddings,\n        usage: { tokens },\n        warnings,\n        providerMetadata: providerMetadata,\n        responses,\n      });\n    },\n  });\n}\n\nclass DefaultEmbedManyResult implements EmbedManyResult {\n  readonly values: EmbedManyResult['values'];\n  readonly embeddings: EmbedManyResult['embeddings'];\n  readonly usage: EmbedManyResult['usage'];\n  readonly warnings: EmbedManyResult['warnings'];\n  readonly providerMetadata: EmbedManyResult['providerMetadata'];\n  readonly responses: EmbedManyResult['responses'];\n\n  constructor(options: {\n    values: EmbedManyResult['values'];\n    embeddings: EmbedManyResult['embeddings'];\n    usage: EmbedManyResult['usage'];\n    warnings: EmbedManyResult['warnings'];\n    providerMetadata?: EmbedManyResult['providerMetadata'];\n    responses?: EmbedManyResult['responses'];\n  }) {\n    this.values = options.values;\n    this.embeddings = options.embeddings;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.responses = options.responses;\n  }\n}\n","/**\n * Splits an array into chunks of a specified size.\n *\n * @template T - The type of elements in the array.\n * @param {T[]} array - The array to split.\n * @param {number} chunkSize - The size of each chunk.\n * @returns {T[][]} - A new array containing the chunks.\n */\nexport function splitArray<T>(array: T[], chunkSize: number): T[][] {\n  if (chunkSize <= 0) {\n    throw new Error('chunkSize must be greater than 0');\n  }\n\n  const result = [];\n  for (let i = 0; i < array.length; i += chunkSize) {\n    result.push(array.slice(i, i + chunkSize));\n  }\n\n  return result;\n}\n","import {\n  ImageModelV3,\n  ImageModelV3CallOptions,\n  ImageModelV3File,\n  ImageModelV3ProviderMetadata,\n} from '@ai-sdk/provider';\nimport {\n  convertBase64ToUint8Array,\n  DataContent,\n  ProviderOptions,\n  withUserAgentSuffix,\n} from '@ai-sdk/provider-utils';\nimport { NoImageGeneratedError } from '../error/no-image-generated-error';\nimport {\n  DefaultGeneratedFile,\n  GeneratedFile,\n} from '../generate-text/generated-file';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveImageModel } from '../model/resolve-model';\nimport type { ImageModel } from '../types/image-model';\nimport { ImageModelResponseMetadata } from '../types/image-model-response-metadata';\nimport { addImageModelUsage, ImageModelUsage } from '../types/usage';\nimport { Warning } from '../types/warning';\nimport {\n  detectMediaType,\n  imageMediaTypeSignatures,\n} from '../util/detect-media-type';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { VERSION } from '../version';\nimport { GenerateImageResult } from './generate-image-result';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { splitDataUrl } from '../prompt/split-data-url';\n\nexport type GenerateImagePrompt =\n  | string\n  | {\n      images: Array<DataContent>;\n      text?: string;\n      mask?: DataContent;\n    };\n\n/**\nGenerates images using an image model.\n\n@param model - The image model to use.\n@param prompt - The prompt that should be used to generate the image.\n@param n - Number of images to generate. Default: 1.\n@param size - Size of the images to generate. Must have the format `{width}x{height}`.\n@param aspectRatio - Aspect ratio of the images to generate. Must have the format `{width}:{height}`.\n@param seed - Seed for the image generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated images.\n */\nexport async function generateImage({\n  model: modelArg,\n  prompt: promptArg,\n  n = 1,\n  maxImagesPerCall,\n  size,\n  aspectRatio,\n  seed,\n  providerOptions,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe image model to use.\n     */\n  model: ImageModel;\n\n  /**\nThe prompt that should be used to generate the image.\n   */\n  prompt: GenerateImagePrompt;\n\n  /**\nNumber of images to generate.\n   */\n  n?: number;\n\n  /**\nNumber of images to generate.\n   */\n  maxImagesPerCall?: number;\n\n  /**\nSize of the images to generate. Must have the format `{width}x{height}`. If not provided, the default size will be used.\n   */\n  size?: `${number}x${number}`;\n\n  /**\nAspect ratio of the images to generate. Must have the format `{width}:{height}`. If not provided, the default aspect ratio will be used.\n   */\n  aspectRatio?: `${number}:${number}`;\n\n  /**\nSeed for the image generation. If not provided, the default seed will be used.\n   */\n  seed?: number;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"style\": \"vivid\"\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per embedding model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<GenerateImageResult> {\n  const model = resolveImageModel(modelArg);\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  // default to 1 if the model has not specified limits on\n  // how many images can be generated in a single call\n  const maxImagesPerCallWithDefault =\n    maxImagesPerCall ?? (await invokeModelMaxImagesPerCall(model)) ?? 1;\n\n  // parallelize calls to the model:\n  const callCount = Math.ceil(n / maxImagesPerCallWithDefault);\n  const callImageCounts = Array.from({ length: callCount }, (_, i) => {\n    if (i < callCount - 1) {\n      return maxImagesPerCallWithDefault;\n    }\n\n    const remainder = n % maxImagesPerCallWithDefault;\n    return remainder === 0 ? maxImagesPerCallWithDefault : remainder;\n  });\n\n  const results = await Promise.all(\n    callImageCounts.map(async callImageCount =>\n      retry(() => {\n        const { prompt, files, mask } = normalizePrompt(promptArg);\n\n        return model.doGenerate({\n          prompt,\n          files,\n          mask,\n          n: callImageCount,\n          abortSignal,\n          headers: headersWithUserAgent,\n          size,\n          aspectRatio,\n          seed,\n          providerOptions: providerOptions ?? {},\n        });\n      }),\n    ),\n  );\n\n  // collect result images, warnings, and response metadata\n  const images: Array<DefaultGeneratedFile> = [];\n  const warnings: Array<Warning> = [];\n  const responses: Array<ImageModelResponseMetadata> = [];\n  const providerMetadata: ImageModelV3ProviderMetadata = {};\n  let totalUsage: ImageModelUsage = {\n    inputTokens: undefined,\n    outputTokens: undefined,\n    totalTokens: undefined,\n  };\n  for (const result of results) {\n    images.push(\n      ...result.images.map(\n        image =>\n          new DefaultGeneratedFile({\n            data: image,\n            mediaType:\n              detectMediaType({\n                data: image,\n                signatures: imageMediaTypeSignatures,\n              }) ?? 'image/png',\n          }),\n      ),\n    );\n    warnings.push(...result.warnings);\n\n    if (result.usage != null) {\n      totalUsage = addImageModelUsage(totalUsage, result.usage);\n    }\n\n    if (result.providerMetadata) {\n      for (const [providerName, metadata] of Object.entries<{\n        images: unknown;\n      }>(result.providerMetadata)) {\n        if (providerName === 'gateway') {\n          const currentEntry = providerMetadata[providerName];\n          if (currentEntry != null && typeof currentEntry === 'object') {\n            providerMetadata[providerName] = {\n              ...(currentEntry as object),\n              ...metadata,\n            } as ImageModelV3ProviderMetadata[string];\n          } else {\n            providerMetadata[providerName] =\n              metadata as ImageModelV3ProviderMetadata[string];\n          }\n          const imagesValue = (\n            providerMetadata[providerName] as { images?: unknown }\n          ).images;\n          if (Array.isArray(imagesValue) && imagesValue.length === 0) {\n            delete (providerMetadata[providerName] as { images?: unknown })\n              .images;\n          }\n        } else {\n          providerMetadata[providerName] ??= { images: [] };\n          providerMetadata[providerName].images.push(\n            ...result.providerMetadata[providerName].images,\n          );\n        }\n      }\n    }\n\n    responses.push(result.response);\n  }\n\n  logWarnings({ warnings, provider: model.provider, model: model.modelId });\n\n  if (!images.length) {\n    throw new NoImageGeneratedError({ responses });\n  }\n\n  return new DefaultGenerateImageResult({\n    images,\n    warnings,\n    responses,\n    providerMetadata,\n    usage: totalUsage,\n  });\n}\n\nclass DefaultGenerateImageResult implements GenerateImageResult {\n  readonly images: Array<GeneratedFile>;\n  readonly warnings: Array<Warning>;\n  readonly responses: Array<ImageModelResponseMetadata>;\n  readonly providerMetadata: ImageModelV3ProviderMetadata;\n  readonly usage: ImageModelUsage;\n\n  constructor(options: {\n    images: Array<GeneratedFile>;\n    warnings: Array<Warning>;\n    responses: Array<ImageModelResponseMetadata>;\n    providerMetadata: ImageModelV3ProviderMetadata;\n    usage: ImageModelUsage;\n  }) {\n    this.images = options.images;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata;\n    this.usage = options.usage;\n  }\n\n  get image() {\n    return this.images[0];\n  }\n}\n\nasync function invokeModelMaxImagesPerCall(model: ImageModelV3) {\n  const isFunction = model.maxImagesPerCall instanceof Function;\n\n  if (!isFunction) {\n    return model.maxImagesPerCall;\n  }\n\n  return model.maxImagesPerCall({\n    modelId: model.modelId,\n  });\n}\n\nfunction normalizePrompt(\n  prompt: GenerateImagePrompt,\n): Pick<ImageModelV3CallOptions, 'prompt' | 'files' | 'mask'> {\n  if (typeof prompt === 'string') {\n    return { prompt, files: undefined, mask: undefined };\n  }\n\n  return {\n    prompt: prompt.text,\n    files: prompt.images.map(toImageModelV3File),\n    mask: prompt.mask ? toImageModelV3File(prompt.mask) : undefined,\n  };\n}\n\nfunction toImageModelV3File(dataContent: DataContent): ImageModelV3File {\n  if (typeof dataContent === 'string' && dataContent.startsWith('http')) {\n    return {\n      type: 'url',\n      url: dataContent,\n    };\n  }\n\n  // Handle data URLs\n  if (typeof dataContent === 'string' && dataContent.startsWith('data:')) {\n    const { mediaType: dataUrlMediaType, base64Content } =\n      splitDataUrl(dataContent);\n\n    if (base64Content != null) {\n      const uint8Data = convertBase64ToUint8Array(base64Content);\n      return {\n        type: 'file',\n        data: uint8Data,\n        mediaType:\n          dataUrlMediaType ||\n          detectMediaType({\n            data: uint8Data,\n            signatures: imageMediaTypeSignatures,\n          }) ||\n          'image/png',\n      };\n    }\n  }\n\n  const uint8Data = convertDataContentToUint8Array(dataContent);\n  return {\n    type: 'file',\n    data: uint8Data,\n    mediaType:\n      detectMediaType({\n        data: uint8Data,\n        signatures: imageMediaTypeSignatures,\n      }) || 'image/png',\n  };\n}\n","export { generateImage } from './generate-image';\nexport type { GenerateImageResult } from './generate-image-result';\n\n// depreacted exports\n\nimport { generateImage } from './generate-image';\n/**\n * @deprecated Use `generateImage` instead.\n */\nconst experimental_generateImage = generateImage;\nexport { experimental_generateImage };\n\nimport type { GenerateImageResult } from './generate-image-result';\n/**\n * @deprecated Use `GenerateImageResult` instead.\n */\ntype Experimental_GenerateImageResult = GenerateImageResult;\nexport type { Experimental_GenerateImageResult };\n","import { JSONValue } from '@ai-sdk/provider';\nimport {\n  createIdGenerator,\n  FlexibleSchema,\n  InferSchema,\n  ProviderOptions,\n  withUserAgentSuffix,\n} from '@ai-sdk/provider-utils';\nimport { NoObjectGeneratedError } from '../error/no-object-generated-error';\nimport { extractReasoningContent } from '../generate-text/extract-reasoning-content';\nimport { extractTextContent } from '../generate-text/extract-text-content';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveLanguageModel } from '../model/resolve-model';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { wrapGatewayError } from '../prompt/wrap-gateway-error';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { stringifyForTelemetry } from '../telemetry/stringify-for-telemetry';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata } from '../types/provider-metadata';\nimport { asLanguageModelUsage, LanguageModelUsage } from '../types/usage';\nimport { DownloadFunction } from '../util/download/download-function';\nimport { prepareHeaders } from '../util/prepare-headers';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { VERSION } from '../version';\nimport { GenerateObjectResult } from './generate-object-result';\nimport { getOutputStrategy } from './output-strategy';\nimport { parseAndValidateObjectResultWithRepair } from './parse-and-validate-object-result';\nimport { RepairTextFunction } from './repair-text';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function does not stream the output. If you want to stream the output, use `streamObject` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxOutputTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param schema - The schema of the object that the model should generate.\n@param schemaName - Optional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n@param schemaDescription - Optional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n\n@param output - The type of the output.\n\n- 'object': The output is an object.\n- 'array': The output is an array.\n- 'enum': The output is an enum.\n- 'no-schema': The output is not a schema.\n\n@param experimental_repairText - A function that attempts to repair the raw output of the model\nto enable JSON parsing.\n\n@param experimental_telemetry - Optional telemetry configuration (experimental).\n\n@param providerOptions - Additional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n\n@returns\nA result object that contains the generated object, the finish reason, the token usage, and additional information.\n\n@deprecated Use `generateText` with an `output` setting instead.\n */\nexport async function generateObject<\n  SCHEMA extends FlexibleSchema<unknown> = FlexibleSchema<JSONValue>,\n  OUTPUT extends\n    | 'object'\n    | 'array'\n    | 'enum'\n    | 'no-schema' = InferSchema<SCHEMA> extends string ? 'enum' : 'object',\n  RESULT = OUTPUT extends 'array'\n    ? Array<InferSchema<SCHEMA>>\n    : InferSchema<SCHEMA>,\n>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt &\n    (OUTPUT extends 'enum'\n      ? {\n          /**\nThe enum values that the model should use.\n        */\n          enum: Array<RESULT>;\n          output: 'enum';\n        }\n      : OUTPUT extends 'no-schema'\n        ? {}\n        : {\n            /**\nThe schema of the object that the model should generate.\n        */\n            schema: SCHEMA;\n\n            /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n        */\n            schemaName?: string;\n\n            /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n        */\n            schemaDescription?: string;\n          }) & {\n      output?: OUTPUT;\n\n      /**\n  The language model to use.\n       */\n      model: LanguageModel;\n      /**\n  A function that attempts to repair the raw output of the model\n  to enable JSON parsing.\n       */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\n  Optional telemetry configuration (experimental).\n         */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\n  Custom download function to use for URLs.\n\n  By default, files are downloaded if the model does not support the URL for the given media type.\n       */\n      experimental_download?: DownloadFunction | undefined;\n\n      /**\n  Additional provider-specific options. They are passed through\n  to the provider from the AI SDK and enable provider-specific\n  functionality that can be fully encapsulated in the provider.\n   */\n      providerOptions?: ProviderOptions;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n      };\n    },\n): Promise<GenerateObjectResult<RESULT>> {\n  const {\n    model: modelArg,\n    output = 'object',\n    system,\n    prompt,\n    messages,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download,\n    providerOptions,\n    _internal: {\n      generateId = originalGenerateId,\n      currentDate = () => new Date(),\n    } = {},\n    ...settings\n  } = options;\n\n  const model = resolveLanguageModel(modelArg);\n\n  const enumValues = 'enum' in options ? options.enum : undefined;\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName,\n  } = 'schema' in options ? options : {};\n\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  const callSettings = prepareCallSettings(settings);\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers: headersWithUserAgent,\n    settings: { ...callSettings, maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n  const jsonSchema = await outputStrategy.jsonSchema();\n\n  try {\n    return await recordSpan({\n      name: 'ai.generateObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.generateObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema':\n            jsonSchema != null\n              ? { input: () => JSON.stringify(jsonSchema) }\n              : undefined,\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n        },\n      }),\n      tracer,\n      fn: async span => {\n        let result: string;\n        let finishReason: FinishReason;\n        let usage: LanguageModelUsage;\n        let warnings: CallWarning[] | undefined;\n        let response: LanguageModelResponseMetadata;\n        let request: LanguageModelRequestMetadata;\n        let resultProviderMetadata: ProviderMetadata | undefined;\n        let reasoning: string | undefined;\n\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages,\n        } as Prompt);\n\n        const promptMessages = await convertToLanguageModelPrompt({\n          prompt: standardizedPrompt,\n          supportedUrls: await model.supportedUrls,\n          download,\n        });\n\n        const generateResult = await retry(() =>\n          recordSpan({\n            name: 'ai.generateObject.doGenerate',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.generateObject.doGenerate',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(promptMessages),\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty':\n                  callSettings.frequencyPenalty,\n                'gen_ai.request.max_tokens': callSettings.maxOutputTokens,\n                'gen_ai.request.presence_penalty': callSettings.presencePenalty,\n                'gen_ai.request.temperature': callSettings.temperature,\n                'gen_ai.request.top_k': callSettings.topK,\n                'gen_ai.request.top_p': callSettings.topP,\n              },\n            }),\n            tracer,\n            fn: async span => {\n              const result = await model.doGenerate({\n                responseFormat: {\n                  type: 'json',\n                  schema: jsonSchema,\n                  name: schemaName,\n                  description: schemaDescription,\n                },\n                ...prepareCallSettings(settings),\n                prompt: promptMessages,\n                providerOptions,\n                abortSignal,\n                headers: headersWithUserAgent,\n              });\n\n              const responseData = {\n                id: result.response?.id ?? generateId(),\n                timestamp: result.response?.timestamp ?? currentDate(),\n                modelId: result.response?.modelId ?? model.modelId,\n                headers: result.response?.headers,\n                body: result.response?.body,\n              };\n\n              const text = extractTextContent(result.content);\n              const reasoning = extractReasoningContent(result.content);\n\n              if (text === undefined) {\n                throw new NoObjectGeneratedError({\n                  message:\n                    'No object generated: the model did not return a response.',\n                  response: responseData,\n                  usage: asLanguageModelUsage(result.usage),\n                  finishReason: result.finishReason.unified,\n                });\n              }\n\n              // Add response information to the span:\n              span.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.response.finishReason': result.finishReason.unified,\n                    'ai.response.object': { output: () => text },\n                    'ai.response.id': responseData.id,\n                    'ai.response.model': responseData.modelId,\n                    'ai.response.timestamp':\n                      responseData.timestamp.toISOString(),\n                    'ai.response.providerMetadata': JSON.stringify(\n                      result.providerMetadata,\n                    ),\n\n                    // TODO rename telemetry attributes to inputTokens and outputTokens\n                    'ai.usage.promptTokens': result.usage.inputTokens.total,\n                    'ai.usage.completionTokens':\n                      result.usage.outputTokens.total,\n\n                    // standardized gen-ai llm span attributes:\n                    'gen_ai.response.finish_reasons': [\n                      result.finishReason.unified,\n                    ],\n                    'gen_ai.response.id': responseData.id,\n                    'gen_ai.response.model': responseData.modelId,\n                    'gen_ai.usage.input_tokens': result.usage.inputTokens.total,\n                    'gen_ai.usage.output_tokens':\n                      result.usage.outputTokens.total,\n                  },\n                }),\n              );\n\n              return {\n                ...result,\n                objectText: text,\n                reasoning,\n                responseData,\n              };\n            },\n          }),\n        );\n\n        result = generateResult.objectText;\n        finishReason = generateResult.finishReason.unified;\n        usage = asLanguageModelUsage(generateResult.usage);\n        warnings = generateResult.warnings;\n        resultProviderMetadata = generateResult.providerMetadata;\n        request = generateResult.request ?? {};\n        response = generateResult.responseData;\n        reasoning = generateResult.reasoning;\n\n        logWarnings({\n          warnings,\n          provider: model.provider,\n          model: model.modelId,\n        });\n\n        const object = await parseAndValidateObjectResultWithRepair(\n          result,\n          outputStrategy,\n          repairText,\n          {\n            response,\n            usage,\n            finishReason,\n          },\n        );\n\n        // Add response information to the span:\n        span.setAttributes(\n          await selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n              'ai.response.finishReason': finishReason,\n              'ai.response.object': {\n                output: () => JSON.stringify(object),\n              },\n              'ai.response.providerMetadata': JSON.stringify(\n                resultProviderMetadata,\n              ),\n\n              // TODO rename telemetry attributes to inputTokens and outputTokens\n              'ai.usage.promptTokens': usage.inputTokens,\n              'ai.usage.completionTokens': usage.outputTokens,\n            },\n          }),\n        );\n\n        return new DefaultGenerateObjectResult({\n          object,\n          reasoning,\n          finishReason,\n          usage,\n          warnings,\n          request,\n          response,\n          providerMetadata: resultProviderMetadata,\n        });\n      },\n    });\n  } catch (error) {\n    throw wrapGatewayError(error);\n  }\n}\n\nclass DefaultGenerateObjectResult<T> implements GenerateObjectResult<T> {\n  readonly object: GenerateObjectResult<T>['object'];\n  readonly finishReason: GenerateObjectResult<T>['finishReason'];\n  readonly usage: GenerateObjectResult<T>['usage'];\n  readonly warnings: GenerateObjectResult<T>['warnings'];\n  readonly providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n  readonly response: GenerateObjectResult<T>['response'];\n  readonly request: GenerateObjectResult<T>['request'];\n  readonly reasoning: GenerateObjectResult<T>['reasoning'];\n\n  constructor(options: {\n    object: GenerateObjectResult<T>['object'];\n    finishReason: GenerateObjectResult<T>['finishReason'];\n    usage: GenerateObjectResult<T>['usage'];\n    warnings: GenerateObjectResult<T>['warnings'];\n    providerMetadata: GenerateObjectResult<T>['providerMetadata'];\n    response: GenerateObjectResult<T>['response'];\n    request: GenerateObjectResult<T>['request'];\n    reasoning: GenerateObjectResult<T>['reasoning'];\n  }) {\n    this.object = options.object;\n    this.finishReason = options.finishReason;\n    this.usage = options.usage;\n    this.warnings = options.warnings;\n    this.providerMetadata = options.providerMetadata;\n    this.response = options.response;\n    this.request = options.request;\n    this.reasoning = options.reasoning;\n  }\n\n  toJsonResponse(init?: ResponseInit): Response {\n    return new Response(JSON.stringify(this.object), {\n      status: init?.status ?? 200,\n      headers: prepareHeaders(init?.headers, {\n        'content-type': 'application/json; charset=utf-8',\n      }),\n    });\n  }\n}\n","import {\n  LanguageModelV3Content,\n  LanguageModelV3Reasoning,\n} from '@ai-sdk/provider';\n\nexport function extractReasoningContent(\n  content: LanguageModelV3Content[],\n): string | undefined {\n  const parts = content.filter(\n    (content): content is LanguageModelV3Reasoning =>\n      content.type === 'reasoning',\n  );\n\n  return parts.length === 0\n    ? undefined\n    : parts.map(content => content.text).join('\\n');\n}\n","import {\n  isJSONArray,\n  isJSONObject,\n  JSONObject,\n  JSONSchema7,\n  JSONValue,\n  TypeValidationError,\n  UnsupportedFunctionalityError,\n} from '@ai-sdk/provider';\nimport {\n  asSchema,\n  FlexibleSchema,\n  safeValidateTypes,\n  Schema,\n  ValidationResult,\n} from '@ai-sdk/provider-utils';\nimport { NoObjectGeneratedError } from '../error/no-object-generated-error';\nimport {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { DeepPartial } from '../util/deep-partial';\nimport { ObjectStreamPart } from './stream-object-result';\n\nexport interface OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM> {\n  readonly type: 'object' | 'array' | 'enum' | 'no-schema';\n\n  jsonSchema(): Promise<JSONSchema7 | undefined>;\n\n  validatePartialResult({\n    value,\n    textDelta,\n    isFinalDelta,\n  }: {\n    value: JSONValue;\n    textDelta: string;\n    isFirstDelta: boolean;\n    isFinalDelta: boolean;\n    latestObject: PARTIAL | undefined;\n  }): Promise<\n    ValidationResult<{\n      partial: PARTIAL;\n      textDelta: string;\n    }>\n  >;\n  validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n    },\n  ): Promise<ValidationResult<RESULT>>;\n\n  createElementStream(\n    originalStream: ReadableStream<ObjectStreamPart<PARTIAL>>,\n  ): ELEMENT_STREAM;\n}\n\nconst noSchemaOutputStrategy: OutputStrategy<JSONValue, JSONValue, never> = {\n  type: 'no-schema',\n  jsonSchema: async () => undefined,\n\n  async validatePartialResult({ value, textDelta }) {\n    return { success: true, value: { partial: value, textDelta } };\n  },\n\n  async validateFinalResult(\n    value: JSONValue | undefined,\n    context: {\n      text: string;\n      response: LanguageModelResponseMetadata;\n      usage: LanguageModelUsage;\n      finishReason: FinishReason;\n    },\n  ): Promise<ValidationResult<JSONValue>> {\n    return value === undefined\n      ? {\n          success: false,\n          error: new NoObjectGeneratedError({\n            message: 'No object generated: response did not match schema.',\n            text: context.text,\n            response: context.response,\n            usage: context.usage,\n            finishReason: context.finishReason,\n          }),\n        }\n      : { success: true, value };\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in no-schema mode',\n    });\n  },\n};\n\nconst objectOutputStrategy = <OBJECT>(\n  schema: Schema<OBJECT>,\n): OutputStrategy<DeepPartial<OBJECT>, OBJECT, never> => ({\n  type: 'object',\n  jsonSchema: async () => await schema.jsonSchema,\n\n  async validatePartialResult({ value, textDelta }) {\n    return {\n      success: true,\n      value: {\n        // Note: currently no validation of partial results:\n        partial: value as DeepPartial<OBJECT>,\n        textDelta,\n      },\n    };\n  },\n\n  async validateFinalResult(\n    value: JSONValue | undefined,\n  ): Promise<ValidationResult<OBJECT>> {\n    return safeValidateTypes({ value, schema });\n  },\n\n  createElementStream() {\n    throw new UnsupportedFunctionalityError({\n      functionality: 'element streams in object mode',\n    });\n  },\n});\n\nconst arrayOutputStrategy = <ELEMENT>(\n  schema: Schema<ELEMENT>,\n): OutputStrategy<ELEMENT[], ELEMENT[], AsyncIterableStream<ELEMENT>> => {\n  return {\n    type: 'array',\n\n    // wrap in object that contains array of elements, since most LLMs will not\n    // be able to generate an array directly:\n    // possible future optimization: use arrays directly when model supports grammar-guided generation\n    jsonSchema: async () => {\n      // remove $schema from schema.jsonSchema:\n      const { $schema, ...itemSchema } = await schema.jsonSchema;\n\n      return {\n        $schema: 'http://json-schema.org/draft-07/schema#',\n        type: 'object',\n        properties: {\n          elements: { type: 'array', items: itemSchema },\n        },\n        required: ['elements'],\n        additionalProperties: false,\n      };\n    },\n\n    async validatePartialResult({\n      value,\n      latestObject,\n      isFirstDelta,\n      isFinalDelta,\n    }) {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n      const resultArray: Array<ELEMENT> = [];\n\n      for (let i = 0; i < inputArray.length; i++) {\n        const element = inputArray[i];\n        const result = await safeValidateTypes({ value: element, schema });\n\n        // special treatment for last processed element:\n        // ignore parse or validation failures, since they indicate that the\n        // last element is incomplete and should not be included in the result,\n        // unless it is the final delta\n        if (i === inputArray.length - 1 && !isFinalDelta) {\n          continue;\n        }\n\n        if (!result.success) {\n          return result;\n        }\n\n        resultArray.push(result.value);\n      }\n\n      // calculate delta:\n      const publishedElementCount = latestObject?.length ?? 0;\n\n      let textDelta = '';\n\n      if (isFirstDelta) {\n        textDelta += '[';\n      }\n\n      if (publishedElementCount > 0) {\n        textDelta += ',';\n      }\n\n      textDelta += resultArray\n        .slice(publishedElementCount) // only new elements\n        .map(element => JSON.stringify(element))\n        .join(',');\n\n      if (isFinalDelta) {\n        textDelta += ']';\n      }\n\n      return {\n        success: true,\n        value: {\n          partial: resultArray,\n          textDelta,\n        },\n      };\n    },\n\n    async validateFinalResult(\n      value: JSONValue | undefined,\n    ): Promise<ValidationResult<Array<ELEMENT>>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || !isJSONArray(value.elements)) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be an object that contains an array of elements',\n          }),\n        };\n      }\n\n      const inputArray = value.elements as Array<JSONObject>;\n\n      // check that each element in the array is of the correct type:\n      for (const element of inputArray) {\n        const result = await safeValidateTypes({ value: element, schema });\n        if (!result.success) {\n          return result;\n        }\n      }\n\n      return { success: true, value: inputArray as Array<ELEMENT> };\n    },\n\n    createElementStream(\n      originalStream: ReadableStream<ObjectStreamPart<ELEMENT[]>>,\n    ) {\n      let publishedElements = 0;\n\n      return createAsyncIterableStream(\n        originalStream.pipeThrough(\n          new TransformStream<ObjectStreamPart<ELEMENT[]>, ELEMENT>({\n            transform(chunk, controller) {\n              switch (chunk.type) {\n                case 'object': {\n                  const array = chunk.object;\n\n                  // publish new elements one by one:\n                  for (\n                    ;\n                    publishedElements < array.length;\n                    publishedElements++\n                  ) {\n                    controller.enqueue(array[publishedElements]);\n                  }\n\n                  break;\n                }\n\n                case 'text-delta':\n                case 'finish':\n                case 'error': // suppress error (use onError instead)\n                  break;\n\n                default: {\n                  const _exhaustiveCheck: never = chunk;\n                  throw new Error(\n                    `Unsupported chunk type: ${_exhaustiveCheck}`,\n                  );\n                }\n              }\n            },\n          }),\n        ),\n      );\n    },\n  };\n};\n\nconst enumOutputStrategy = <ENUM extends string>(\n  enumValues: Array<ENUM>,\n): OutputStrategy<string, ENUM, never> => {\n  return {\n    type: 'enum',\n\n    // wrap in object that contains result, since most LLMs will not\n    // be able to generate an enum value directly:\n    // possible future optimization: use enums directly when model supports top-level enums\n    jsonSchema: async () => ({\n      $schema: 'http://json-schema.org/draft-07/schema#',\n      type: 'object',\n      properties: {\n        result: { type: 'string', enum: enumValues },\n      },\n      required: ['result'],\n      additionalProperties: false,\n    }),\n\n    async validateFinalResult(\n      value: JSONValue | undefined,\n    ): Promise<ValidationResult<ENUM>> {\n      // check that the value is an object that contains an array of elements:\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n\n      return enumValues.includes(result as ENUM)\n        ? { success: true, value: result as ENUM }\n        : {\n            success: false,\n            error: new TypeValidationError({\n              value,\n              cause: 'value must be a string in the enum',\n            }),\n          };\n    },\n\n    async validatePartialResult({ value, textDelta }) {\n      if (!isJSONObject(value) || typeof value.result !== 'string') {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause:\n              'value must be an object that contains a string in the \"result\" property.',\n          }),\n        };\n      }\n\n      const result = value.result as string;\n      const possibleEnumValues = enumValues.filter(enumValue =>\n        enumValue.startsWith(result),\n      );\n\n      if (value.result.length === 0 || possibleEnumValues.length === 0) {\n        return {\n          success: false,\n          error: new TypeValidationError({\n            value,\n            cause: 'value must be a string in the enum',\n          }),\n        };\n      }\n\n      return {\n        success: true,\n        value: {\n          partial:\n            possibleEnumValues.length > 1 ? result : possibleEnumValues[0],\n          textDelta,\n        },\n      };\n    },\n\n    createElementStream() {\n      // no streaming in enum mode\n      throw new UnsupportedFunctionalityError({\n        functionality: 'element streams in enum mode',\n      });\n    },\n  };\n};\n\nexport function getOutputStrategy<SCHEMA>({\n  output,\n  schema,\n  enumValues,\n}: {\n  output: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: FlexibleSchema<SCHEMA>;\n  enumValues?: Array<SCHEMA>;\n}): OutputStrategy<any, any, any> {\n  switch (output) {\n    case 'object':\n      return objectOutputStrategy(asSchema(schema!));\n    case 'array':\n      return arrayOutputStrategy(asSchema(schema!));\n    case 'enum':\n      return enumOutputStrategy(enumValues! as Array<string>);\n    case 'no-schema':\n      return noSchemaOutputStrategy;\n    default: {\n      const _exhaustiveCheck: never = output;\n      throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n    }\n  }\n}\n","import { JSONParseError, TypeValidationError } from '@ai-sdk/provider';\nimport { safeParseJSON } from '@ai-sdk/provider-utils';\nimport { NoObjectGeneratedError } from '../error/no-object-generated-error';\nimport type {\n  FinishReason,\n  LanguageModelResponseMetadata,\n  LanguageModelUsage,\n} from '../types';\nimport type { OutputStrategy } from './output-strategy';\nimport { RepairTextFunction } from './repair-text';\n\n/**\n * Parses and validates a result string by parsing it as JSON and validating against the output strategy.\n *\n * @param result - The result string to parse and validate\n * @param outputStrategy - The output strategy containing validation logic\n * @param context - Additional context for error reporting\n * @returns The validated result\n * @throws NoObjectGeneratedError if parsing or validation fails\n */\nasync function parseAndValidateObjectResult<RESULT>(\n  result: string,\n  outputStrategy: OutputStrategy<any, RESULT, any>,\n  context: {\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n): Promise<RESULT> {\n  const parseResult = await safeParseJSON({ text: result });\n\n  if (!parseResult.success) {\n    throw new NoObjectGeneratedError({\n      message: 'No object generated: could not parse the response.',\n      cause: parseResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason,\n    });\n  }\n\n  const validationResult = await outputStrategy.validateFinalResult(\n    parseResult.value,\n    {\n      text: result,\n      response: context.response,\n      usage: context.usage,\n    },\n  );\n\n  if (!validationResult.success) {\n    throw new NoObjectGeneratedError({\n      message: 'No object generated: response did not match schema.',\n      cause: validationResult.error,\n      text: result,\n      response: context.response,\n      usage: context.usage,\n      finishReason: context.finishReason,\n    });\n  }\n\n  return validationResult.value;\n}\n\n/**\n * Parses and validates a result string by parsing it as JSON and validating against the output strategy.\n * If the result cannot be parsed, it attempts to repair the result using the repairText function.\n *\n * @param result - The result string to parse and validate\n * @param outputStrategy - The output strategy containing validation logic\n * @param repairText - A function that attempts to repair the result string\n * @param context - Additional context for error reporting\n * @returns The validated result\n * @throws NoObjectGeneratedError if parsing or validation fails\n */\nexport async function parseAndValidateObjectResultWithRepair<RESULT>(\n  result: string,\n  outputStrategy: OutputStrategy<any, RESULT, any>,\n  repairText: RepairTextFunction | undefined,\n  context: {\n    response: LanguageModelResponseMetadata;\n    usage: LanguageModelUsage;\n    finishReason: FinishReason;\n  },\n): Promise<RESULT> {\n  try {\n    return await parseAndValidateObjectResult(result, outputStrategy, context);\n  } catch (error) {\n    if (\n      repairText != null &&\n      NoObjectGeneratedError.isInstance(error) &&\n      (JSONParseError.isInstance(error.cause) ||\n        TypeValidationError.isInstance(error.cause))\n    ) {\n      const repairedText = await repairText({\n        text: result,\n        error: error.cause,\n      });\n      if (repairedText === null) {\n        throw error;\n      }\n      return await parseAndValidateObjectResult(\n        repairedText,\n        outputStrategy,\n        context,\n      );\n    }\n    throw error;\n  }\n}\n","import { FlexibleSchema } from '@ai-sdk/provider-utils';\nimport { InvalidArgumentError } from '../error/invalid-argument-error';\n\nexport function validateObjectGenerationInput({\n  output,\n  schema,\n  schemaName,\n  schemaDescription,\n  enumValues,\n}: {\n  output?: 'object' | 'array' | 'enum' | 'no-schema';\n  schema?: FlexibleSchema<unknown>;\n  schemaName?: string;\n  schemaDescription?: string;\n  enumValues?: Array<unknown>;\n}) {\n  if (\n    output != null &&\n    output !== 'object' &&\n    output !== 'array' &&\n    output !== 'enum' &&\n    output !== 'no-schema'\n  ) {\n    throw new InvalidArgumentError({\n      parameter: 'output',\n      value: output,\n      message: 'Invalid output type.',\n    });\n  }\n\n  if (output === 'no-schema') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for no-schema output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for no-schema output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for no-schema output.',\n      });\n    }\n  }\n\n  if (output === 'object') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is required for object output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for object output.',\n      });\n    }\n  }\n\n  if (output === 'array') {\n    if (schema == null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Element schema is required for array output.',\n      });\n    }\n\n    if (enumValues != null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are not supported for array output.',\n      });\n    }\n  }\n\n  if (output === 'enum') {\n    if (schema != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schema',\n        value: schema,\n        message: 'Schema is not supported for enum output.',\n      });\n    }\n\n    if (schemaDescription != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaDescription',\n        value: schemaDescription,\n        message: 'Schema description is not supported for enum output.',\n      });\n    }\n\n    if (schemaName != null) {\n      throw new InvalidArgumentError({\n        parameter: 'schemaName',\n        value: schemaName,\n        message: 'Schema name is not supported for enum output.',\n      });\n    }\n\n    if (enumValues == null) {\n      throw new InvalidArgumentError({\n        parameter: 'enumValues',\n        value: enumValues,\n        message: 'Enum values are required for enum output.',\n      });\n    }\n\n    for (const value of enumValues) {\n      if (typeof value !== 'string') {\n        throw new InvalidArgumentError({\n          parameter: 'enumValues',\n          value,\n          message: 'Enum values must be strings.',\n        });\n      }\n    }\n  }\n}\n","import {\n  JSONValue,\n  LanguageModelV3FinishReason,\n  LanguageModelV3StreamPart,\n  LanguageModelV3Usage,\n  SharedV3ProviderMetadata,\n  SharedV3Warning,\n} from '@ai-sdk/provider';\nimport {\n  createIdGenerator,\n  DelayedPromise,\n  FlexibleSchema,\n  ProviderOptions,\n  type InferSchema,\n} from '@ai-sdk/provider-utils';\nimport { ServerResponse } from 'http';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveLanguageModel } from '../model/resolve-model';\nimport { CallSettings } from '../prompt/call-settings';\nimport { convertToLanguageModelPrompt } from '../prompt/convert-to-language-model-prompt';\nimport { prepareCallSettings } from '../prompt/prepare-call-settings';\nimport { Prompt } from '../prompt/prompt';\nimport { standardizePrompt } from '../prompt/standardize-prompt';\nimport { wrapGatewayError } from '../prompt/wrap-gateway-error';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { stringifyForTelemetry } from '../telemetry/stringify-for-telemetry';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { createTextStreamResponse } from '../text-stream/create-text-stream-response';\nimport { pipeTextStreamToResponse } from '../text-stream/pipe-text-stream-to-response';\nimport {\n  CallWarning,\n  FinishReason,\n  LanguageModel,\n} from '../types/language-model';\nimport { LanguageModelRequestMetadata } from '../types/language-model-request-metadata';\nimport { LanguageModelResponseMetadata } from '../types/language-model-response-metadata';\nimport { ProviderMetadata } from '../types/provider-metadata';\nimport {\n  asLanguageModelUsage,\n  createNullLanguageModelUsage,\n  LanguageModelUsage,\n} from '../types/usage';\nimport { DeepPartial, isDeepEqualData, parsePartialJson } from '../util';\nimport {\n  AsyncIterableStream,\n  createAsyncIterableStream,\n} from '../util/async-iterable-stream';\nimport { createStitchableStream } from '../util/create-stitchable-stream';\nimport { DownloadFunction } from '../util/download/download-function';\nimport { now as originalNow } from '../util/now';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { getOutputStrategy, OutputStrategy } from './output-strategy';\nimport { parseAndValidateObjectResultWithRepair } from './parse-and-validate-object-result';\nimport { RepairTextFunction } from './repair-text';\nimport { ObjectStreamPart, StreamObjectResult } from './stream-object-result';\nimport { validateObjectGenerationInput } from './validate-object-generation-input';\n\nconst originalGenerateId = createIdGenerator({ prefix: 'aiobj', size: 24 });\n\n/**\nCallback that is set using the `onError` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnErrorCallback = (event: {\n  error: unknown;\n}) => Promise<void> | void;\n\n/**\nCallback that is set using the `onFinish` option.\n\n@param event - The event that is passed to the callback.\n */\nexport type StreamObjectOnFinishCallback<RESULT> = (event: {\n  /**\nThe token usage of the generated response.\n*/\n  usage: LanguageModelUsage;\n\n  /**\nThe generated object. Can be undefined if the final object does not match the schema.\n*/\n  object: RESULT | undefined;\n\n  /**\nOptional error object. This is e.g. a TypeValidationError when the final object does not match the schema.\n*/\n  error: unknown | undefined;\n\n  /**\nResponse metadata.\n */\n  response: LanguageModelResponseMetadata;\n\n  /**\nWarnings from the model provider (e.g. unsupported settings).\n*/\n  warnings?: CallWarning[];\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n*/\n  providerMetadata: ProviderMetadata | undefined;\n}) => Promise<void> | void;\n\n/**\nGenerate a structured, typed object for a given prompt and schema using a language model.\n\nThis function streams the output. If you do not want to stream the output, use `generateObject` instead.\n\n@param model - The language model to use.\n@param tools - Tools that are accessible to and can be called by the model. The model needs to support calling tools.\n\n@param system - A system message that will be part of the prompt.\n@param prompt - A simple text prompt. You can either use `prompt` or `messages` but not both.\n@param messages - A list of messages. You can either use `prompt` or `messages` but not both.\n\n@param maxOutputTokens - Maximum number of tokens to generate.\n@param temperature - Temperature setting.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topP - Nucleus sampling.\nThe value is passed through to the provider. The range depends on the provider and model.\nIt is recommended to set either `temperature` or `topP`, but not both.\n@param topK - Only sample from the top K options for each subsequent token.\nUsed to remove \"long tail\" low probability responses.\nRecommended for advanced use cases only. You usually only need to use temperature.\n@param presencePenalty - Presence penalty setting.\nIt affects the likelihood of the model to repeat information that is already in the prompt.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param frequencyPenalty - Frequency penalty setting.\nIt affects the likelihood of the model to repeatedly use the same words or phrases.\nThe value is passed through to the provider. The range depends on the provider and model.\n@param stopSequences - Stop sequences.\nIf set, the model will stop generating text when one of the stop sequences is generated.\n@param seed - The seed (integer) to use for random sampling.\nIf set and supported by the model, calls will generate deterministic results.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@param schema - The schema of the object that the model should generate.\n@param schemaName - Optional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n@param schemaDescription - Optional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n\n@param output - The type of the output.\n\n- 'object': The output is an object.\n- 'array': The output is an array.\n- 'enum': The output is an enum.\n- 'no-schema': The output is not a schema.\n\n@param experimental_telemetry - Optional telemetry configuration (experimental).\n\n@param providerOptions - Additional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n\n@returns\nA result object for accessing the partial object stream and additional information.\n\n@deprecated Use `streamText` with an `output` setting instead.\n */\nexport function streamObject<\n  SCHEMA extends FlexibleSchema<unknown> = FlexibleSchema<JSONValue>,\n  OUTPUT extends\n    | 'object'\n    | 'array'\n    | 'enum'\n    | 'no-schema' = InferSchema<SCHEMA> extends string ? 'enum' : 'object',\n  RESULT = OUTPUT extends 'array'\n    ? Array<InferSchema<SCHEMA>>\n    : InferSchema<SCHEMA>,\n>(\n  options: Omit<CallSettings, 'stopSequences'> &\n    Prompt &\n    (OUTPUT extends 'enum'\n      ? {\n          /**\nThe enum values that the model should use.\n        */\n          enum: Array<RESULT>;\n          output: 'enum';\n        }\n      : OUTPUT extends 'no-schema'\n        ? {}\n        : {\n            /**\nThe schema of the object that the model should generate.\n      */\n            schema: SCHEMA;\n\n            /**\nOptional name of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema name.\n      */\n            schemaName?: string;\n\n            /**\nOptional description of the output that should be generated.\nUsed by some providers for additional LLM guidance, e.g.\nvia tool or schema description.\n      */\n            schemaDescription?: string;\n          }) & {\n      output?: OUTPUT;\n\n      /**\nThe language model to use.\n     */\n      model: LanguageModel;\n\n      /**\nA function that attempts to repair the raw output of the model\nto enable JSON parsing.\n       */\n      experimental_repairText?: RepairTextFunction;\n\n      /**\nOptional telemetry configuration (experimental).\n       */\n\n      experimental_telemetry?: TelemetrySettings;\n\n      /**\n  Custom download function to use for URLs.\n\n  By default, files are downloaded if the model does not support the URL for the given media type.\n       */\n      experimental_download?: DownloadFunction | undefined;\n\n      /**\nAdditional provider-specific options. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n      providerOptions?: ProviderOptions;\n\n      /**\nCallback that is invoked when an error occurs during streaming.\nYou can use it to log errors.\nThe stream processing will pause until the callback promise is resolved.\n     */\n      onError?: StreamObjectOnErrorCallback;\n\n      /**\nCallback that is called when the LLM response and the final object validation are finished.\n*/\n      onFinish?: StreamObjectOnFinishCallback<RESULT>;\n\n      /**\n       * Internal. For test use only. May change without notice.\n       */\n      _internal?: {\n        generateId?: () => string;\n        currentDate?: () => Date;\n        now?: () => number;\n      };\n    },\n): StreamObjectResult<\n  OUTPUT extends 'enum'\n    ? string\n    : OUTPUT extends 'array'\n      ? RESULT\n      : DeepPartial<RESULT>,\n  OUTPUT extends 'array' ? RESULT : RESULT,\n  OUTPUT extends 'array'\n    ? RESULT extends Array<infer U>\n      ? AsyncIterableStream<U>\n      : never\n    : never\n> {\n  const {\n    model,\n    output = 'object',\n    system,\n    prompt,\n    messages,\n    maxRetries,\n    abortSignal,\n    headers,\n    experimental_repairText: repairText,\n    experimental_telemetry: telemetry,\n    experimental_download: download,\n    providerOptions,\n    onError = ({ error }: { error: unknown }) => {\n      console.error(error);\n    },\n    onFinish,\n    _internal: {\n      generateId = originalGenerateId,\n      currentDate = () => new Date(),\n      now = originalNow,\n    } = {},\n    ...settings\n  } = options;\n\n  const enumValues =\n    'enum' in options && options.enum ? options.enum : undefined;\n\n  const {\n    schema: inputSchema,\n    schemaDescription,\n    schemaName,\n  } = 'schema' in options ? options : {};\n\n  validateObjectGenerationInput({\n    output,\n    schema: inputSchema,\n    schemaName,\n    schemaDescription,\n    enumValues,\n  });\n\n  const outputStrategy = getOutputStrategy({\n    output,\n    schema: inputSchema,\n    enumValues,\n  });\n\n  return new DefaultStreamObjectResult({\n    model,\n    telemetry,\n    headers,\n    settings,\n    maxRetries,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download,\n    generateId,\n    currentDate,\n    now,\n  });\n}\n\nclass DefaultStreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n  implements StreamObjectResult<PARTIAL, RESULT, ELEMENT_STREAM>\n{\n  private readonly _object = new DelayedPromise<RESULT>();\n  private readonly _usage = new DelayedPromise<LanguageModelUsage>();\n  private readonly _providerMetadata = new DelayedPromise<\n    ProviderMetadata | undefined\n  >();\n  private readonly _warnings = new DelayedPromise<CallWarning[] | undefined>();\n  private readonly _request =\n    new DelayedPromise<LanguageModelRequestMetadata>();\n  private readonly _response =\n    new DelayedPromise<LanguageModelResponseMetadata>();\n  private readonly _finishReason = new DelayedPromise<FinishReason>();\n\n  private readonly baseStream: ReadableStream<ObjectStreamPart<PARTIAL>>;\n\n  private readonly outputStrategy: OutputStrategy<\n    PARTIAL,\n    RESULT,\n    ELEMENT_STREAM\n  >;\n\n  constructor({\n    model: modelArg,\n    headers,\n    telemetry,\n    settings,\n    maxRetries: maxRetriesArg,\n    abortSignal,\n    outputStrategy,\n    system,\n    prompt,\n    messages,\n    schemaName,\n    schemaDescription,\n    providerOptions,\n    repairText,\n    onError,\n    onFinish,\n    download,\n    generateId,\n    currentDate,\n    now,\n  }: {\n    model: LanguageModel;\n    telemetry: TelemetrySettings | undefined;\n    headers: Record<string, string | undefined> | undefined;\n    settings: Omit<CallSettings, 'abortSignal' | 'headers'>;\n    maxRetries: number | undefined;\n    abortSignal: AbortSignal | undefined;\n    outputStrategy: OutputStrategy<PARTIAL, RESULT, ELEMENT_STREAM>;\n    system: Prompt['system'];\n    prompt: Prompt['prompt'];\n    messages: Prompt['messages'];\n    schemaName: string | undefined;\n    schemaDescription: string | undefined;\n    providerOptions: ProviderOptions | undefined;\n    repairText: RepairTextFunction | undefined;\n    onError: StreamObjectOnErrorCallback;\n    onFinish: StreamObjectOnFinishCallback<RESULT> | undefined;\n    download: DownloadFunction | undefined;\n    generateId: () => string;\n    currentDate: () => Date;\n    now: () => number;\n  }) {\n    const model = resolveLanguageModel(modelArg);\n\n    const { maxRetries, retry } = prepareRetries({\n      maxRetries: maxRetriesArg,\n      abortSignal,\n    });\n\n    const callSettings = prepareCallSettings(settings);\n\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n      model,\n      telemetry,\n      headers,\n      settings: { ...callSettings, maxRetries },\n    });\n\n    const tracer = getTracer(telemetry);\n    const self = this;\n\n    const stitchableStream =\n      createStitchableStream<ObjectStreamPart<PARTIAL>>();\n\n    const eventProcessor = new TransformStream<\n      ObjectStreamPart<PARTIAL>,\n      ObjectStreamPart<PARTIAL>\n    >({\n      transform(chunk, controller) {\n        controller.enqueue(chunk);\n\n        if (chunk.type === 'error') {\n          onError({ error: wrapGatewayError(chunk.error) });\n        }\n      },\n    });\n\n    this.baseStream = stitchableStream.stream.pipeThrough(eventProcessor);\n\n    recordSpan({\n      name: 'ai.streamObject',\n      attributes: selectTelemetryAttributes({\n        telemetry,\n        attributes: {\n          ...assembleOperationName({\n            operationId: 'ai.streamObject',\n            telemetry,\n          }),\n          ...baseTelemetryAttributes,\n          // specific settings that only make sense on the outer level:\n          'ai.prompt': {\n            input: () => JSON.stringify({ system, prompt, messages }),\n          },\n          'ai.schema': {\n            input: async () =>\n              JSON.stringify(await outputStrategy.jsonSchema()),\n          },\n          'ai.schema.name': schemaName,\n          'ai.schema.description': schemaDescription,\n          'ai.settings.output': outputStrategy.type,\n        },\n      }),\n      tracer,\n      endWhenDone: false,\n      fn: async rootSpan => {\n        const standardizedPrompt = await standardizePrompt({\n          system,\n          prompt,\n          messages,\n        } as Prompt);\n\n        const callOptions = {\n          responseFormat: {\n            type: 'json' as const,\n            schema: await outputStrategy.jsonSchema(),\n            name: schemaName,\n            description: schemaDescription,\n          },\n          ...prepareCallSettings(settings),\n          prompt: await convertToLanguageModelPrompt({\n            prompt: standardizedPrompt,\n            supportedUrls: await model.supportedUrls,\n            download,\n          }),\n          providerOptions,\n          abortSignal,\n          headers,\n          includeRawChunks: false,\n        };\n\n        const transformer: Transformer<\n          LanguageModelV3StreamPart,\n          ObjectStreamInputPart\n        > = {\n          transform: (chunk, controller) => {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.delta);\n                break;\n              case 'response-metadata':\n              case 'finish':\n              case 'error':\n              case 'stream-start':\n                controller.enqueue(chunk);\n                break;\n            }\n          },\n        };\n\n        const {\n          result: { stream, response, request },\n          doStreamSpan,\n          startTimestampMs,\n        } = await retry(() =>\n          recordSpan({\n            name: 'ai.streamObject.doStream',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.streamObject.doStream',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                'ai.prompt.messages': {\n                  input: () => stringifyForTelemetry(callOptions.prompt),\n                },\n\n                // standardized gen-ai llm span attributes:\n                'gen_ai.system': model.provider,\n                'gen_ai.request.model': model.modelId,\n                'gen_ai.request.frequency_penalty':\n                  callSettings.frequencyPenalty,\n                'gen_ai.request.max_tokens': callSettings.maxOutputTokens,\n                'gen_ai.request.presence_penalty': callSettings.presencePenalty,\n                'gen_ai.request.temperature': callSettings.temperature,\n                'gen_ai.request.top_k': callSettings.topK,\n                'gen_ai.request.top_p': callSettings.topP,\n              },\n            }),\n            tracer,\n            endWhenDone: false,\n            fn: async doStreamSpan => ({\n              startTimestampMs: now(),\n              doStreamSpan,\n              result: await model.doStream(callOptions),\n            }),\n          }),\n        );\n\n        self._request.resolve(request ?? {});\n\n        // store information for onFinish callback:\n        let warnings: SharedV3Warning[] | undefined;\n        let usage: LanguageModelUsage = createNullLanguageModelUsage();\n        let finishReason: FinishReason | undefined;\n        let providerMetadata: ProviderMetadata | undefined;\n        let object: RESULT | undefined;\n        let error: unknown | undefined;\n\n        // pipe chunks through a transformation stream that extracts metadata:\n        let accumulatedText = '';\n        let textDelta = '';\n        let fullResponse: {\n          id: string;\n          timestamp: Date;\n          modelId: string;\n        } = {\n          id: generateId(),\n          timestamp: currentDate(),\n          modelId: model.modelId,\n        };\n\n        // Keep track of raw parse result before type validation, since e.g. Zod might\n        // change the object by mapping properties.\n        let latestObjectJson: JSONValue | undefined = undefined;\n        let latestObject: PARTIAL | undefined = undefined;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n\n        const transformedStream = stream\n          .pipeThrough(new TransformStream(transformer))\n          .pipeThrough(\n            new TransformStream<\n              string | ObjectStreamInputPart,\n              ObjectStreamPart<PARTIAL>\n            >({\n              async transform(chunk, controller): Promise<void> {\n                if (\n                  typeof chunk === 'object' &&\n                  chunk.type === 'stream-start'\n                ) {\n                  warnings = chunk.warnings;\n                  return; // stream start chunks are sent immediately and do not count as first chunk\n                }\n\n                // Telemetry event for first chunk:\n                if (isFirstChunk) {\n                  const msToFirstChunk = now() - startTimestampMs;\n\n                  isFirstChunk = false;\n\n                  doStreamSpan.addEvent('ai.stream.firstChunk', {\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n\n                  doStreamSpan.setAttributes({\n                    'ai.stream.msToFirstChunk': msToFirstChunk,\n                  });\n                }\n\n                // process partial text chunks\n                if (typeof chunk === 'string') {\n                  accumulatedText += chunk;\n                  textDelta += chunk;\n\n                  const { value: currentObjectJson, state: parseState } =\n                    await parsePartialJson(accumulatedText);\n\n                  if (\n                    currentObjectJson !== undefined &&\n                    !isDeepEqualData(latestObjectJson, currentObjectJson)\n                  ) {\n                    const validationResult =\n                      await outputStrategy.validatePartialResult({\n                        value: currentObjectJson,\n                        textDelta,\n                        latestObject,\n                        isFirstDelta,\n                        isFinalDelta: parseState === 'successful-parse',\n                      });\n\n                    if (\n                      validationResult.success &&\n                      !isDeepEqualData(\n                        latestObject,\n                        validationResult.value.partial,\n                      )\n                    ) {\n                      // inside inner check to correctly parse the final element in array mode:\n                      latestObjectJson = currentObjectJson;\n                      latestObject = validationResult.value.partial;\n\n                      controller.enqueue({\n                        type: 'object',\n                        object: latestObject,\n                      });\n\n                      controller.enqueue({\n                        type: 'text-delta',\n                        textDelta: validationResult.value.textDelta,\n                      });\n\n                      textDelta = '';\n                      isFirstDelta = false;\n                    }\n                  }\n\n                  return;\n                }\n\n                switch (chunk.type) {\n                  case 'response-metadata': {\n                    fullResponse = {\n                      id: chunk.id ?? fullResponse.id,\n                      timestamp: chunk.timestamp ?? fullResponse.timestamp,\n                      modelId: chunk.modelId ?? fullResponse.modelId,\n                    };\n                    break;\n                  }\n\n                  case 'finish': {\n                    // send final text delta:\n                    if (textDelta !== '') {\n                      controller.enqueue({ type: 'text-delta', textDelta });\n                    }\n\n                    // store finish reason for telemetry:\n                    finishReason = chunk.finishReason.unified;\n\n                    // store usage and metadata for promises and onFinish callback:\n                    usage = asLanguageModelUsage(chunk.usage);\n                    providerMetadata = chunk.providerMetadata;\n\n                    controller.enqueue({\n                      ...chunk,\n                      finishReason: chunk.finishReason.unified,\n                      usage,\n                      response: fullResponse,\n                    });\n\n                    // log warnings:\n                    logWarnings({\n                      warnings: warnings ?? [],\n                      provider: model.provider,\n                      model: model.modelId,\n                    });\n\n                    // resolve promises that can be resolved now:\n                    self._usage.resolve(usage);\n                    self._providerMetadata.resolve(providerMetadata);\n                    self._warnings.resolve(warnings);\n                    self._response.resolve({\n                      ...fullResponse,\n                      headers: response?.headers,\n                    });\n                    self._finishReason.resolve(finishReason ?? 'other');\n\n                    try {\n                      object = await parseAndValidateObjectResultWithRepair(\n                        accumulatedText,\n                        outputStrategy,\n                        repairText,\n                        {\n                          response: fullResponse,\n                          usage,\n                          finishReason,\n                        },\n                      );\n                      self._object.resolve(object);\n                    } catch (e) {\n                      error = e;\n                      self._object.reject(e);\n                    }\n                    break;\n                  }\n\n                  default: {\n                    controller.enqueue(chunk);\n                    break;\n                  }\n                }\n              },\n\n              // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n              async flush(controller) {\n                try {\n                  const finalUsage = usage ?? {\n                    promptTokens: NaN,\n                    completionTokens: NaN,\n                    totalTokens: NaN,\n                  };\n\n                  doStreamSpan.setAttributes(\n                    await selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.response.finishReason': finishReason,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.id': fullResponse.id,\n                        'ai.response.model': fullResponse.modelId,\n                        'ai.response.timestamp':\n                          fullResponse.timestamp.toISOString(),\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n\n                        'ai.usage.inputTokens': finalUsage.inputTokens,\n                        'ai.usage.outputTokens': finalUsage.outputTokens,\n                        'ai.usage.totalTokens': finalUsage.totalTokens,\n                        'ai.usage.reasoningTokens': finalUsage.reasoningTokens,\n                        'ai.usage.cachedInputTokens':\n                          finalUsage.cachedInputTokens,\n\n                        // standardized gen-ai llm span attributes:\n                        'gen_ai.response.finish_reasons': [finishReason],\n                        'gen_ai.response.id': fullResponse.id,\n                        'gen_ai.response.model': fullResponse.modelId,\n                        'gen_ai.usage.input_tokens': finalUsage.inputTokens,\n                        'gen_ai.usage.output_tokens': finalUsage.outputTokens,\n                      },\n                    }),\n                  );\n\n                  // finish doStreamSpan before other operations for correct timing:\n                  doStreamSpan.end();\n\n                  // Add response information to the root span:\n                  rootSpan.setAttributes(\n                    await selectTelemetryAttributes({\n                      telemetry,\n                      attributes: {\n                        'ai.usage.inputTokens': finalUsage.inputTokens,\n                        'ai.usage.outputTokens': finalUsage.outputTokens,\n                        'ai.usage.totalTokens': finalUsage.totalTokens,\n                        'ai.usage.reasoningTokens': finalUsage.reasoningTokens,\n                        'ai.usage.cachedInputTokens':\n                          finalUsage.cachedInputTokens,\n                        'ai.response.object': {\n                          output: () => JSON.stringify(object),\n                        },\n                        'ai.response.providerMetadata':\n                          JSON.stringify(providerMetadata),\n                      },\n                    }),\n                  );\n\n                  // call onFinish callback:\n                  await onFinish?.({\n                    usage: finalUsage,\n                    object,\n                    error,\n                    response: {\n                      ...fullResponse,\n                      headers: response?.headers,\n                    },\n                    warnings,\n                    providerMetadata,\n                  });\n                } catch (error) {\n                  controller.enqueue({ type: 'error', error });\n                } finally {\n                  rootSpan.end();\n                }\n              },\n            }),\n          );\n\n        stitchableStream.addStream(transformedStream);\n      },\n    })\n      .catch(error => {\n        // add an empty stream with an error to break the stream:\n        stitchableStream.addStream(\n          new ReadableStream({\n            start(controller) {\n              controller.enqueue({ type: 'error', error });\n              controller.close();\n            },\n          }),\n        );\n      })\n      .finally(() => {\n        stitchableStream.close();\n      });\n\n    this.outputStrategy = outputStrategy;\n  }\n\n  get object() {\n    return this._object.promise;\n  }\n\n  get usage() {\n    return this._usage.promise;\n  }\n\n  get providerMetadata() {\n    return this._providerMetadata.promise;\n  }\n\n  get warnings() {\n    return this._warnings.promise;\n  }\n\n  get request() {\n    return this._request.promise;\n  }\n\n  get response() {\n    return this._response.promise;\n  }\n\n  get finishReason() {\n    return this._finishReason.promise;\n  }\n\n  get partialObjectStream(): AsyncIterableStream<PARTIAL> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, PARTIAL>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'object':\n                controller.enqueue(chunk.object);\n                break;\n\n              case 'text-delta':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get elementStream(): ELEMENT_STREAM {\n    return this.outputStrategy.createElementStream(this.baseStream);\n  }\n\n  get textStream(): AsyncIterableStream<string> {\n    return createAsyncIterableStream(\n      this.baseStream.pipeThrough(\n        new TransformStream<ObjectStreamPart<PARTIAL>, string>({\n          transform(chunk, controller) {\n            switch (chunk.type) {\n              case 'text-delta':\n                controller.enqueue(chunk.textDelta);\n                break;\n\n              case 'object':\n              case 'finish':\n              case 'error': // suppress error (use onError instead)\n                break;\n\n              default: {\n                const _exhaustiveCheck: never = chunk;\n                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n              }\n            }\n          },\n        }),\n      ),\n    );\n  }\n\n  get fullStream(): AsyncIterableStream<ObjectStreamPart<PARTIAL>> {\n    return createAsyncIterableStream(this.baseStream);\n  }\n\n  pipeTextStreamToResponse(response: ServerResponse, init?: ResponseInit) {\n    pipeTextStreamToResponse({\n      response,\n      textStream: this.textStream,\n      ...init,\n    });\n  }\n\n  toTextStreamResponse(init?: ResponseInit): Response {\n    return createTextStreamResponse({\n      textStream: this.textStream,\n      ...init,\n    });\n  }\n}\n\nexport type ObjectStreamInputPart =\n  | string\n  | {\n      type: 'stream-start';\n      warnings: SharedV3Warning[];\n    }\n  | {\n      type: 'error';\n      error: unknown;\n    }\n  | {\n      type: 'response-metadata';\n      id?: string;\n      timestamp?: Date;\n      modelId?: string;\n    }\n  | {\n      type: 'finish';\n      finishReason: LanguageModelV3FinishReason;\n      usage: LanguageModelV3Usage;\n      providerMetadata?: SharedV3ProviderMetadata;\n    };\n","import { InvalidArgumentError } from '../error/invalid-argument-error';\n\n/**\n * Calculates the cosine similarity between two vectors. This is a useful metric for\n * comparing the similarity of two vectors such as embeddings.\n *\n * @param vector1 - The first vector.\n * @param vector2 - The second vector.\n *\n * @returns The cosine similarity between vector1 and vector2.\n * @returns 0 if either vector is the zero vector.\n *\n * @throws {InvalidArgumentError} If the vectors do not have the same length.\n */\nexport function cosineSimilarity(vector1: number[], vector2: number[]): number {\n  if (vector1.length !== vector2.length) {\n    throw new InvalidArgumentError({\n      parameter: 'vector1,vector2',\n      value: { vector1Length: vector1.length, vector2Length: vector2.length },\n      message: `Vectors must have the same length`,\n    });\n  }\n\n  const n = vector1.length;\n\n  if (n === 0) {\n    return 0; // Return 0 for empty vectors if no error is thrown\n  }\n\n  let magnitudeSquared1 = 0;\n  let magnitudeSquared2 = 0;\n  let dotProduct = 0;\n\n  for (let i = 0; i < n; i++) {\n    const value1 = vector1[i];\n    const value2 = vector2[i];\n\n    magnitudeSquared1 += value1 * value1;\n    magnitudeSquared2 += value2 * value2;\n    dotProduct += value1 * value2;\n  }\n\n  return magnitudeSquared1 === 0 || magnitudeSquared2 === 0\n    ? 0\n    : dotProduct /\n        (Math.sqrt(magnitudeSquared1) * Math.sqrt(magnitudeSquared2));\n}\n","/**\n * Converts a data URL of type text/* to a text string.\n */\nexport function getTextFromDataUrl(dataUrl: string): string {\n  const [header, base64Content] = dataUrl.split(',');\n  const mediaType = header.split(';')[0].split(':')[1];\n\n  if (mediaType == null || base64Content == null) {\n    throw new Error('Invalid data URL format');\n  }\n\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n","/**\n * Performs a deep-equal comparison of two parsed JSON objects.\n *\n * @param {any} obj1 - The first object to compare.\n * @param {any} obj2 - The second object to compare.\n * @returns {boolean} - Returns true if the two objects are deeply equal, false otherwise.\n */\nexport function isDeepEqualData(obj1: any, obj2: any): boolean {\n  // Check for strict equality first\n  if (obj1 === obj2) return true;\n\n  // Check if either is null or undefined\n  if (obj1 == null || obj2 == null) return false;\n\n  // Check if both are objects\n  if (typeof obj1 !== 'object' && typeof obj2 !== 'object')\n    return obj1 === obj2;\n\n  // If they are not strictly equal, they both need to be Objects\n  if (obj1.constructor !== obj2.constructor) return false;\n\n  // Special handling for Date objects\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n\n  // Handle arrays: compare length and then perform a recursive deep comparison on each item\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length) return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n    }\n    return true; // All array elements matched\n  }\n\n  // Compare the set of keys in each object\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length) return false;\n\n  // Check each key-value pair recursively\n  for (const key of keys1) {\n    if (!keys2.includes(key)) return false;\n    if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n  }\n\n  return true; // All keys and values matched\n}\n","import { Job } from './job';\n\nexport class SerialJobExecutor {\n  private queue: Array<Job> = [];\n  private isProcessing = false;\n\n  private async processQueue() {\n    if (this.isProcessing) {\n      return;\n    }\n\n    this.isProcessing = true;\n\n    while (this.queue.length > 0) {\n      await this.queue[0]();\n      this.queue.shift();\n    }\n\n    this.isProcessing = false;\n  }\n\n  async run(job: Job): Promise<void> {\n    return new Promise<void>((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          await job();\n          resolve();\n        } catch (error) {\n          reject(error);\n        }\n      });\n\n      void this.processQueue();\n    });\n  }\n}\n","import { delay as delayFunction } from '@ai-sdk/provider-utils';\n\n/**\n * Creates a ReadableStream that emits the provided values with an optional delay between each value.\n *\n * @param options - The configuration options\n * @param options.chunks - Array of values to be emitted by the stream\n * @param options.initialDelayInMs - Optional initial delay in milliseconds before emitting the first value (default: 0). Can be set to `null` to skip the initial delay. The difference between `initialDelayInMs: null` and `initialDelayInMs: 0` is that `initialDelayInMs: null` will emit the values without any delay, while `initialDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @param options.chunkDelayInMs - Optional delay in milliseconds between emitting each value (default: 0). Can be set to `null` to skip the delay. The difference between `chunkDelayInMs: null` and `chunkDelayInMs: 0` is that `chunkDelayInMs: null` will emit the values without any delay, while `chunkDelayInMs: 0` will emit the values with a delay of 0 milliseconds.\n * @returns A ReadableStream that emits the provided values\n */\nexport function simulateReadableStream<T>({\n  chunks,\n  initialDelayInMs = 0,\n  chunkDelayInMs = 0,\n  _internal,\n}: {\n  chunks: T[];\n  initialDelayInMs?: number | null;\n  chunkDelayInMs?: number | null;\n  _internal?: {\n    delay?: (ms: number | null) => Promise<void>;\n  };\n}): ReadableStream<T> {\n  const delay = _internal?.delay ?? delayFunction;\n\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        await delay(index === 0 ? initialDelayInMs : chunkDelayInMs);\n        controller.enqueue(chunks[index++]);\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n","import { JSONObject } from '@ai-sdk/provider';\nimport { ProviderOptions, withUserAgentSuffix } from '@ai-sdk/provider-utils';\nimport { NoSpeechGeneratedError } from '../error/no-speech-generated-error';\nimport { logWarnings } from '../logger/log-warnings';\nimport { resolveSpeechModel } from '../model/resolve-model';\nimport { SpeechModel } from '../types/speech-model';\nimport { SpeechModelResponseMetadata } from '../types/speech-model-response-metadata';\nimport { Warning } from '../types/warning';\nimport {\n  audioMediaTypeSignatures,\n  detectMediaType,\n} from '../util/detect-media-type';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { VERSION } from '../version';\nimport { SpeechResult } from './generate-speech-result';\nimport {\n  DefaultGeneratedAudioFile,\n  GeneratedAudioFile,\n} from './generated-audio-file';\n\n/**\nGenerates speech audio using a speech model.\n\n@param model - The speech model to use.\n@param text - The text to convert to speech.\n@param voice - The voice to use for speech generation.\n@param outputFormat - The output format to use for speech generation e.g. \"mp3\", \"wav\", etc.\n@param instructions - Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n@param speed - The speed of the speech generation.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated audio data.\n */\nexport async function generateSpeech({\n  model,\n  text,\n  voice,\n  outputFormat,\n  instructions,\n  speed,\n  language,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe speech model to use.\n     */\n  model: SpeechModel;\n\n  /**\nThe text to convert to speech.\n   */\n  text: string;\n\n  /**\nThe voice to use for speech generation.\n   */\n  voice?: string;\n\n  /**\n   * The desired output format for the audio e.g. \"mp3\", \"wav\", etc.\n   */\n  outputFormat?: 'mp3' | 'wav' | (string & {});\n\n  /**\n    Instructions for the speech generation e.g. \"Speak in a slow and steady tone\".\n  */\n  instructions?: string;\n\n  /**\n  The speed of the speech generation.\n   */\n  speed?: number;\n\n  /**\n  The language for speech generation. This should be an ISO 639-1 language code (e.g. \"en\", \"es\", \"fr\")\n  or \"auto\" for automatic language detection. Provider support varies.\n   */\n  language?: string;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {}\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per speech model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<SpeechResult> {\n  const resolvedModel = resolveSpeechModel(model);\n  if (!resolvedModel) {\n    throw new Error('Model could not be resolved');\n  }\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const result = await retry(() =>\n    resolvedModel.doGenerate({\n      text,\n      voice,\n      outputFormat,\n      instructions,\n      speed,\n      language,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions,\n    }),\n  );\n\n  if (!result.audio || result.audio.length === 0) {\n    throw new NoSpeechGeneratedError({ responses: [result.response] });\n  }\n\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId,\n  });\n\n  return new DefaultSpeechResult({\n    audio: new DefaultGeneratedAudioFile({\n      data: result.audio,\n      mediaType:\n        detectMediaType({\n          data: result.audio,\n          signatures: audioMediaTypeSignatures,\n        }) ?? 'audio/mp3',\n    }),\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultSpeechResult implements SpeechResult {\n  readonly audio: GeneratedAudioFile;\n  readonly warnings: Array<Warning>;\n  readonly responses: Array<SpeechModelResponseMetadata>;\n  readonly providerMetadata: Record<string, JSONObject>;\n\n  constructor(options: {\n    audio: GeneratedAudioFile;\n    warnings: Array<Warning>;\n    responses: Array<SpeechModelResponseMetadata>;\n    providerMetadata: Record<string, JSONObject> | undefined;\n  }) {\n    this.audio = options.audio;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n","import {\n  GeneratedFile,\n  DefaultGeneratedFile,\n} from '../generate-text/generated-file';\n\n/**\n * A generated audio file.\n */\nexport interface GeneratedAudioFile extends GeneratedFile {\n  /**\n   * Audio format of the file (e.g., 'mp3', 'wav', etc.)\n   */\n  readonly format: string;\n}\n\nexport class DefaultGeneratedAudioFile\n  extends DefaultGeneratedFile\n  implements GeneratedAudioFile\n{\n  readonly format: string;\n\n  constructor({\n    data,\n    mediaType,\n  }: {\n    data: string | Uint8Array;\n    mediaType: string;\n  }) {\n    super({ data, mediaType });\n    let format = 'mp3';\n\n    // If format is not provided, try to determine it from the media type\n    if (mediaType) {\n      const mediaTypeParts = mediaType.split('/');\n\n      if (mediaTypeParts.length === 2) {\n        // Handle special cases for audio formats\n        if (mediaType !== 'audio/mpeg') {\n          format = mediaTypeParts[1];\n        }\n      }\n    }\n\n    if (!format) {\n      // TODO this should be an AI SDK error\n      throw new Error(\n        'Audio format must be provided or determinable from media type',\n      );\n    }\n\n    this.format = format;\n  }\n}\n\nexport class DefaultGeneratedAudioFileWithType extends DefaultGeneratedAudioFile {\n  readonly type = 'audio';\n\n  constructor(options: {\n    data: string | Uint8Array;\n    mediaType: string;\n    format: string;\n  }) {\n    super(options);\n  }\n}\n","import {\n  AssistantModelMessage,\n  ModelMessage,\n  ToolModelMessage,\n} from '@ai-sdk/provider-utils';\n\n/**\n * Prunes model messages from a list of model messages.\n *\n * @param messages - The list of model messages to prune.\n * @param reasoning - How to remove reasoning content from assistant messages. Default is `'none'`.\n * @param toolCalls - How to prune tool call/results/approval content. Default is `[]`.\n * @param emptyMessages - Whether to keep or remove messages whose content is empty after pruning. Default is `'remove'`.\n *\n * @returns The pruned list of model messages.\n */\nexport function pruneMessages({\n  messages,\n  reasoning = 'none',\n  toolCalls = [],\n  emptyMessages = 'remove',\n}: {\n  messages: ModelMessage[];\n  reasoning?: 'all' | 'before-last-message' | 'none';\n  toolCalls?:\n    | 'all'\n    | 'before-last-message'\n    | `before-last-${number}-messages`\n    | 'none'\n    | Array<{\n        type: 'all' | 'before-last-message' | `before-last-${number}-messages`;\n        tools?: string[];\n      }>;\n  emptyMessages?: 'keep' | 'remove';\n}): ModelMessage[] {\n  // filter reasoning parts:\n  if (reasoning === 'all' || reasoning === 'before-last-message') {\n    messages = messages.map((message, messageIndex) => {\n      if (\n        message.role !== 'assistant' ||\n        typeof message.content === 'string' ||\n        (reasoning === 'before-last-message' &&\n          messageIndex === messages.length - 1)\n      ) {\n        return message;\n      }\n\n      return {\n        ...message,\n        content: message.content.filter(part => part.type !== 'reasoning'),\n      };\n    });\n  }\n\n  // filter tool calls, results, errors, and approvals:\n  if (toolCalls === 'none') {\n    toolCalls = [];\n  } else if (toolCalls === 'all') {\n    toolCalls = [{ type: 'all' }];\n  } else if (toolCalls === 'before-last-message') {\n    toolCalls = [{ type: 'before-last-message' }];\n  } else if (typeof toolCalls === 'string') {\n    toolCalls = [{ type: toolCalls }];\n  }\n\n  for (const toolCall of toolCalls) {\n    // determine how many trailing messages to keep:\n    const keepLastMessagesCount =\n      toolCall.type === 'all'\n        ? undefined\n        : toolCall.type === 'before-last-message'\n          ? 1\n          : Number(\n              toolCall.type\n                .slice('before-last-'.length)\n                .slice(0, -'-messages'.length),\n            );\n\n    // scan kept messages to identify tool calls and approvals that need to be kept:\n    const keptToolCallIds: Set<string> = new Set();\n    const keptApprovalIds: Set<string> = new Set();\n\n    if (keepLastMessagesCount != null) {\n      for (const message of messages.slice(-keepLastMessagesCount)) {\n        if (\n          (message.role === 'assistant' || message.role === 'tool') &&\n          typeof message.content !== 'string'\n        ) {\n          for (const part of message.content) {\n            if (part.type === 'tool-call' || part.type === 'tool-result') {\n              keptToolCallIds.add(part.toolCallId);\n            } else if (\n              part.type === 'tool-approval-request' ||\n              part.type === 'tool-approval-response'\n            ) {\n              keptApprovalIds.add(part.approvalId);\n            }\n          }\n        }\n      }\n    }\n\n    messages = messages.map((message, messageIndex) => {\n      if (\n        (message.role !== 'assistant' && message.role !== 'tool') ||\n        typeof message.content === 'string' ||\n        (keepLastMessagesCount &&\n          messageIndex >= messages.length - keepLastMessagesCount)\n      ) {\n        return message;\n      }\n\n      const toolCallIdToToolName: Record<string, string> = {};\n      const approvalIdToToolName: Record<string, string> = {};\n\n      return {\n        ...message,\n        content: message.content.filter(part => {\n          // keep non-tool parts:\n          if (\n            part.type !== 'tool-call' &&\n            part.type !== 'tool-result' &&\n            part.type !== 'tool-approval-request' &&\n            part.type !== 'tool-approval-response'\n          ) {\n            return true;\n          }\n\n          // track tool calls and approvals:\n          if (part.type === 'tool-call') {\n            toolCallIdToToolName[part.toolCallId] = part.toolName;\n          } else if (part.type === 'tool-approval-request') {\n            approvalIdToToolName[part.approvalId] =\n              toolCallIdToToolName[part.toolCallId];\n          }\n\n          // keep parts that are associated with a tool call or approval that needs to be kept:\n          if (\n            ((part.type === 'tool-call' || part.type === 'tool-result') &&\n              keptToolCallIds.has(part.toolCallId)) ||\n            ((part.type === 'tool-approval-request' ||\n              part.type === 'tool-approval-response') &&\n              keptApprovalIds.has(part.approvalId))\n          ) {\n            return true;\n          }\n\n          // keep parts that are not associated with a tool that should be removed:\n          return (\n            toolCall.tools != null &&\n            !toolCall.tools.includes(\n              part.type === 'tool-call' || part.type === 'tool-result'\n                ? part.toolName\n                : approvalIdToToolName[part.approvalId],\n            )\n          );\n        }),\n      } as AssistantModelMessage | ToolModelMessage;\n    });\n  }\n\n  if (emptyMessages === 'remove') {\n    messages = messages.filter(message => message.content.length > 0);\n  }\n\n  return messages;\n}\n","import { delay as originalDelay } from '@ai-sdk/provider-utils';\nimport { TextStreamPart } from './stream-text-result';\nimport { ToolSet } from './tool-set';\nimport { InvalidArgumentError } from '@ai-sdk/provider';\n\nconst CHUNKING_REGEXPS = {\n  word: /\\S+\\s+/m,\n  line: /\\n+/m,\n};\n\n/**\n * Detects the first chunk in a buffer.\n *\n * @param buffer - The buffer to detect the first chunk in.\n *\n * @returns The first detected chunk, or `undefined` if no chunk was detected.\n */\nexport type ChunkDetector = (buffer: string) => string | undefined | null;\n\n/**\n * Smooths text streaming output.\n *\n * @param delayInMs - The delay in milliseconds between each chunk. Defaults to 10ms. Can be set to `null` to skip the delay.\n * @param chunking - Controls how the text is chunked for streaming. Use \"word\" to stream word by word (default), \"line\" to stream line by line, or provide a custom RegExp pattern for custom chunking.\n *\n * @returns A transform stream that smooths text streaming output.\n */\nexport function smoothStream<TOOLS extends ToolSet>({\n  delayInMs = 10,\n  chunking = 'word',\n  _internal: { delay = originalDelay } = {},\n}: {\n  delayInMs?: number | null;\n  chunking?: 'word' | 'line' | RegExp | ChunkDetector;\n  /**\n   * Internal. For test use only. May change without notice.\n   */\n  _internal?: {\n    delay?: (delayInMs: number | null) => Promise<void>;\n  };\n} = {}): (options: {\n  tools: TOOLS;\n}) => TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>> {\n  let detectChunk: ChunkDetector;\n\n  if (typeof chunking === 'function') {\n    detectChunk = buffer => {\n      const match = chunking(buffer);\n\n      if (match == null) {\n        return null;\n      }\n\n      if (!match.length) {\n        throw new Error(`Chunking function must return a non-empty string.`);\n      }\n\n      if (!buffer.startsWith(match)) {\n        throw new Error(\n          `Chunking function must return a match that is a prefix of the buffer. Received: \"${match}\" expected to start with \"${buffer}\"`,\n        );\n      }\n\n      return match;\n    };\n  } else {\n    const chunkingRegex =\n      typeof chunking === 'string' ? CHUNKING_REGEXPS[chunking] : chunking;\n\n    if (chunkingRegex == null) {\n      throw new InvalidArgumentError({\n        argument: 'chunking',\n        message: `Chunking must be \"word\" or \"line\" or a RegExp. Received: ${chunking}`,\n      });\n    }\n\n    detectChunk = buffer => {\n      const match = chunkingRegex.exec(buffer);\n\n      if (!match) {\n        return null;\n      }\n\n      return buffer.slice(0, match.index) + match?.[0];\n    };\n  }\n\n  return () => {\n    let buffer = '';\n    let id = '';\n\n    return new TransformStream<TextStreamPart<TOOLS>, TextStreamPart<TOOLS>>({\n      async transform(chunk, controller) {\n        if (chunk.type !== 'text-delta') {\n          if (buffer.length > 0) {\n            controller.enqueue({ type: 'text-delta', text: buffer, id });\n            buffer = '';\n          }\n\n          controller.enqueue(chunk);\n          return;\n        }\n\n        if (chunk.id !== id && buffer.length > 0) {\n          controller.enqueue({ type: 'text-delta', text: buffer, id });\n          buffer = '';\n        }\n\n        buffer += chunk.text;\n        id = chunk.id;\n\n        let match;\n\n        while ((match = detectChunk(buffer)) != null) {\n          controller.enqueue({ type: 'text-delta', text: match, id });\n          buffer = buffer.slice(match.length);\n\n          await delay(delayInMs);\n        }\n      },\n    });\n  };\n}\n","import { EmbeddingModelV3CallOptions } from '@ai-sdk/provider';\nimport { EmbeddingModelMiddleware } from '../types';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a embedding model.\n */\nexport function defaultEmbeddingSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<{\n    headers?: EmbeddingModelV3CallOptions['headers'];\n    providerOptions?: EmbeddingModelV3CallOptions['providerOptions'];\n  }>;\n}): EmbeddingModelMiddleware {\n  return {\n    specificationVersion: 'v3',\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params) as EmbeddingModelV3CallOptions;\n    },\n  };\n}\n","import { LanguageModelV3CallOptions } from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types';\nimport { mergeObjects } from '../util/merge-objects';\n\n/**\n * Applies default settings for a language model.\n */\nexport function defaultSettingsMiddleware({\n  settings,\n}: {\n  settings: Partial<{\n    maxOutputTokens?: LanguageModelV3CallOptions['maxOutputTokens'];\n    temperature?: LanguageModelV3CallOptions['temperature'];\n    stopSequences?: LanguageModelV3CallOptions['stopSequences'];\n    topP?: LanguageModelV3CallOptions['topP'];\n    topK?: LanguageModelV3CallOptions['topK'];\n    presencePenalty?: LanguageModelV3CallOptions['presencePenalty'];\n    frequencyPenalty?: LanguageModelV3CallOptions['frequencyPenalty'];\n    responseFormat?: LanguageModelV3CallOptions['responseFormat'];\n    seed?: LanguageModelV3CallOptions['seed'];\n    tools?: LanguageModelV3CallOptions['tools'];\n    toolChoice?: LanguageModelV3CallOptions['toolChoice'];\n    headers?: LanguageModelV3CallOptions['headers'];\n    providerOptions?: LanguageModelV3CallOptions['providerOptions'];\n  }>;\n}): LanguageModelMiddleware {\n  return {\n    specificationVersion: 'v3',\n    transformParams: async ({ params }) => {\n      return mergeObjects(settings, params) as LanguageModelV3CallOptions;\n    },\n  };\n}\n","/**\n * Returns the index of the start of the searchedText in the text, or null if it\n * is not found.\n */\nexport function getPotentialStartIndex(\n  text: string,\n  searchedText: string,\n): number | null {\n  // Return null immediately if searchedText is empty.\n  if (searchedText.length === 0) {\n    return null;\n  }\n\n  // Check if the searchedText exists as a direct substring of text.\n  const directIndex = text.indexOf(searchedText);\n  if (directIndex !== -1) {\n    return directIndex;\n  }\n\n  // Otherwise, look for the largest suffix of \"text\" that matches\n  // a prefix of \"searchedText\". We go from the end of text inward.\n  for (let i = text.length - 1; i >= 0; i--) {\n    const suffix = text.substring(i);\n    if (searchedText.startsWith(suffix)) {\n      return i;\n    }\n  }\n\n  return null;\n}\n","import type {\n  LanguageModelV3Content,\n  LanguageModelV3StreamPart,\n} from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types/language-model-middleware';\nimport { getPotentialStartIndex } from '../util/get-potential-start-index';\n\n/**\n * Extract an XML-tagged reasoning section from the generated text and exposes it\n * as a `reasoning` property on the result.\n *\n * @param tagName - The name of the XML tag to extract reasoning from.\n * @param separator - The separator to use between reasoning and text sections.\n * @param startWithReasoning - Whether to start with reasoning tokens.\n */\nexport function extractReasoningMiddleware({\n  tagName,\n  separator = '\\n',\n  startWithReasoning = false,\n}: {\n  tagName: string;\n  separator?: string;\n  startWithReasoning?: boolean;\n}): LanguageModelMiddleware {\n  const openingTag = `<${tagName}>`;\n  const closingTag = `<\\/${tagName}>`;\n\n  return {\n    specificationVersion: 'v3',\n    wrapGenerate: async ({ doGenerate }) => {\n      const { content, ...rest } = await doGenerate();\n\n      const transformedContent: LanguageModelV3Content[] = [];\n      for (const part of content) {\n        if (part.type !== 'text') {\n          transformedContent.push(part);\n          continue;\n        }\n\n        const text = startWithReasoning ? openingTag + part.text : part.text;\n\n        const regexp = new RegExp(`${openingTag}(.*?)${closingTag}`, 'gs');\n        const matches = Array.from(text.matchAll(regexp));\n\n        if (!matches.length) {\n          transformedContent.push(part);\n          continue;\n        }\n\n        const reasoningText = matches.map(match => match[1]).join(separator);\n\n        let textWithoutReasoning = text;\n        for (let i = matches.length - 1; i >= 0; i--) {\n          const match = matches[i];\n\n          const beforeMatch = textWithoutReasoning.slice(0, match.index);\n          const afterMatch = textWithoutReasoning.slice(\n            match.index! + match[0].length,\n          );\n\n          textWithoutReasoning =\n            beforeMatch +\n            (beforeMatch.length > 0 && afterMatch.length > 0 ? separator : '') +\n            afterMatch;\n        }\n\n        transformedContent.push({\n          type: 'reasoning',\n          text: reasoningText,\n        });\n\n        transformedContent.push({\n          type: 'text',\n          text: textWithoutReasoning,\n        });\n      }\n\n      return { content: transformedContent, ...rest };\n    },\n\n    wrapStream: async ({ doStream }) => {\n      const { stream, ...rest } = await doStream();\n\n      const reasoningExtractions: Record<\n        string,\n        {\n          isFirstReasoning: boolean;\n          isFirstText: boolean;\n          afterSwitch: boolean;\n          isReasoning: boolean;\n          buffer: string;\n          idCounter: number;\n          textId: string;\n        }\n      > = {};\n\n      let delayedTextStart: LanguageModelV3StreamPart | undefined;\n\n      return {\n        stream: stream.pipeThrough(\n          new TransformStream<\n            LanguageModelV3StreamPart,\n            LanguageModelV3StreamPart\n          >({\n            transform: (chunk, controller) => {\n              // do not send `text-start` before `reasoning-start`\n              // https://github.com/vercel/ai/issues/7774\n              if (chunk.type === 'text-start') {\n                delayedTextStart = chunk;\n                return;\n              }\n\n              if (chunk.type === 'text-end' && delayedTextStart) {\n                controller.enqueue(delayedTextStart);\n                delayedTextStart = undefined;\n              }\n\n              if (chunk.type !== 'text-delta') {\n                controller.enqueue(chunk);\n                return;\n              }\n\n              if (reasoningExtractions[chunk.id] == null) {\n                reasoningExtractions[chunk.id] = {\n                  isFirstReasoning: true,\n                  isFirstText: true,\n                  afterSwitch: false,\n                  isReasoning: startWithReasoning,\n                  buffer: '',\n                  idCounter: 0,\n                  textId: chunk.id,\n                };\n              }\n\n              const activeExtraction = reasoningExtractions[chunk.id];\n\n              activeExtraction.buffer += chunk.delta;\n\n              function publish(text: string) {\n                if (text.length > 0) {\n                  const prefix =\n                    activeExtraction.afterSwitch &&\n                    (activeExtraction.isReasoning\n                      ? !activeExtraction.isFirstReasoning\n                      : !activeExtraction.isFirstText)\n                      ? separator\n                      : '';\n\n                  if (\n                    activeExtraction.isReasoning &&\n                    (activeExtraction.afterSwitch ||\n                      activeExtraction.isFirstReasoning)\n                  ) {\n                    controller.enqueue({\n                      type: 'reasoning-start',\n                      id: `reasoning-${activeExtraction.idCounter}`,\n                    });\n                  }\n\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: 'reasoning-delta',\n                      delta: prefix + text,\n                      id: `reasoning-${activeExtraction.idCounter}`,\n                    });\n                  } else {\n                    if (delayedTextStart) {\n                      controller.enqueue(delayedTextStart);\n                      delayedTextStart = undefined;\n                    }\n                    controller.enqueue({\n                      type: 'text-delta',\n                      delta: prefix + text,\n                      id: activeExtraction.textId,\n                    });\n                  }\n                  activeExtraction.afterSwitch = false;\n\n                  if (activeExtraction.isReasoning) {\n                    activeExtraction.isFirstReasoning = false;\n                  } else {\n                    activeExtraction.isFirstText = false;\n                  }\n                }\n              }\n\n              do {\n                const nextTag = activeExtraction.isReasoning\n                  ? closingTag\n                  : openingTag;\n\n                const startIndex = getPotentialStartIndex(\n                  activeExtraction.buffer,\n                  nextTag,\n                );\n\n                // no opening or closing tag found, publish the buffer\n                if (startIndex == null) {\n                  publish(activeExtraction.buffer);\n                  activeExtraction.buffer = '';\n                  break;\n                }\n\n                // publish text before the tag\n                publish(activeExtraction.buffer.slice(0, startIndex));\n\n                const foundFullMatch =\n                  startIndex + nextTag.length <= activeExtraction.buffer.length;\n\n                if (foundFullMatch) {\n                  activeExtraction.buffer = activeExtraction.buffer.slice(\n                    startIndex + nextTag.length,\n                  );\n\n                  // reasoning part finished:\n                  if (activeExtraction.isReasoning) {\n                    controller.enqueue({\n                      type: 'reasoning-end',\n                      id: `reasoning-${activeExtraction.idCounter++}`,\n                    });\n                  }\n\n                  activeExtraction.isReasoning = !activeExtraction.isReasoning;\n                  activeExtraction.afterSwitch = true;\n                } else {\n                  activeExtraction.buffer =\n                    activeExtraction.buffer.slice(startIndex);\n                  break;\n                }\n              } while (true);\n            },\n          }),\n        ),\n        ...rest,\n      };\n    },\n  };\n}\n","import type { LanguageModelV3StreamPart } from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types';\n\n/**\n * Simulates streaming chunks with the response from a generate call.\n */\nexport function simulateStreamingMiddleware(): LanguageModelMiddleware {\n  return {\n    specificationVersion: 'v3',\n    wrapStream: async ({ doGenerate }) => {\n      const result = await doGenerate();\n\n      let id = 0;\n\n      const simulatedStream = new ReadableStream<LanguageModelV3StreamPart>({\n        start(controller) {\n          controller.enqueue({\n            type: 'stream-start',\n            warnings: result.warnings,\n          });\n\n          controller.enqueue({ type: 'response-metadata', ...result.response });\n\n          for (const part of result.content) {\n            switch (part.type) {\n              case 'text': {\n                if (part.text.length > 0) {\n                  controller.enqueue({ type: 'text-start', id: String(id) });\n                  controller.enqueue({\n                    type: 'text-delta',\n                    id: String(id),\n                    delta: part.text,\n                  });\n                  controller.enqueue({ type: 'text-end', id: String(id) });\n                  id++;\n                }\n                break;\n              }\n              case 'reasoning': {\n                controller.enqueue({\n                  type: 'reasoning-start',\n                  id: String(id),\n                  providerMetadata: part.providerMetadata,\n                });\n                controller.enqueue({\n                  type: 'reasoning-delta',\n                  id: String(id),\n                  delta: part.text,\n                });\n                controller.enqueue({ type: 'reasoning-end', id: String(id) });\n                id++;\n                break;\n              }\n              default: {\n                controller.enqueue(part);\n                break;\n              }\n            }\n          }\n\n          controller.enqueue({\n            type: 'finish',\n            finishReason: result.finishReason,\n            usage: result.usage,\n            providerMetadata: result.providerMetadata,\n          });\n\n          controller.close();\n        },\n      });\n\n      return {\n        stream: simulatedStream,\n        request: result.request,\n        response: result.response,\n      };\n    },\n  };\n}\n","import { JSONObject, LanguageModelV3FunctionTool } from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types';\n\nfunction defaultFormatExample(example: { input: JSONObject }): string {\n  return JSON.stringify(example.input);\n}\n\n/**\n * Middleware that appends input examples to tool descriptions.\n *\n * This is useful for providers that don't natively support the `inputExamples`\n * property. The middleware serializes examples into the tool's description text.\n *\n * @param options - Configuration options for the middleware.\n * @param options.prefix - A prefix to prepend before the examples. Default: 'Input Examples:'\n * @param options.format - Optional custom formatter for each example.\n *   Receives the example object and its index. Default: JSON.stringify(example.input)\n * @param options.remove - Whether to remove the inputExamples property\n *   after adding them to the description. Default: true\n *\n * @example\n * ```ts\n * import { wrapLanguageModel, addToolInputExamplesMiddleware } from 'ai';\n *\n * const model = wrapLanguageModel({\n *   model: yourModel,\n *   middleware: addToolInputExamplesMiddleware(),\n * });\n * ```\n */\nexport function addToolInputExamplesMiddleware({\n  prefix = 'Input Examples:',\n  format = defaultFormatExample,\n  remove = true,\n}: {\n  /**\n   * A prefix to prepend before the examples.\n   */\n  prefix?: string;\n\n  /**\n   * Optional custom formatter for each example.\n   * Receives the example object and its index.\n   * Default: JSON.stringify(example.input)\n   */\n  format?: (example: { input: JSONObject }, index: number) => string;\n\n  /**\n   * Whether to remove the inputExamples property after adding them to the description.\n   * Default: true\n   */\n  remove?: boolean;\n} = {}): LanguageModelMiddleware {\n  return {\n    specificationVersion: 'v3',\n    transformParams: async ({ params }) => {\n      if (!params.tools?.length) {\n        return params;\n      }\n\n      const transformedTools = params.tools.map(tool => {\n        // Only transform function tools that have inputExamples\n        if (tool.type !== 'function' || !tool.inputExamples?.length) {\n          return tool;\n        }\n\n        const formattedExamples = tool.inputExamples\n          .map((example, index) => format(example, index))\n          .join('\\n');\n\n        const examplesSection = `${prefix}\\n${formattedExamples}`;\n\n        const toolDescription = tool.description\n          ? `${tool.description}\\n\\n${examplesSection}`\n          : examplesSection;\n\n        return {\n          ...tool,\n          description: toolDescription,\n          inputExamples: remove ? undefined : tool.inputExamples,\n        } satisfies LanguageModelV3FunctionTool;\n      });\n\n      return {\n        ...params,\n        tools: transformedTools,\n      };\n    },\n  };\n}\n","import {\n  LanguageModelV3,\n  LanguageModelV3CallOptions,\n  LanguageModelV3GenerateResult,\n  LanguageModelV3StreamResult,\n} from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types';\nimport { asArray } from '../util/as-array';\n\n/**\n * Wraps a LanguageModelV3 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap generate operations, and wrap stream operations of a language model.\n *\n * @param options - Configuration options for wrapping the language model.\n * @param options.model - The original LanguageModelV3 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the language model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider ID.\n * @returns A new LanguageModelV3 instance with middleware applied.\n */\nexport const wrapLanguageModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV3;\n  middleware: LanguageModelMiddleware | LanguageModelMiddleware[];\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV3 => {\n  return [...asArray(middlewareArg)]\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapGenerate,\n    wrapStream,\n    overrideProvider,\n    overrideModelId,\n    overrideSupportedUrls,\n  },\n  modelId,\n  providerId,\n}: {\n  model: LanguageModelV3;\n  middleware: LanguageModelMiddleware;\n  modelId?: string;\n  providerId?: string;\n}): LanguageModelV3 => {\n  async function doTransform({\n    params,\n    type,\n  }: {\n    params: LanguageModelV3CallOptions;\n    type: 'generate' | 'stream';\n  }) {\n    return transformParams\n      ? await transformParams({ params, type, model })\n      : params;\n  }\n\n  return {\n    specificationVersion: 'v3',\n\n    provider: providerId ?? overrideProvider?.({ model }) ?? model.provider,\n    modelId: modelId ?? overrideModelId?.({ model }) ?? model.modelId,\n    supportedUrls: overrideSupportedUrls?.({ model }) ?? model.supportedUrls,\n\n    async doGenerate(\n      params: LanguageModelV3CallOptions,\n    ): Promise<LanguageModelV3GenerateResult> {\n      const transformedParams = await doTransform({ params, type: 'generate' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapGenerate\n        ? wrapGenerate({\n            doGenerate,\n            doStream,\n            params: transformedParams,\n            model,\n          })\n        : doGenerate();\n    },\n\n    async doStream(\n      params: LanguageModelV3CallOptions,\n    ): Promise<LanguageModelV3StreamResult> {\n      const transformedParams = await doTransform({ params, type: 'stream' });\n      const doGenerate = async () => model.doGenerate(transformedParams);\n      const doStream = async () => model.doStream(transformedParams);\n      return wrapStream\n        ? wrapStream({ doGenerate, doStream, params: transformedParams, model })\n        : doStream();\n    },\n  };\n};\n","import {\n  EmbeddingModelV3,\n  EmbeddingModelV3CallOptions,\n} from '@ai-sdk/provider';\nimport { EmbeddingModelMiddleware } from '../types';\nimport { asArray } from '../util/as-array';\n\n/**\n * Wraps a EmbeddingModelV3 instance with middleware functionality.\n * This function allows you to apply middleware to transform parameters,\n * wrap embed operations of a language model.\n *\n * @param options - Configuration options for wrapping the embedding model.\n * @param options.model - The original EmbeddingModelV3 instance to be wrapped.\n * @param options.middleware - The middleware to be applied to the embedding model. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @param options.modelId - Optional custom model ID to override the original model's ID.\n * @param options.providerId - Optional custom provider ID to override the original model's provider ID.\n * @returns A new EmbeddingModelV3 instance with middleware applied.\n */\nexport const wrapEmbeddingModel = ({\n  model,\n  middleware: middlewareArg,\n  modelId,\n  providerId,\n}: {\n  model: EmbeddingModelV3;\n  middleware: EmbeddingModelMiddleware | EmbeddingModelMiddleware[];\n  modelId?: string;\n  providerId?: string;\n}): EmbeddingModelV3 => {\n  return [...asArray(middlewareArg)]\n    .reverse()\n    .reduce((wrappedModel, middleware) => {\n      return doWrap({ model: wrappedModel, middleware, modelId, providerId });\n    }, model);\n};\n\nconst doWrap = ({\n  model,\n  middleware: {\n    transformParams,\n    wrapEmbed,\n    overrideProvider,\n    overrideModelId,\n    overrideMaxEmbeddingsPerCall,\n    overrideSupportsParallelCalls,\n  },\n  modelId,\n  providerId,\n}: {\n  model: EmbeddingModelV3;\n  middleware: EmbeddingModelMiddleware;\n  modelId?: string;\n  providerId?: string;\n}): EmbeddingModelV3 => {\n  async function doTransform({\n    params,\n  }: {\n    params: EmbeddingModelV3CallOptions;\n  }) {\n    return transformParams ? await transformParams({ params, model }) : params;\n  }\n\n  return {\n    specificationVersion: 'v3',\n    provider: providerId ?? overrideProvider?.({ model }) ?? model.provider,\n    modelId: modelId ?? overrideModelId?.({ model }) ?? model.modelId,\n    maxEmbeddingsPerCall:\n      overrideMaxEmbeddingsPerCall?.({ model }) ?? model.maxEmbeddingsPerCall,\n    supportsParallelCalls:\n      overrideSupportsParallelCalls?.({ model }) ?? model.supportsParallelCalls,\n    async doEmbed(\n      params: EmbeddingModelV3CallOptions,\n    ): Promise<Awaited<ReturnType<EmbeddingModelV3['doEmbed']>>> {\n      const transformedParams = await doTransform({ params });\n      const doEmbed = async () => model.doEmbed(transformedParams);\n      return wrapEmbed\n        ? wrapEmbed({\n            doEmbed,\n            params: transformedParams,\n            model,\n          })\n        : doEmbed();\n    },\n  };\n};\n","import { ProviderV2, ProviderV3 } from '@ai-sdk/provider';\nimport { asEmbeddingModelV3 } from './as-embedding-model-v3';\nimport { asImageModelV3 } from './as-image-model-v3';\nimport { asLanguageModelV3 } from './as-language-model-v3';\nimport { asTranscriptionModelV3 } from './as-transcription-model-v3';\nimport { asSpeechModelV3 } from './as-speech-model-v3';\n\nexport function asProviderV3(provider: ProviderV2 | ProviderV3): ProviderV3 {\n  if (\n    'specificationVersion' in provider &&\n    provider.specificationVersion === 'v3'\n  ) {\n    return provider;\n  }\n\n  // v3 providers have already been returned\n  const v2Provider: ProviderV2 = provider as ProviderV2;\n\n  return {\n    specificationVersion: 'v3',\n    languageModel: (modelId: string) =>\n      asLanguageModelV3(v2Provider.languageModel(modelId)),\n    embeddingModel: (modelId: string) =>\n      asEmbeddingModelV3(v2Provider.textEmbeddingModel(modelId)),\n    imageModel: (modelId: string) =>\n      asImageModelV3(v2Provider.imageModel(modelId)),\n    transcriptionModel: v2Provider.transcriptionModel\n      ? (modelId: string) =>\n          asTranscriptionModelV3(v2Provider.transcriptionModel!(modelId))\n      : undefined,\n    speechModel: v2Provider.speechModel\n      ? (modelId: string) => asSpeechModelV3(v2Provider.speechModel!(modelId))\n      : undefined,\n    rerankingModel: undefined, // v2 providers don't have reranking models\n  };\n}\n","import type { ProviderV2, ProviderV3 } from '@ai-sdk/provider';\nimport { LanguageModelMiddleware } from '../types/language-model-middleware';\nimport { wrapLanguageModel } from './wrap-language-model';\nimport { asProviderV3 } from '../model/as-provider-v3';\n\n/**\n * Wraps a ProviderV3 instance with middleware functionality.\n * This function allows you to apply middleware to all language models\n * from the provider, enabling you to transform parameters, wrap generate\n * operations, and wrap stream operations for every language model.\n *\n * @param options - Configuration options for wrapping the provider.\n * @param options.provider - The original ProviderV3 instance to be wrapped.\n * @param options.languageModelMiddleware - The middleware to be applied to all language models from the provider. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @returns A new ProviderV3 instance with middleware applied to all language models.\n */\nexport function wrapProvider({\n  provider,\n  languageModelMiddleware,\n}: {\n  provider: ProviderV3 | ProviderV2;\n  languageModelMiddleware: LanguageModelMiddleware | LanguageModelMiddleware[];\n}): ProviderV3 {\n  const providerV3 = asProviderV3(provider);\n  return {\n    specificationVersion: 'v3',\n    languageModel: (modelId: string) =>\n      wrapLanguageModel({\n        model: providerV3.languageModel(modelId),\n        middleware: languageModelMiddleware,\n      }),\n    embeddingModel: providerV3.embeddingModel,\n    imageModel: providerV3.imageModel,\n    transcriptionModel: providerV3.transcriptionModel,\n    speechModel: providerV3.speechModel,\n    rerankingModel: providerV3.rerankingModel,\n  };\n}\n","import {\n  EmbeddingModelV3,\n  ImageModelV3,\n  LanguageModelV3,\n  NoSuchModelError,\n  ProviderV2,\n  ProviderV3,\n  RerankingModelV3,\n  SpeechModelV3,\n  TranscriptionModelV3,\n} from '@ai-sdk/provider';\nimport { asProviderV3 } from '../model/as-provider-v3';\n\n/**\n * Creates a custom provider with specified language models, text embedding models, image models, transcription models, speech models, and an optional fallback provider.\n *\n * @param {Object} options - The options for creating the custom provider.\n * @param {Record<string, LanguageModel>} [options.languageModels] - A record of language models, where keys are model IDs and values are LanguageModel instances.\n * @param {Record<string, EmbeddingModel>} [options.embeddingModels] - A record of text embedding models, where keys are model IDs and values are EmbeddingModel instances.\n * @param {Record<string, ImageModel>} [options.imageModels] - A record of image models, where keys are model IDs and values are ImageModel instances.\n * @param {Record<string, TranscriptionModel>} [options.transcriptionModels] - A record of transcription models, where keys are model IDs and values are TranscriptionModel instances.\n * @param {Record<string, SpeechModel>} [options.speechModels] - A record of speech models, where keys are model IDs and values are SpeechModel instances.\n * @param {Record<string, RerankingModel>} [options.rerankingModels] - A record of reranking models, where keys are model IDs and values are RerankingModel instances.\n * @param {Provider} [options.fallbackProvider] - An optional fallback provider to use when a requested model is not found in the custom provider.\n * @returns {Provider} A Provider object with languageModel, embeddingModel, imageModel, transcriptionModel, and speechModel methods.\n *\n * @throws {NoSuchModelError} Throws when a requested model is not found and no fallback provider is available.\n */\nexport function customProvider<\n  LANGUAGE_MODELS extends Record<string, LanguageModelV3>,\n  EMBEDDING_MODELS extends Record<string, EmbeddingModelV3>,\n  IMAGE_MODELS extends Record<string, ImageModelV3>,\n  TRANSCRIPTION_MODELS extends Record<string, TranscriptionModelV3>,\n  SPEECH_MODELS extends Record<string, SpeechModelV3>,\n  RERANKING_MODELS extends Record<string, RerankingModelV3>,\n>({\n  languageModels,\n  embeddingModels,\n  imageModels,\n  transcriptionModels,\n  speechModels,\n  rerankingModels,\n  fallbackProvider: fallbackProviderArg,\n}: {\n  languageModels?: LANGUAGE_MODELS;\n  embeddingModels?: EMBEDDING_MODELS;\n  imageModels?: IMAGE_MODELS;\n  transcriptionModels?: TRANSCRIPTION_MODELS;\n  speechModels?: SPEECH_MODELS;\n  rerankingModels?: RERANKING_MODELS;\n  fallbackProvider?: ProviderV3 | ProviderV2;\n}): ProviderV3 & {\n  languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModelV3;\n  embeddingModel(modelId: ExtractModelId<EMBEDDING_MODELS>): EmbeddingModelV3;\n  imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModelV3;\n  transcriptionModel(\n    modelId: ExtractModelId<TRANSCRIPTION_MODELS>,\n  ): TranscriptionModelV3;\n  rerankingModel(modelId: ExtractModelId<RERANKING_MODELS>): RerankingModelV3;\n  speechModel(modelId: ExtractModelId<SPEECH_MODELS>): SpeechModelV3;\n} {\n  const fallbackProvider = fallbackProviderArg\n    ? asProviderV3(fallbackProviderArg)\n    : undefined;\n\n  return {\n    specificationVersion: 'v3',\n    languageModel(modelId: ExtractModelId<LANGUAGE_MODELS>): LanguageModelV3 {\n      if (languageModels != null && modelId in languageModels) {\n        return languageModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return (fallbackProvider as ProviderV3).languageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'languageModel' });\n    },\n\n    embeddingModel(\n      modelId: ExtractModelId<EMBEDDING_MODELS>,\n    ): EmbeddingModelV3 {\n      if (embeddingModels != null && modelId in embeddingModels) {\n        return embeddingModels[modelId];\n      }\n\n      if (fallbackProvider) {\n        return (fallbackProvider as ProviderV3).embeddingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'embeddingModel' });\n    },\n\n    imageModel(modelId: ExtractModelId<IMAGE_MODELS>): ImageModelV3 {\n      if (imageModels != null && modelId in imageModels) {\n        return imageModels[modelId];\n      }\n\n      if (fallbackProvider?.imageModel) {\n        return (fallbackProvider as ProviderV3).imageModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'imageModel' });\n    },\n\n    transcriptionModel(\n      modelId: ExtractModelId<TRANSCRIPTION_MODELS>,\n    ): TranscriptionModelV3 {\n      if (transcriptionModels != null && modelId in transcriptionModels) {\n        return transcriptionModels[modelId];\n      }\n\n      if (fallbackProvider?.transcriptionModel) {\n        return (fallbackProvider as ProviderV3).transcriptionModel!(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'transcriptionModel' });\n    },\n\n    speechModel(modelId: ExtractModelId<SPEECH_MODELS>): SpeechModelV3 {\n      if (speechModels != null && modelId in speechModels) {\n        return speechModels[modelId];\n      }\n\n      if (fallbackProvider?.speechModel) {\n        return (fallbackProvider as ProviderV3).speechModel!(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'speechModel' });\n    },\n    rerankingModel(\n      modelId: ExtractModelId<RERANKING_MODELS>,\n    ): RerankingModelV3 {\n      if (rerankingModels != null && modelId in rerankingModels) {\n        return rerankingModels[modelId];\n      }\n\n      if (fallbackProvider?.rerankingModel) {\n        return fallbackProvider.rerankingModel(modelId);\n      }\n\n      throw new NoSuchModelError({ modelId, modelType: 'rerankingModel' });\n    },\n  };\n}\n\n/**\n * @deprecated Use `customProvider` instead.\n */\nexport const experimental_customProvider = customProvider;\n\ntype ExtractModelId<MODELS extends Record<string, unknown>> = Extract<\n  keyof MODELS,\n  string\n>;\n","import { AISDKError, NoSuchModelError } from '@ai-sdk/provider';\n\nconst name = 'AI_NoSuchProviderError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class NoSuchProviderError extends NoSuchModelError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly providerId: string;\n  readonly availableProviders: string[];\n\n  constructor({\n    modelId,\n    modelType,\n    providerId,\n    availableProviders,\n    message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})`,\n  }: {\n    modelId: string;\n    modelType:\n      | 'languageModel'\n      | 'embeddingModel'\n      | 'imageModel'\n      | 'transcriptionModel'\n      | 'speechModel'\n      | 'rerankingModel';\n    providerId: string;\n    availableProviders: string[];\n    message?: string;\n  }) {\n    super({ errorName: name, modelId, modelType, message });\n\n    this.providerId = providerId;\n    this.availableProviders = availableProviders;\n  }\n\n  static isInstance(error: unknown): error is NoSuchProviderError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import {\n  EmbeddingModelV3,\n  ImageModelV3,\n  LanguageModelV3,\n  NoSuchModelError,\n  ProviderV3,\n  RerankingModelV3,\n  SpeechModelV3,\n  TranscriptionModelV3,\n} from '@ai-sdk/provider';\nimport { wrapLanguageModel } from '../middleware/wrap-language-model';\nimport { LanguageModelMiddleware } from '../types';\nimport { NoSuchProviderError } from './no-such-provider-error';\n\ntype ExtractLiteralUnion<T> = T extends string\n  ? string extends T\n    ? never\n    : T\n  : never;\n\nexport interface ProviderRegistryProvider<\n  PROVIDERS extends Record<string, ProviderV3> = Record<string, ProviderV3>,\n  SEPARATOR extends string = ':',\n> {\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['languageModel']>>[0]>}`\n      : never,\n  ): LanguageModelV3;\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): LanguageModelV3;\n\n  embeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['embeddingModel']>>[0]>}`\n      : never,\n  ): EmbeddingModelV3;\n  embeddingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): EmbeddingModelV3;\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['imageModel']>>[0]>}`\n      : never,\n  ): ImageModelV3;\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): ImageModelV3;\n\n  transcriptionModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['transcriptionModel']>>[0]>}`\n      : never,\n  ): TranscriptionModelV3;\n  transcriptionModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): TranscriptionModelV3;\n\n  speechModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['speechModel']>>[0]>}`\n      : never,\n  ): SpeechModelV3;\n  speechModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): SpeechModelV3;\n\n  rerankingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string\n      ? `${KEY & string}${SEPARATOR}${ExtractLiteralUnion<Parameters<NonNullable<PROVIDERS[KEY]['rerankingModel']>>[0]>}`\n      : never,\n  ): RerankingModelV3;\n  rerankingModel<KEY extends keyof PROVIDERS>(\n    id: KEY extends string ? `${KEY & string}${SEPARATOR}${string}` : never,\n  ): RerankingModelV3;\n}\n\n/**\n * Creates a registry for the given providers with optional middleware functionality.\n * This function allows you to register multiple providers and optionally apply middleware\n * to all language models from the registry, enabling you to transform parameters, wrap generate\n * operations, and wrap stream operations for every language model accessed through the registry.\n *\n * @param providers - A record of provider instances to be registered in the registry.\n * @param options - Configuration options for the provider registry.\n * @param options.separator - The separator used between provider ID and model ID in the combined identifier. Defaults to ':'.\n * @param options.languageModelMiddleware - Optional middleware to be applied to all language models from the registry. When multiple middlewares are provided, the first middleware will transform the input first, and the last middleware will be wrapped directly around the model.\n * @returns A new ProviderRegistryProvider instance that provides access to all registered providers with optional middleware applied to language models.\n */\nexport function createProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV3>,\n  SEPARATOR extends string = ':',\n>(\n  providers: PROVIDERS,\n  {\n    separator = ':' as SEPARATOR,\n    languageModelMiddleware,\n  }: {\n    separator?: SEPARATOR;\n    languageModelMiddleware?:\n      | LanguageModelMiddleware\n      | LanguageModelMiddleware[];\n  } = {},\n): ProviderRegistryProvider<PROVIDERS, SEPARATOR> {\n  const registry = new DefaultProviderRegistry<PROVIDERS, SEPARATOR>({\n    separator,\n    languageModelMiddleware,\n  });\n\n  for (const [id, provider] of Object.entries(providers)) {\n    registry.registerProvider({ id, provider } as {\n      id: keyof PROVIDERS;\n      provider: PROVIDERS[keyof PROVIDERS];\n    });\n  }\n\n  return registry;\n}\n\n/**\n * @deprecated Use `createProviderRegistry` instead.\n */\nexport const experimental_createProviderRegistry = createProviderRegistry;\n\nclass DefaultProviderRegistry<\n  PROVIDERS extends Record<string, ProviderV3>,\n  SEPARATOR extends string,\n> implements ProviderRegistryProvider<PROVIDERS, SEPARATOR>\n{\n  private providers: PROVIDERS = {} as PROVIDERS;\n  private separator: SEPARATOR;\n  private languageModelMiddleware?:\n    | LanguageModelMiddleware\n    | LanguageModelMiddleware[];\n\n  constructor({\n    separator,\n    languageModelMiddleware,\n  }: {\n    separator: SEPARATOR;\n    languageModelMiddleware?:\n      | LanguageModelMiddleware\n      | LanguageModelMiddleware[];\n  }) {\n    this.separator = separator;\n    this.languageModelMiddleware = languageModelMiddleware;\n  }\n\n  registerProvider<K extends keyof PROVIDERS>({\n    id,\n    provider,\n  }: {\n    id: K;\n    provider: PROVIDERS[K];\n  }): void {\n    this.providers[id] = provider;\n  }\n\n  private getProvider(\n    id: string,\n    modelType:\n      | 'languageModel'\n      | 'embeddingModel'\n      | 'imageModel'\n      | 'transcriptionModel'\n      | 'speechModel'\n      | 'rerankingModel',\n  ): ProviderV3 {\n    const provider = this.providers[id as keyof PROVIDERS];\n\n    if (provider == null) {\n      throw new NoSuchProviderError({\n        modelId: id,\n        modelType,\n        providerId: id,\n        availableProviders: Object.keys(this.providers),\n      });\n    }\n\n    return provider;\n  }\n\n  private splitId(\n    id: string,\n    modelType:\n      | 'languageModel'\n      | 'embeddingModel'\n      | 'imageModel'\n      | 'transcriptionModel'\n      | 'speechModel'\n      | 'rerankingModel',\n  ): [string, string] {\n    const index = id.indexOf(this.separator);\n\n    if (index === -1) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType,\n        message:\n          `Invalid ${modelType} id for registry: ${id} ` +\n          `(must be in the format \"providerId${this.separator}modelId\")`,\n      });\n    }\n\n    return [id.slice(0, index), id.slice(index + this.separator.length)];\n  }\n\n  languageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): LanguageModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'languageModel');\n    let model = this.getProvider(providerId, 'languageModel').languageModel?.(\n      modelId,\n    );\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'languageModel' });\n    }\n\n    if (this.languageModelMiddleware != null) {\n      model = wrapLanguageModel({\n        model,\n        middleware: this.languageModelMiddleware,\n      });\n    }\n\n    return model;\n  }\n\n  embeddingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): EmbeddingModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'embeddingModel');\n    const provider = this.getProvider(providerId, 'embeddingModel');\n\n    const model = provider.embeddingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'embeddingModel',\n      });\n    }\n\n    return model;\n  }\n\n  imageModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): ImageModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'imageModel');\n    const provider = this.getProvider(providerId, 'imageModel');\n\n    const model = provider.imageModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'imageModel' });\n    }\n\n    return model;\n  }\n\n  transcriptionModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): TranscriptionModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'transcriptionModel');\n    const provider = this.getProvider(providerId, 'transcriptionModel');\n\n    const model = provider.transcriptionModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({\n        modelId: id,\n        modelType: 'transcriptionModel',\n      });\n    }\n\n    return model;\n  }\n\n  speechModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): SpeechModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'speechModel');\n    const provider = this.getProvider(providerId, 'speechModel');\n\n    const model = provider.speechModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'speechModel' });\n    }\n\n    return model;\n  }\n\n  rerankingModel<KEY extends keyof PROVIDERS>(\n    id: `${KEY & string}${SEPARATOR}${string}`,\n  ): RerankingModelV3 {\n    const [providerId, modelId] = this.splitId(id, 'rerankingModel');\n    const provider = this.getProvider(providerId, 'rerankingModel');\n\n    const model = provider.rerankingModel?.(modelId);\n\n    if (model == null) {\n      throw new NoSuchModelError({ modelId: id, modelType: 'rerankingModel' });\n    }\n\n    return model;\n  }\n}\n","import { JSONObject, RerankingModelV3CallOptions } from '@ai-sdk/provider';\nimport { ProviderOptions } from '@ai-sdk/provider-utils';\nimport { prepareRetries } from '../../src/util/prepare-retries';\nimport { assembleOperationName } from '../telemetry/assemble-operation-name';\nimport { getBaseTelemetryAttributes } from '../telemetry/get-base-telemetry-attributes';\nimport { getTracer } from '../telemetry/get-tracer';\nimport { recordSpan } from '../telemetry/record-span';\nimport { selectTelemetryAttributes } from '../telemetry/select-telemetry-attributes';\nimport { TelemetrySettings } from '../telemetry/telemetry-settings';\nimport { RerankingModel } from '../types';\nimport { RerankResult } from './rerank-result';\nimport { logWarnings } from '../logger/log-warnings';\n\n/**\nRerank documents using an reranking model. The type of the value is defined by the reranking model.\n\n@param model - The Reranking model to use.\n@param documents - The documents that should be reranking.\n@param query - The query is a string that represents the query to rerank the documents against.\n@param topN - Top n documents to rerank.\n\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the reranked documents, the reranked indices, and additional information.\n */\nexport async function rerank<VALUE extends JSONObject | string>({\n  model,\n  documents,\n  query,\n  topN,\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n  providerOptions,\n  experimental_telemetry: telemetry,\n}: {\n  /**\nThe reranking model to use.\n  */\n  model: RerankingModel;\n\n  /**\n   * The documents that should be reranked.\n   */\n  documents: Array<VALUE>;\n\n  /**\nThe query is a string that represents the query to rerank the documents against.\n   */\n  query: string;\n\n  /**\n   * Number of top documents to return.\n   */\n  topN?: number;\n\n  /**\nMaximum number of retries per reranking model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n\n  /**\n   * Optional telemetry configuration (experimental).\n   */\n  experimental_telemetry?: TelemetrySettings;\n\n  /**\n    Additional provider-specific options. They are passed through\n    to the provider from the AI SDK and enable provider-specific\n    functionality that can be fully encapsulated in the provider.\n    */\n  providerOptions?: ProviderOptions;\n}): Promise<RerankResult<VALUE>> {\n  if (documents.length === 0) {\n    return new DefaultRerankResult({\n      originalDocuments: [],\n      ranking: [],\n      providerMetadata: undefined,\n      response: {\n        timestamp: new Date(),\n        modelId: model.modelId,\n      },\n    });\n  }\n\n  const { maxRetries, retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  // detect the type of the documents:\n  const documentsToSend: RerankingModelV3CallOptions['documents'] =\n    typeof documents[0] === 'string'\n      ? { type: 'text', values: documents as string[] }\n      : { type: 'object', values: documents as JSONObject[] };\n\n  const baseTelemetryAttributes = getBaseTelemetryAttributes({\n    model,\n    telemetry,\n    headers,\n    settings: { maxRetries },\n  });\n\n  const tracer = getTracer(telemetry);\n\n  return recordSpan({\n    name: 'ai.rerank',\n    attributes: selectTelemetryAttributes({\n      telemetry,\n      attributes: {\n        ...assembleOperationName({ operationId: 'ai.rerank', telemetry }),\n        ...baseTelemetryAttributes,\n        'ai.documents': {\n          input: () => documents.map(document => JSON.stringify(document)),\n        },\n      },\n    }),\n    tracer,\n    fn: async () => {\n      const { ranking, response, providerMetadata, warnings } = await retry(\n        () =>\n          recordSpan({\n            name: 'ai.rerank.doRerank',\n            attributes: selectTelemetryAttributes({\n              telemetry,\n              attributes: {\n                ...assembleOperationName({\n                  operationId: 'ai.rerank.doRerank',\n                  telemetry,\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                'ai.documents': {\n                  input: () =>\n                    documents.map(document => JSON.stringify(document)),\n                },\n              },\n            }),\n            tracer,\n            fn: async doRerankSpan => {\n              const modelResponse = await model.doRerank({\n                documents: documentsToSend,\n                query,\n                topN,\n                providerOptions,\n                abortSignal,\n                headers,\n              });\n\n              const ranking = modelResponse.ranking;\n\n              doRerankSpan.setAttributes(\n                await selectTelemetryAttributes({\n                  telemetry,\n                  attributes: {\n                    'ai.ranking.type': documentsToSend.type,\n                    'ai.ranking': {\n                      output: () =>\n                        ranking.map(ranking => JSON.stringify(ranking)),\n                    },\n                  },\n                }),\n              );\n\n              return {\n                ranking,\n                providerMetadata: modelResponse.providerMetadata,\n                response: modelResponse.response,\n                warnings: modelResponse.warnings,\n              };\n            },\n          }),\n      );\n\n      logWarnings({\n        warnings: warnings ?? [],\n        provider: model.provider,\n        model: model.modelId,\n      });\n\n      return new DefaultRerankResult({\n        originalDocuments: documents,\n        ranking: ranking.map(ranking => ({\n          originalIndex: ranking.index,\n          score: ranking.relevanceScore,\n          document: documents[ranking.index],\n        })),\n        providerMetadata,\n        response: {\n          id: response?.id,\n          timestamp: response?.timestamp ?? new Date(),\n          modelId: response?.modelId ?? model.modelId,\n          headers: response?.headers,\n          body: response?.body,\n        },\n      });\n    },\n  });\n}\n\nclass DefaultRerankResult<VALUE> implements RerankResult<VALUE> {\n  readonly originalDocuments: RerankResult<VALUE>['originalDocuments'];\n  readonly ranking: RerankResult<VALUE>['ranking'];\n  readonly response: RerankResult<VALUE>['response'];\n  readonly providerMetadata: RerankResult<VALUE>['providerMetadata'];\n\n  constructor(options: {\n    originalDocuments: RerankResult<VALUE>['originalDocuments'];\n    ranking: RerankResult<VALUE>['ranking'];\n    providerMetadata?: RerankResult<VALUE>['providerMetadata'];\n    response: RerankResult<VALUE>['response'];\n  }) {\n    this.originalDocuments = options.originalDocuments;\n    this.ranking = options.ranking;\n    this.response = options.response;\n    this.providerMetadata = options.providerMetadata;\n  }\n\n  get rerankedDocuments(): RerankResult<VALUE>['rerankedDocuments'] {\n    return this.ranking.map(ranking => ranking.document);\n  }\n}\n","import { JSONObject } from '@ai-sdk/provider';\nimport { ProviderOptions, withUserAgentSuffix } from '@ai-sdk/provider-utils';\nimport { NoTranscriptGeneratedError } from '../error/no-transcript-generated-error';\nimport { logWarnings } from '../logger/log-warnings';\nimport { DataContent } from '../prompt';\nimport { convertDataContentToUint8Array } from '../prompt/data-content';\nimport { TranscriptionModel } from '../types/transcription-model';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\nimport {\n  audioMediaTypeSignatures,\n  detectMediaType,\n} from '../util/detect-media-type';\nimport { download } from '../util/download/download';\nimport { prepareRetries } from '../util/prepare-retries';\nimport { TranscriptionResult } from './transcribe-result';\nimport { VERSION } from '../version';\nimport { resolveTranscriptionModel } from '../model/resolve-model';\nimport { Warning } from '../types';\n/**\nGenerates transcripts using a transcription model.\n\n@param model - The transcription model to use.\n@param audio - The audio data to transcribe as DataContent (string | Uint8Array | ArrayBuffer | Buffer) or a URL.\n@param providerOptions - Additional provider-specific options that are passed through to the provider\nas body parameters.\n@param maxRetries - Maximum number of retries. Set to 0 to disable retries. Default: 2.\n@param abortSignal - An optional abort signal that can be used to cancel the call.\n@param headers - Additional HTTP headers to be sent with the request. Only applicable for HTTP-based providers.\n\n@returns A result object that contains the generated transcript.\n */\nexport async function transcribe({\n  model,\n  audio,\n  providerOptions = {},\n  maxRetries: maxRetriesArg,\n  abortSignal,\n  headers,\n}: {\n  /**\nThe transcription model to use.\n     */\n  model: TranscriptionModel;\n\n  /**\nThe audio data to transcribe.\n   */\n  audio: DataContent | URL;\n\n  /**\nAdditional provider-specific options that are passed through to the provider\nas body parameters.\n\nThe outer record is keyed by the provider name, and the inner\nrecord is keyed by the provider-specific metadata key.\n```ts\n{\n  \"openai\": {\n    \"temperature\": 0\n  }\n}\n```\n     */\n  providerOptions?: ProviderOptions;\n\n  /**\nMaximum number of retries per transcript model call. Set to 0 to disable retries.\n\n@default 2\n   */\n  maxRetries?: number;\n\n  /**\nAbort signal.\n */\n  abortSignal?: AbortSignal;\n\n  /**\nAdditional headers to include in the request.\nOnly applicable for HTTP-based providers.\n */\n  headers?: Record<string, string>;\n}): Promise<TranscriptionResult> {\n  const resolvedModel = resolveTranscriptionModel(model);\n  if (!resolvedModel) {\n    throw new Error('Model could not be resolved');\n  }\n\n  const { retry } = prepareRetries({\n    maxRetries: maxRetriesArg,\n    abortSignal,\n  });\n\n  const headersWithUserAgent = withUserAgentSuffix(\n    headers ?? {},\n    `ai/${VERSION}`,\n  );\n\n  const audioData =\n    audio instanceof URL\n      ? (await download({ url: audio })).data\n      : convertDataContentToUint8Array(audio);\n\n  const result = await retry(() =>\n    resolvedModel.doGenerate({\n      audio: audioData,\n      abortSignal,\n      headers: headersWithUserAgent,\n      providerOptions,\n      mediaType:\n        detectMediaType({\n          data: audioData,\n          signatures: audioMediaTypeSignatures,\n        }) ?? 'audio/wav',\n    }),\n  );\n\n  logWarnings({\n    warnings: result.warnings,\n    provider: resolvedModel.provider,\n    model: resolvedModel.modelId,\n  });\n\n  if (!result.text) {\n    throw new NoTranscriptGeneratedError({ responses: [result.response] });\n  }\n\n  return new DefaultTranscriptionResult({\n    text: result.text,\n    segments: result.segments,\n    language: result.language,\n    durationInSeconds: result.durationInSeconds,\n    warnings: result.warnings,\n    responses: [result.response],\n    providerMetadata: result.providerMetadata,\n  });\n}\n\nclass DefaultTranscriptionResult implements TranscriptionResult {\n  readonly text: string;\n  readonly segments: Array<{\n    text: string;\n    startSecond: number;\n    endSecond: number;\n  }>;\n  readonly language: string | undefined;\n  readonly durationInSeconds: number | undefined;\n  readonly warnings: Array<Warning>;\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n  readonly providerMetadata: Record<string, JSONObject>;\n\n  constructor(options: {\n    text: string;\n    segments: Array<{\n      text: string;\n      startSecond: number;\n      endSecond: number;\n    }>;\n    language: string | undefined;\n    durationInSeconds: number | undefined;\n    warnings: Array<Warning>;\n    responses: Array<TranscriptionModelResponseMetadata>;\n    providerMetadata: Record<string, JSONObject> | undefined;\n  }) {\n    this.text = options.text;\n    this.segments = options.segments;\n    this.language = options.language;\n    this.durationInSeconds = options.durationInSeconds;\n    this.warnings = options.warnings;\n    this.responses = options.responses;\n    this.providerMetadata = options.providerMetadata ?? {};\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\nimport { TranscriptionModelResponseMetadata } from '../types/transcription-model-response-metadata';\n\n/**\nError that is thrown when no transcript was generated.\n */\nexport class NoTranscriptGeneratedError extends AISDKError {\n  readonly responses: Array<TranscriptionModelResponseMetadata>;\n\n  constructor(options: {\n    responses: Array<TranscriptionModelResponseMetadata>;\n  }) {\n    super({\n      name: 'AI_NoTranscriptGeneratedError',\n      message: 'No transcript generated.',\n    });\n\n    this.responses = options.responses;\n  }\n}\n","import {\n  parseJsonEventStream,\n  ParseResult,\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport {\n  UIMessageChunk,\n  uiMessageChunkSchema,\n} from '../ui-message-stream/ui-message-chunks';\nimport { consumeStream } from '../util/consume-stream';\nimport { processTextStream } from './process-text-stream';\nimport { VERSION } from '../version';\n\n// use function to allow for mocking in tests:\nconst getOriginalFetch = () => fetch;\n\nexport async function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = 'data',\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onFinish,\n  onError,\n  fetch = getOriginalFetch(),\n}: {\n  api: string;\n  prompt: string;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  body: Record<string, any>;\n  streamProtocol: 'data' | 'text' | undefined;\n  setCompletion: (completion: string) => void;\n  setLoading: (loading: boolean) => void;\n  setError: (error: Error | undefined) => void;\n  setAbortController: (abortController: AbortController | null) => void;\n  onFinish: ((prompt: string, completion: string) => void) | undefined;\n  onError: ((error: Error) => void) | undefined;\n  fetch: ReturnType<typeof getOriginalFetch> | undefined;\n}) {\n  try {\n    setLoading(true);\n    setError(undefined);\n\n    const abortController = new AbortController();\n    setAbortController(abortController);\n\n    // Empty the completion immediately.\n    setCompletion('');\n\n    const response = await fetch(api, {\n      method: 'POST',\n      body: JSON.stringify({\n        prompt,\n        ...body,\n      }),\n      credentials,\n      headers: withUserAgentSuffix(\n        {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      signal: abortController.signal,\n    }).catch(err => {\n      throw err;\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    let result = '';\n\n    switch (streamProtocol) {\n      case 'text': {\n        await processTextStream({\n          stream: response.body,\n          onTextPart: chunk => {\n            result += chunk;\n            setCompletion(result);\n          },\n        });\n        break;\n      }\n      case 'data': {\n        await consumeStream({\n          stream: parseJsonEventStream({\n            stream: response.body,\n            schema: uiMessageChunkSchema,\n          }).pipeThrough(\n            new TransformStream<ParseResult<UIMessageChunk>, UIMessageChunk>({\n              async transform(part) {\n                if (!part.success) {\n                  throw part.error;\n                }\n\n                const streamPart = part.value;\n                if (streamPart.type === 'text-delta') {\n                  result += streamPart.delta;\n                  setCompletion(result);\n                } else if (streamPart.type === 'error') {\n                  throw new Error(streamPart.errorText);\n                }\n              },\n            }),\n          ),\n          onError: error => {\n            throw error;\n          },\n        });\n        break;\n      }\n      default: {\n        const exhaustiveCheck: never = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    // Ignore abort errors as they are expected.\n    if ((err as any).name === 'AbortError') {\n      setAbortController(null);\n      return null;\n    }\n\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n\n    setError(err as Error);\n  } finally {\n    setLoading(false);\n  }\n}\n","export async function processTextStream({\n  stream,\n  onTextPart,\n}: {\n  stream: ReadableStream<Uint8Array>;\n  onTextPart: (chunk: string) => Promise<void> | void;\n}): Promise<void> {\n  const reader = stream.pipeThrough(new TextDecoderStream()).getReader();\n  while (true) {\n    const { done, value } = await reader.read();\n    if (done) {\n      break;\n    }\n    await onTextPart(value);\n  }\n}\n","import {\n  FlexibleSchema,\n  generateId as generateIdFunc,\n  IdGenerator,\n  InferSchema,\n} from '@ai-sdk/provider-utils';\nimport { FinishReason } from '../types/language-model';\nimport { UIMessageChunk } from '../ui-message-stream/ui-message-chunks';\nimport { consumeStream } from '../util/consume-stream';\nimport { SerialJobExecutor } from '../util/serial-job-executor';\nimport { ChatTransport } from './chat-transport';\nimport { convertFileListToFileUIParts } from './convert-file-list-to-file-ui-parts';\nimport { DefaultChatTransport } from './default-chat-transport';\nimport {\n  createStreamingUIMessageState,\n  processUIMessageStream,\n  StreamingUIMessageState,\n} from './process-ui-message-stream';\nimport {\n  InferUIMessageToolCall,\n  isToolUIPart,\n  UIMessagePart,\n  UITools,\n  type DataUIPart,\n  type FileUIPart,\n  type InferUIMessageData,\n  type InferUIMessageMetadata,\n  type InferUIMessageTools,\n  type UIDataTypes,\n  type UIMessage,\n} from './ui-messages';\n\nexport type CreateUIMessage<UI_MESSAGE extends UIMessage> = Omit<\n  UI_MESSAGE,\n  'id' | 'role'\n> & {\n  id?: UI_MESSAGE['id'];\n  role?: UI_MESSAGE['role'];\n};\n\nexport type UIDataPartSchemas = Record<string, FlexibleSchema>;\n\nexport type UIDataTypesToSchemas<T extends UIDataTypes> = {\n  [K in keyof T]: FlexibleSchema<T[K]>;\n};\n\nexport type InferUIDataParts<T extends UIDataPartSchemas> = {\n  [K in keyof T]: InferSchema<T[K]>;\n};\n\nexport type ChatRequestOptions = {\n  /**\n  Additional headers that should be to be passed to the API endpoint.\n   */\n  headers?: Record<string, string> | Headers;\n\n  /**\n  Additional body JSON properties that should be sent to the API endpoint.\n   */\n  body?: object; // TODO JSONStringifyable\n\n  metadata?: unknown;\n};\n\n/**\n * Function that can be called to add a tool approval response to the chat.\n */\nexport type ChatAddToolApproveResponseFunction = ({\n  id,\n  approved,\n  reason,\n}: {\n  id: string;\n\n  /**\n   * Flag indicating whether the approval was granted or denied.\n   */\n  approved: boolean;\n\n  /**\n   * Optional reason for the approval or denial.\n   */\n  reason?: string;\n}) => void | PromiseLike<void>;\n\nexport type ChatStatus = 'submitted' | 'streaming' | 'ready' | 'error';\n\ntype ActiveResponse<UI_MESSAGE extends UIMessage> = {\n  state: StreamingUIMessageState<UI_MESSAGE>;\n  abortController: AbortController;\n};\n\nexport interface ChatState<UI_MESSAGE extends UIMessage> {\n  status: ChatStatus;\n\n  error: Error | undefined;\n\n  messages: UI_MESSAGE[];\n  pushMessage: (message: UI_MESSAGE) => void;\n  popMessage: () => void;\n  replaceMessage: (index: number, message: UI_MESSAGE) => void;\n\n  snapshot: <T>(thing: T) => T;\n}\n\nexport type ChatOnErrorCallback = (error: Error) => void;\n\nexport type ChatOnToolCallCallback<UI_MESSAGE extends UIMessage = UIMessage> =\n  (options: {\n    toolCall: InferUIMessageToolCall<UI_MESSAGE>;\n  }) => void | PromiseLike<void>;\n\nexport type ChatOnDataCallback<UI_MESSAGE extends UIMessage> = (\n  dataPart: DataUIPart<InferUIMessageData<UI_MESSAGE>>,\n) => void;\n\n/**\n * Function that is called when the assistant response has finished streaming.\n *\n * @param message The assistant message that was streamed.\n * @param messages The full chat history, including the assistant message.\n *\n * @param isAbort Indicates whether the request has been aborted.\n * @param isDisconnect Indicates whether the request has been ended by a network error.\n * @param isError Indicates whether the request has been ended by an error.\n * @param finishReason The reason why the generation finished.\n */\nexport type ChatOnFinishCallback<UI_MESSAGE extends UIMessage> = (options: {\n  message: UI_MESSAGE;\n  messages: UI_MESSAGE[];\n  isAbort: boolean;\n  isDisconnect: boolean;\n  isError: boolean;\n  finishReason?: FinishReason;\n}) => void;\n\nexport interface ChatInit<UI_MESSAGE extends UIMessage> {\n  /**\n   * A unique identifier for the chat. If not provided, a random one will be\n   * generated.\n   */\n  id?: string;\n\n  messageMetadataSchema?: FlexibleSchema<InferUIMessageMetadata<UI_MESSAGE>>;\n  dataPartSchemas?: UIDataTypesToSchemas<InferUIMessageData<UI_MESSAGE>>;\n\n  messages?: UI_MESSAGE[];\n\n  /**\n   * A way to provide a function that is going to be used for ids for messages and the chat.\n   * If not provided the default AI SDK `generateId` is used.\n   */\n  generateId?: IdGenerator;\n\n  transport?: ChatTransport<UI_MESSAGE>;\n\n  /**\n   * Callback function to be called when an error is encountered.\n   */\n  onError?: ChatOnErrorCallback;\n\n  /**\n  Optional callback function that is invoked when a tool call is received.\n  Intended for automatic client-side tool execution.\n\n  You can optionally return a result for the tool call,\n  either synchronously or asynchronously.\n     */\n  onToolCall?: ChatOnToolCallCallback<UI_MESSAGE>;\n\n  /**\n   * Function that is called when the assistant response has finished streaming.\n   */\n  onFinish?: ChatOnFinishCallback<UI_MESSAGE>;\n\n  /**\n   * Optional callback function that is called when a data part is received.\n   *\n   * @param data The data part that was received.\n   */\n  onData?: ChatOnDataCallback<UI_MESSAGE>;\n\n  /**\n   * When provided, this function will be called when the stream is finished or a tool call is added\n   * to determine if the current messages should be resubmitted.\n   */\n  sendAutomaticallyWhen?: (options: {\n    messages: UI_MESSAGE[];\n  }) => boolean | PromiseLike<boolean>;\n}\n\nexport abstract class AbstractChat<UI_MESSAGE extends UIMessage> {\n  readonly id: string;\n  readonly generateId: IdGenerator;\n\n  protected state: ChatState<UI_MESSAGE>;\n\n  private messageMetadataSchema:\n    | FlexibleSchema<InferUIMessageMetadata<UI_MESSAGE>>\n    | undefined;\n  private dataPartSchemas:\n    | UIDataTypesToSchemas<InferUIMessageData<UI_MESSAGE>>\n    | undefined;\n  private readonly transport: ChatTransport<UI_MESSAGE>;\n  private onError?: ChatInit<UI_MESSAGE>['onError'];\n  private onToolCall?: ChatInit<UI_MESSAGE>['onToolCall'];\n  private onFinish?: ChatInit<UI_MESSAGE>['onFinish'];\n  private onData?: ChatInit<UI_MESSAGE>['onData'];\n  private sendAutomaticallyWhen?: ChatInit<UI_MESSAGE>['sendAutomaticallyWhen'];\n\n  private activeResponse: ActiveResponse<UI_MESSAGE> | undefined = undefined;\n  private jobExecutor = new SerialJobExecutor();\n\n  constructor({\n    generateId = generateIdFunc,\n    id = generateId(),\n    transport = new DefaultChatTransport(),\n    messageMetadataSchema,\n    dataPartSchemas,\n    state,\n    onError,\n    onToolCall,\n    onFinish,\n    onData,\n    sendAutomaticallyWhen,\n  }: Omit<ChatInit<UI_MESSAGE>, 'messages'> & {\n    state: ChatState<UI_MESSAGE>;\n  }) {\n    this.id = id;\n    this.transport = transport;\n    this.generateId = generateId;\n    this.messageMetadataSchema = messageMetadataSchema;\n    this.dataPartSchemas = dataPartSchemas;\n    this.state = state;\n    this.onError = onError;\n    this.onToolCall = onToolCall;\n    this.onFinish = onFinish;\n    this.onData = onData;\n    this.sendAutomaticallyWhen = sendAutomaticallyWhen;\n  }\n\n  /**\n   * Hook status:\n   *\n   * - `submitted`: The message has been sent to the API and we're awaiting the start of the response stream.\n   * - `streaming`: The response is actively streaming in from the API, receiving chunks of data.\n   * - `ready`: The full response has been received and processed; a new user message can be submitted.\n   * - `error`: An error occurred during the API request, preventing successful completion.\n   */\n  get status(): ChatStatus {\n    return this.state.status;\n  }\n\n  protected setStatus({\n    status,\n    error,\n  }: {\n    status: ChatStatus;\n    error?: Error;\n  }) {\n    if (this.status === status) return;\n\n    this.state.status = status;\n    this.state.error = error;\n  }\n\n  get error() {\n    return this.state.error;\n  }\n\n  get messages(): UI_MESSAGE[] {\n    return this.state.messages;\n  }\n\n  get lastMessage(): UI_MESSAGE | undefined {\n    return this.state.messages[this.state.messages.length - 1];\n  }\n\n  set messages(messages: UI_MESSAGE[]) {\n    this.state.messages = messages;\n  }\n\n  /**\n   * Appends or replaces a user message to the chat list. This triggers the API call to fetch\n   * the assistant's response.\n   *\n   * If a messageId is provided, the message will be replaced.\n   */\n  sendMessage = async (\n    message?:\n      | (CreateUIMessage<UI_MESSAGE> & {\n          text?: never;\n          files?: never;\n          messageId?: string;\n        })\n      | {\n          text: string;\n          files?: FileList | FileUIPart[];\n          metadata?: InferUIMessageMetadata<UI_MESSAGE>;\n          parts?: never;\n          messageId?: string;\n        }\n      | {\n          files: FileList | FileUIPart[];\n          metadata?: InferUIMessageMetadata<UI_MESSAGE>;\n          parts?: never;\n          messageId?: string;\n        },\n    options?: ChatRequestOptions,\n  ): Promise<void> => {\n    if (message == null) {\n      await this.makeRequest({\n        trigger: 'submit-message',\n        messageId: this.lastMessage?.id,\n        ...options,\n      });\n      return;\n    }\n\n    let uiMessage: CreateUIMessage<UI_MESSAGE>;\n\n    if ('text' in message || 'files' in message) {\n      const fileParts = Array.isArray(message.files)\n        ? message.files\n        : await convertFileListToFileUIParts(message.files);\n\n      uiMessage = {\n        parts: [\n          ...fileParts,\n          ...('text' in message && message.text != null\n            ? [{ type: 'text' as const, text: message.text }]\n            : []),\n        ],\n      } as UI_MESSAGE;\n    } else {\n      uiMessage = message;\n    }\n\n    if (message.messageId != null) {\n      const messageIndex = this.state.messages.findIndex(\n        m => m.id === message.messageId,\n      );\n\n      if (messageIndex === -1) {\n        throw new Error(`message with id ${message.messageId} not found`);\n      }\n\n      if (this.state.messages[messageIndex].role !== 'user') {\n        throw new Error(\n          `message with id ${message.messageId} is not a user message`,\n        );\n      }\n\n      // remove all messages after the message with the given id\n      this.state.messages = this.state.messages.slice(0, messageIndex + 1);\n\n      // update the message with the new content\n      this.state.replaceMessage(messageIndex, {\n        ...uiMessage,\n        id: message.messageId,\n        role: uiMessage.role ?? 'user',\n        metadata: message.metadata,\n      } as UI_MESSAGE);\n    } else {\n      this.state.pushMessage({\n        ...uiMessage,\n        id: uiMessage.id ?? this.generateId(),\n        role: uiMessage.role ?? 'user',\n        metadata: message.metadata,\n      } as UI_MESSAGE);\n    }\n\n    await this.makeRequest({\n      trigger: 'submit-message',\n      messageId: message.messageId,\n      ...options,\n    });\n  };\n\n  /**\n   * Regenerate the assistant message with the provided message id.\n   * If no message id is provided, the last assistant message will be regenerated.\n   */\n  regenerate = async ({\n    messageId,\n    ...options\n  }: {\n    messageId?: string;\n  } & ChatRequestOptions = {}): Promise<void> => {\n    const messageIndex =\n      messageId == null\n        ? this.state.messages.length - 1\n        : this.state.messages.findIndex(message => message.id === messageId);\n\n    if (messageIndex === -1) {\n      throw new Error(`message ${messageId} not found`);\n    }\n\n    // set the messages to the message before the assistant message\n    this.state.messages = this.state.messages.slice(\n      0,\n      // if the message is a user message, we need to include it in the request:\n      this.messages[messageIndex].role === 'assistant'\n        ? messageIndex\n        : messageIndex + 1,\n    );\n\n    await this.makeRequest({\n      trigger: 'regenerate-message',\n      messageId,\n      ...options,\n    });\n  };\n\n  /**\n   * Attempt to resume an ongoing streaming response.\n   */\n  resumeStream = async (options: ChatRequestOptions = {}): Promise<void> => {\n    await this.makeRequest({ trigger: 'resume-stream', ...options });\n  };\n\n  /**\n   * Clear the error state and set the status to ready if the chat is in an error state.\n   */\n  clearError = () => {\n    if (this.status === 'error') {\n      this.state.error = undefined;\n      this.setStatus({ status: 'ready' });\n    }\n  };\n\n  addToolApprovalResponse: ChatAddToolApproveResponseFunction = async ({\n    id,\n    approved,\n    reason,\n  }) =>\n    this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      const updatePart = (\n        part: UIMessagePart<UIDataTypes, UITools>,\n      ): UIMessagePart<UIDataTypes, UITools> =>\n        isToolUIPart(part) &&\n        part.state === 'approval-requested' &&\n        part.approval.id === id\n          ? {\n              ...part,\n              state: 'approval-responded',\n              approval: { id, approved, reason },\n            }\n          : part;\n\n      // update the message to trigger an immediate UI update\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart),\n      });\n\n      // update the active response if it exists\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts =\n          this.activeResponse.state.message.parts.map(updatePart);\n      }\n\n      // automatically send the message if the sendAutomaticallyWhen function returns true\n      if (\n        this.status !== 'streaming' &&\n        this.status !== 'submitted' &&\n        this.sendAutomaticallyWhen?.({ messages: this.state.messages })\n      ) {\n        // no await to avoid deadlocking\n        this.makeRequest({\n          trigger: 'submit-message',\n          messageId: this.lastMessage?.id,\n        });\n      }\n    });\n\n  addToolOutput = async <TOOL extends keyof InferUIMessageTools<UI_MESSAGE>>({\n    state = 'output-available',\n    tool,\n    toolCallId,\n    output,\n    errorText,\n  }:\n    | {\n        state?: 'output-available';\n        tool: TOOL;\n        toolCallId: string;\n        output: InferUIMessageTools<UI_MESSAGE>[TOOL]['output'];\n        errorText?: never;\n      }\n    | {\n        state: 'output-error';\n        tool: TOOL;\n        toolCallId: string;\n        output?: never;\n        errorText: string;\n      }) =>\n    this.jobExecutor.run(async () => {\n      const messages = this.state.messages;\n      const lastMessage = messages[messages.length - 1];\n\n      const updatePart = (\n        part: UIMessagePart<UIDataTypes, UITools>,\n      ): UIMessagePart<UIDataTypes, UITools> =>\n        isToolUIPart(part) && part.toolCallId === toolCallId\n          ? ({ ...part, state, output, errorText } as typeof part)\n          : part;\n\n      // update the message to trigger an immediate UI update\n      this.state.replaceMessage(messages.length - 1, {\n        ...lastMessage,\n        parts: lastMessage.parts.map(updatePart),\n      });\n\n      // update the active response if it exists\n      if (this.activeResponse) {\n        this.activeResponse.state.message.parts =\n          this.activeResponse.state.message.parts.map(updatePart);\n      }\n\n      // automatically send the message if the sendAutomaticallyWhen function returns true\n      if (\n        this.status !== 'streaming' &&\n        this.status !== 'submitted' &&\n        this.sendAutomaticallyWhen?.({ messages: this.state.messages })\n      ) {\n        // no await to avoid deadlocking\n        this.makeRequest({\n          trigger: 'submit-message',\n          messageId: this.lastMessage?.id,\n        });\n      }\n    });\n\n  /** @deprecated Use addToolOutput */\n  addToolResult = this.addToolOutput;\n\n  /**\n   * Abort the current request immediately, keep the generated tokens if any.\n   */\n  stop = async () => {\n    if (this.status !== 'streaming' && this.status !== 'submitted') return;\n\n    if (this.activeResponse?.abortController) {\n      this.activeResponse.abortController.abort();\n    }\n  };\n\n  private async makeRequest({\n    trigger,\n    metadata,\n    headers,\n    body,\n    messageId,\n  }: {\n    trigger: 'submit-message' | 'resume-stream' | 'regenerate-message';\n    messageId?: string;\n  } & ChatRequestOptions) {\n    this.setStatus({ status: 'submitted', error: undefined });\n\n    const lastMessage = this.lastMessage;\n\n    let isAbort = false;\n    let isDisconnect = false;\n    let isError = false;\n\n    try {\n      const activeResponse = {\n        state: createStreamingUIMessageState({\n          lastMessage: this.state.snapshot(lastMessage),\n          messageId: this.generateId(),\n        }),\n        abortController: new AbortController(),\n      } as ActiveResponse<UI_MESSAGE>;\n\n      activeResponse.abortController.signal.addEventListener('abort', () => {\n        isAbort = true;\n      });\n\n      this.activeResponse = activeResponse;\n\n      let stream: ReadableStream<UIMessageChunk>;\n\n      if (trigger === 'resume-stream') {\n        const reconnect = await this.transport.reconnectToStream({\n          chatId: this.id,\n          metadata,\n          headers,\n          body,\n        });\n\n        if (reconnect == null) {\n          this.setStatus({ status: 'ready' });\n          return; // no active stream found, so we do not resume\n        }\n\n        stream = reconnect;\n      } else {\n        stream = await this.transport.sendMessages({\n          chatId: this.id,\n          messages: this.state.messages,\n          abortSignal: activeResponse.abortController.signal,\n          metadata,\n          headers,\n          body,\n          trigger,\n          messageId,\n        });\n      }\n\n      const runUpdateMessageJob = (\n        job: (options: {\n          state: StreamingUIMessageState<UI_MESSAGE>;\n          write: () => void;\n        }) => Promise<void>,\n      ) =>\n        // serialize the job execution to avoid race conditions:\n        this.jobExecutor.run(() =>\n          job({\n            state: activeResponse.state,\n            write: () => {\n              // streaming is set on first write (before it should be \"submitted\")\n              this.setStatus({ status: 'streaming' });\n\n              const replaceLastMessage =\n                activeResponse.state.message.id === this.lastMessage?.id;\n\n              if (replaceLastMessage) {\n                this.state.replaceMessage(\n                  this.state.messages.length - 1,\n                  activeResponse.state.message,\n                );\n              } else {\n                this.state.pushMessage(activeResponse.state.message);\n              }\n            },\n          }),\n        );\n\n      await consumeStream({\n        stream: processUIMessageStream({\n          stream,\n          onToolCall: this.onToolCall,\n          onData: this.onData,\n          messageMetadataSchema: this.messageMetadataSchema,\n          dataPartSchemas: this.dataPartSchemas,\n          runUpdateMessageJob,\n          onError: error => {\n            throw error;\n          },\n        }),\n        onError: error => {\n          throw error;\n        },\n      });\n\n      this.setStatus({ status: 'ready' });\n    } catch (err) {\n      // Ignore abort errors as they are expected.\n      if (isAbort || (err as any).name === 'AbortError') {\n        isAbort = true;\n        this.setStatus({ status: 'ready' });\n        return null;\n      }\n\n      isError = true;\n\n      // Network errors such as disconnected, timeout, etc.\n      if (\n        err instanceof TypeError &&\n        (err.message.toLowerCase().includes('fetch') ||\n          err.message.toLowerCase().includes('network'))\n      ) {\n        isDisconnect = true;\n      }\n\n      if (this.onError && err instanceof Error) {\n        this.onError(err);\n      }\n\n      this.setStatus({ status: 'error', error: err as Error });\n    } finally {\n      try {\n        this.onFinish?.({\n          message: this.activeResponse!.state.message,\n          messages: this.state.messages,\n          isAbort,\n          isDisconnect,\n          isError,\n          finishReason: this.activeResponse?.state.finishReason,\n        });\n      } catch (err) {\n        console.error(err);\n      }\n\n      this.activeResponse = undefined;\n    }\n\n    // automatically send the message if the sendAutomaticallyWhen function returns true\n    if (\n      this.sendAutomaticallyWhen?.({ messages: this.state.messages }) &&\n      !isError\n    ) {\n      await this.makeRequest({\n        trigger: 'submit-message',\n        messageId: this.lastMessage?.id,\n        metadata,\n        headers,\n        body,\n      });\n    }\n  }\n}\n","import { FileUIPart } from './ui-messages';\n\nexport async function convertFileListToFileUIParts(\n  files: FileList | undefined,\n): Promise<Array<FileUIPart>> {\n  if (files == null) {\n    return [];\n  }\n\n  // React-native doesn't have a FileList global:\n  if (!globalThis.FileList || !(files instanceof globalThis.FileList)) {\n    throw new Error('FileList is not supported in the current environment');\n  }\n\n  return Promise.all(\n    Array.from(files).map(async file => {\n      const { name, type } = file;\n\n      const dataUrl = await new Promise<string>((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = readerEvent => {\n          resolve(readerEvent.target?.result as string);\n        };\n        reader.onerror = error => reject(error);\n        reader.readAsDataURL(file);\n      });\n\n      return {\n        type: 'file',\n        mediaType: type,\n        filename: name,\n        url: dataUrl,\n      };\n    }),\n  );\n}\n","import { parseJsonEventStream, ParseResult } from '@ai-sdk/provider-utils';\nimport {\n  UIMessageChunk,\n  uiMessageChunkSchema,\n} from '../ui-message-stream/ui-message-chunks';\nimport {\n  HttpChatTransport,\n  HttpChatTransportInitOptions,\n} from './http-chat-transport';\nimport { UIMessage } from './ui-messages';\n\nexport class DefaultChatTransport<\n  UI_MESSAGE extends UIMessage,\n> extends HttpChatTransport<UI_MESSAGE> {\n  constructor(options: HttpChatTransportInitOptions<UI_MESSAGE> = {}) {\n    super(options);\n  }\n\n  protected processResponseStream(\n    stream: ReadableStream<Uint8Array<ArrayBufferLike>>,\n  ): ReadableStream<UIMessageChunk> {\n    return parseJsonEventStream({\n      stream,\n      schema: uiMessageChunkSchema,\n    }).pipeThrough(\n      new TransformStream<ParseResult<UIMessageChunk>, UIMessageChunk>({\n        async transform(chunk, controller) {\n          if (!chunk.success) {\n            throw chunk.error;\n          }\n          controller.enqueue(chunk.value);\n        },\n      }),\n    );\n  }\n}\n","import {\n  FetchFunction,\n  Resolvable,\n  normalizeHeaders,\n  resolve,\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport { UIMessageChunk } from '../ui-message-stream/ui-message-chunks';\nimport { ChatTransport } from './chat-transport';\nimport { UIMessage } from './ui-messages';\nimport { VERSION } from '../version';\n\nexport type PrepareSendMessagesRequest<UI_MESSAGE extends UIMessage> = (\n  options: {\n    id: string;\n    messages: UI_MESSAGE[];\n    requestMetadata: unknown;\n    body: Record<string, any> | undefined;\n    credentials: RequestCredentials | undefined;\n    headers: HeadersInit | undefined;\n    api: string;\n  } & {\n    trigger: 'submit-message' | 'regenerate-message';\n    messageId: string | undefined;\n  },\n) =>\n  | {\n      body: object;\n      headers?: HeadersInit;\n      credentials?: RequestCredentials;\n      api?: string;\n    }\n  | PromiseLike<{\n      body: object;\n      headers?: HeadersInit;\n      credentials?: RequestCredentials;\n      api?: string;\n    }>;\n\nexport type PrepareReconnectToStreamRequest = (options: {\n  id: string;\n  requestMetadata: unknown;\n  body: Record<string, any> | undefined;\n  credentials: RequestCredentials | undefined;\n  headers: HeadersInit | undefined;\n  api: string;\n}) =>\n  | {\n      headers?: HeadersInit;\n      credentials?: RequestCredentials;\n      api?: string;\n    }\n  | PromiseLike<{\n      headers?: HeadersInit;\n      credentials?: RequestCredentials;\n      api?: string;\n    }>;\n\n/**\n * Options for the `HttpChatTransport` class.\n *\n * @param UI_MESSAGE - The type of message to be used in the chat.\n */\nexport type HttpChatTransportInitOptions<UI_MESSAGE extends UIMessage> = {\n  /**\n   * The API URL to be used for the chat transport.\n   * Defaults to '/api/chat'.\n   */\n  api?: string;\n\n  /**\n   * The credentials mode to be used for the fetch request.\n   * Possible values are: 'omit', 'same-origin', 'include'.\n   * Defaults to 'same-origin'.\n   */\n  credentials?: Resolvable<RequestCredentials>;\n\n  /**\n   * HTTP headers to be sent with the API request.\n   */\n  headers?: Resolvable<Record<string, string> | Headers>;\n\n  /**\n   * Extra body object to be sent with the API request.\n   * @example\n   * Send a `sessionId` to the API along with the messages.\n   * ```js\n   * useChat({\n   *   body: {\n   *     sessionId: '123',\n   *   }\n   * })\n   * ```\n   */\n  body?: Resolvable<object>;\n\n  /**\n  Custom fetch implementation. You can use it as a middleware to intercept requests,\n  or to provide a custom fetch implementation for e.g. testing.\n      */\n  fetch?: FetchFunction;\n\n  /**\n   * When a function is provided, it will be used\n   * to prepare the request body for the chat API. This can be useful for\n   * customizing the request body based on the messages and data in the chat.\n   *\n   * @param id The id of the chat.\n   * @param messages The current messages in the chat.\n   * @param requestBody The request body object passed in the chat request.\n   */\n  prepareSendMessagesRequest?: PrepareSendMessagesRequest<UI_MESSAGE>;\n\n  /**\n   * When a function is provided, it will be used\n   * to prepare the request body for the chat API. This can be useful for\n   * customizing the request body based on the messages and data in the chat.\n   *\n   * @param id The id of the chat.\n   * @param messages The current messages in the chat.\n   * @param requestBody The request body object passed in the chat request.\n   */\n  prepareReconnectToStreamRequest?: PrepareReconnectToStreamRequest;\n};\n\nexport abstract class HttpChatTransport<UI_MESSAGE extends UIMessage>\n  implements ChatTransport<UI_MESSAGE>\n{\n  protected api: string;\n  protected credentials: HttpChatTransportInitOptions<UI_MESSAGE>['credentials'];\n  protected headers: HttpChatTransportInitOptions<UI_MESSAGE>['headers'];\n  protected body: HttpChatTransportInitOptions<UI_MESSAGE>['body'];\n  protected fetch?: FetchFunction;\n  protected prepareSendMessagesRequest?: PrepareSendMessagesRequest<UI_MESSAGE>;\n  protected prepareReconnectToStreamRequest?: PrepareReconnectToStreamRequest;\n\n  constructor({\n    api = '/api/chat',\n    credentials,\n    headers,\n    body,\n    fetch,\n    prepareSendMessagesRequest,\n    prepareReconnectToStreamRequest,\n  }: HttpChatTransportInitOptions<UI_MESSAGE>) {\n    this.api = api;\n    this.credentials = credentials;\n    this.headers = headers;\n    this.body = body;\n    this.fetch = fetch;\n    this.prepareSendMessagesRequest = prepareSendMessagesRequest;\n    this.prepareReconnectToStreamRequest = prepareReconnectToStreamRequest;\n  }\n\n  async sendMessages({\n    abortSignal,\n    ...options\n  }: Parameters<ChatTransport<UI_MESSAGE>['sendMessages']>[0]) {\n    const resolvedBody = await resolve(this.body);\n    const resolvedHeaders = await resolve(this.headers);\n    const resolvedCredentials = await resolve(this.credentials);\n\n    const baseHeaders = {\n      ...normalizeHeaders(resolvedHeaders),\n      ...normalizeHeaders(options.headers),\n    };\n\n    const preparedRequest = await this.prepareSendMessagesRequest?.({\n      api: this.api,\n      id: options.chatId,\n      messages: options.messages,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n      trigger: options.trigger,\n      messageId: options.messageId,\n    });\n\n    const api = preparedRequest?.api ?? this.api;\n    const headers =\n      preparedRequest?.headers !== undefined\n        ? normalizeHeaders(preparedRequest.headers)\n        : baseHeaders;\n    const body =\n      preparedRequest?.body !== undefined\n        ? preparedRequest.body\n        : {\n            ...resolvedBody,\n            ...options.body,\n            id: options.chatId,\n            messages: options.messages,\n            trigger: options.trigger,\n            messageId: options.messageId,\n          };\n    const credentials = preparedRequest?.credentials ?? resolvedCredentials;\n\n    // avoid caching globalThis.fetch in case it is patched by other libraries\n    const fetch = this.fetch ?? globalThis.fetch;\n\n    const response = await fetch(api, {\n      method: 'POST',\n      headers: withUserAgentSuffix(\n        {\n          'Content-Type': 'application/json',\n          ...headers,\n        },\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      body: JSON.stringify(body),\n      credentials,\n      signal: abortSignal,\n    });\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    return this.processResponseStream(response.body);\n  }\n\n  async reconnectToStream(\n    options: Parameters<ChatTransport<UI_MESSAGE>['reconnectToStream']>[0],\n  ): Promise<ReadableStream<UIMessageChunk> | null> {\n    const resolvedBody = await resolve(this.body);\n    const resolvedHeaders = await resolve(this.headers);\n    const resolvedCredentials = await resolve(this.credentials);\n\n    const baseHeaders = {\n      ...normalizeHeaders(resolvedHeaders),\n      ...normalizeHeaders(options.headers),\n    };\n\n    const preparedRequest = await this.prepareReconnectToStreamRequest?.({\n      api: this.api,\n      id: options.chatId,\n      body: { ...resolvedBody, ...options.body },\n      headers: baseHeaders,\n      credentials: resolvedCredentials,\n      requestMetadata: options.metadata,\n    });\n\n    const api = preparedRequest?.api ?? `${this.api}/${options.chatId}/stream`;\n    const headers =\n      preparedRequest?.headers !== undefined\n        ? normalizeHeaders(preparedRequest.headers)\n        : baseHeaders;\n    const credentials = preparedRequest?.credentials ?? resolvedCredentials;\n\n    // avoid caching globalThis.fetch in case it is patched by other libraries\n    const fetch = this.fetch ?? globalThis.fetch;\n\n    const response = await fetch(api, {\n      method: 'GET',\n      headers: withUserAgentSuffix(\n        headers,\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n      credentials,\n    });\n\n    // no active stream found, so we do not resume\n    if (response.status === 204) {\n      return null;\n    }\n\n    if (!response.ok) {\n      throw new Error(\n        (await response.text()) ?? 'Failed to fetch the chat response.',\n      );\n    }\n\n    if (!response.body) {\n      throw new Error('The response body is empty.');\n    }\n\n    return this.processResponseStream(response.body);\n  }\n\n  protected abstract processResponseStream(\n    stream: ReadableStream<Uint8Array<ArrayBufferLike>>,\n  ): ReadableStream<UIMessageChunk>;\n}\n","import { isToolUIPart, type UIMessage } from './ui-messages';\n\n/**\nCheck if the last message is an assistant message with completed tool call approvals.\nThe last step of the message must have at least one tool approval response and\nall tool approvals must have a response.\n */\nexport function lastAssistantMessageIsCompleteWithApprovalResponses({\n  messages,\n}: {\n  messages: UIMessage[];\n}): boolean {\n  const message = messages[messages.length - 1];\n\n  if (!message) {\n    return false;\n  }\n\n  if (message.role !== 'assistant') {\n    return false;\n  }\n\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === 'step-start' ? index : lastIndex;\n  }, -1);\n\n  const lastStepToolInvocations = message.parts\n    .slice(lastStepStartIndex + 1)\n    .filter(isToolUIPart)\n    .filter(part => !part.providerExecuted);\n\n  return (\n    // has at least one tool approval response\n    lastStepToolInvocations.filter(part => part.state === 'approval-responded')\n      .length > 0 &&\n    // all tool approvals must have a response\n    lastStepToolInvocations.every(\n      part =>\n        part.state === 'output-available' ||\n        part.state === 'output-error' ||\n        part.state === 'approval-responded',\n    )\n  );\n}\n","import { isToolUIPart, type UIMessage } from './ui-messages';\n\n/**\nCheck if the message is an assistant message with completed tool calls.\nThe last step of the message must have at least one tool invocation and\nall tool invocations must have a result.\n */\nexport function lastAssistantMessageIsCompleteWithToolCalls({\n  messages,\n}: {\n  messages: UIMessage[];\n}): boolean {\n  const message = messages[messages.length - 1];\n\n  if (!message) {\n    return false;\n  }\n\n  if (message.role !== 'assistant') {\n    return false;\n  }\n\n  const lastStepStartIndex = message.parts.reduce((lastIndex, part, index) => {\n    return part.type === 'step-start' ? index : lastIndex;\n  }, -1);\n\n  const lastStepToolInvocations = message.parts\n    .slice(lastStepStartIndex + 1)\n    .filter(isToolUIPart)\n    .filter(part => !part.providerExecuted);\n\n  return (\n    lastStepToolInvocations.length > 0 &&\n    lastStepToolInvocations.every(\n      part =>\n        part.state === 'output-available' || part.state === 'output-error',\n    )\n  );\n}\n","import { UIMessageChunk } from '../ui-message-stream/ui-message-chunks';\n\nexport function transformTextToUiMessageStream({\n  stream,\n}: {\n  stream: ReadableStream<string>;\n}) {\n  return stream.pipeThrough(\n    new TransformStream<string, UIMessageChunk>({\n      start(controller) {\n        controller.enqueue({ type: 'start' });\n        controller.enqueue({ type: 'start-step' });\n        controller.enqueue({ type: 'text-start', id: 'text-1' });\n      },\n\n      async transform(part, controller) {\n        controller.enqueue({ type: 'text-delta', id: 'text-1', delta: part });\n      },\n\n      async flush(controller) {\n        controller.enqueue({ type: 'text-end', id: 'text-1' });\n        controller.enqueue({ type: 'finish-step' });\n        controller.enqueue({ type: 'finish' });\n      },\n    }),\n  );\n}\n","import { UIMessageChunk } from '../ui-message-stream/ui-message-chunks';\nimport {\n  HttpChatTransport,\n  HttpChatTransportInitOptions,\n} from './http-chat-transport';\nimport { transformTextToUiMessageStream } from './transform-text-to-ui-message-stream';\nimport { UIMessage } from './ui-messages';\n\nexport class TextStreamChatTransport<\n  UI_MESSAGE extends UIMessage,\n> extends HttpChatTransport<UI_MESSAGE> {\n  constructor(options: HttpChatTransportInitOptions<UI_MESSAGE> = {}) {\n    super(options);\n  }\n\n  protected processResponseStream(\n    stream: ReadableStream<Uint8Array<ArrayBufferLike>>,\n  ): ReadableStream<UIMessageChunk> {\n    return transformTextToUiMessageStream({\n      stream: stream.pipeThrough(new TextDecoderStream()),\n    });\n  }\n}\n"],"mappings":"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","names":["import_gateway","import_provider_utils","import_provider_utils","import_provider","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","text","import_provider","name","marker","symbol","_a","import_provider","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","import_provider","name","marker","symbol","_a","_a","import_provider_utils","import_provider_utils","import_provider_utils","_a","download","import_provider","import_provider_utils","_a","download","_a","import_provider","tool","import_provider_utils","object","name","tool","import_provider","import_provider_utils","import_v4","import_v4","import_v4","import_v4","import_v4","import_gateway","import_provider","_a","name","import_api","name","_a","import_provider","import_provider_utils","import_provider_utils","tool","content","import_provider_utils","tool","import_provider","import_provider_utils","import_provider_utils","text","name","jsonSchema","import_provider_utils","_a","tool","_a","download","generateId","_a","output","callSettings","tool","span","_b","_c","_d","_e","_f","_g","_h","totalUsage","toolCall","import_provider","import_provider_utils","resolve","import_provider_utils","import_v4","import_provider_utils","_a","part","_b","_a","resolve","_a","import_provider_utils","generateId","tool","originalGenerateId","download","now","generateId","text","_a","result","output","includeRawChunks","stream","tool","doStreamSpan","_b","_c","_d","_e","_a","import_provider_utils","generateId","generateIdFunc","resolve","_a","import_provider_utils","_a","content","import_provider","import_provider_utils","import_v4","tool","import_provider_utils","_a","embedding","usage","import_provider_utils","array","_a","embeddings","warnings","providerMetadata","usage","import_provider_utils","_a","uint8Data","import_provider_utils","content","import_provider","import_provider_utils","_a","array","import_provider","import_provider_utils","originalGenerateId","download","generateId","jsonSchema","_a","span","result","text","reasoning","object","import_provider_utils","resolve","import_provider_utils","_a","delay","delayFunction","originalGenerateId","download","generateId","now","doStreamSpan","object","_a","error","import_provider_utils","text","_a","import_provider_utils","import_provider","delay","originalDelay","text","text","_a","tool","_a","doWrap","_a","import_provider","import_provider","name","marker","symbol","_a","import_provider","_a","_a","ranking","import_provider_utils","import_provider","_a","import_provider_utils","fetch","_a","import_provider_utils","name","resolve","_a","import_provider_utils","import_provider_utils","fetch","_a","generateId","generateIdFunc","_a","tool"]}