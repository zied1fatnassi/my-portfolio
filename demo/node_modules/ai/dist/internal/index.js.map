{"version":3,"sources":["../../internal/index.ts","../../src/prompt/convert-to-language-model-prompt.ts","../../src/util/detect-media-type.ts","../../src/util/download/download.ts","../../src/version.ts","../../src/util/download/download-function.ts","../../src/prompt/data-content.ts","../../src/prompt/split-data-url.ts","../../src/prompt/invalid-message-role-error.ts","../../src/util/as-array.ts","../../src/prompt/prepare-tools-and-tool-choice.ts","../../src/util/is-non-empty-object.ts","../../src/prompt/standardize-prompt.ts","../../src/prompt/message.ts","../../src/types/provider-metadata.ts","../../src/types/json-value.ts","../../src/prompt/content-part.ts","../../src/error/invalid-argument-error.ts","../../src/prompt/prepare-call-settings.ts","../../src/util/retry-with-exponential-backoff.ts","../../src/util/retry-error.ts","../../src/util/prepare-retries.ts","../../src/types/usage.ts"],"sourcesContent":["// internal re-exports\nexport { convertAsyncIteratorToReadableStream } from '@ai-sdk/provider-utils';\n\n// internal\nexport { convertToLanguageModelPrompt } from '../src/prompt/convert-to-language-model-prompt';\nexport { prepareToolsAndToolChoice } from '../src/prompt/prepare-tools-and-tool-choice';\nexport { standardizePrompt } from '../src/prompt/standardize-prompt';\nexport { prepareCallSettings } from '../src/prompt/prepare-call-settings';\nexport { prepareRetries } from '../src/util/prepare-retries';\nexport { asLanguageModelUsage } from '../src/types/usage';\n","import {\n  LanguageModelV3FilePart,\n  LanguageModelV3Message,\n  LanguageModelV3Prompt,\n  LanguageModelV3TextPart,\n  LanguageModelV3ToolResultOutput,\n} from '@ai-sdk/provider';\nimport {\n  DataContent,\n  FilePart,\n  ImagePart,\n  isUrlSupported,\n  ModelMessage,\n  ReasoningPart,\n  TextPart,\n  ToolCallPart,\n  ToolResultOutput,\n  ToolResultPart,\n} from '@ai-sdk/provider-utils';\nimport {\n  detectMediaType,\n  imageMediaTypeSignatures,\n} from '../util/detect-media-type';\nimport {\n  createDefaultDownloadFunction,\n  DownloadFunction,\n} from '../util/download/download-function';\nimport { convertToLanguageModelV3DataContent } from './data-content';\nimport { InvalidMessageRoleError } from './invalid-message-role-error';\nimport { StandardizedPrompt } from './standardize-prompt';\nimport { asArray } from '../util/as-array';\n\nexport async function convertToLanguageModelPrompt({\n  prompt,\n  supportedUrls,\n  download = createDefaultDownloadFunction(),\n}: {\n  prompt: StandardizedPrompt;\n  supportedUrls: Record<string, RegExp[]>;\n  download: DownloadFunction | undefined;\n}): Promise<LanguageModelV3Prompt> {\n  const downloadedAssets = await downloadAssets(\n    prompt.messages,\n    download,\n    supportedUrls,\n  );\n\n  const messages = [\n    ...(prompt.system != null\n      ? typeof prompt.system === 'string'\n        ? [{ role: 'system' as const, content: prompt.system }]\n        : asArray(prompt.system).map(message => ({\n            role: 'system' as const,\n            content: message.content,\n            providerOptions: message.providerOptions,\n          }))\n      : []),\n    ...prompt.messages.map(message =>\n      convertToLanguageModelMessage({ message, downloadedAssets }),\n    ),\n  ];\n\n  // combine consecutive tool messages into a single tool message\n  const combinedMessages = [];\n  for (const message of messages) {\n    if (message.role !== 'tool') {\n      combinedMessages.push(message);\n      continue;\n    }\n\n    const lastCombinedMessage = combinedMessages.at(-1);\n    if (lastCombinedMessage?.role === 'tool') {\n      lastCombinedMessage.content.push(...message.content);\n    } else {\n      combinedMessages.push(message);\n    }\n  }\n\n  return combinedMessages;\n}\n\n/**\n * Convert a ModelMessage to a LanguageModelV3Message.\n *\n * @param message The ModelMessage to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *   available if the model does not support URLs, null otherwise.\n */\nexport function convertToLanguageModelMessage({\n  message,\n  downloadedAssets,\n}: {\n  message: ModelMessage;\n  downloadedAssets: Record<\n    string,\n    { mediaType: string | undefined; data: Uint8Array }\n  >;\n}): LanguageModelV3Message {\n  const role = message.role;\n  switch (role) {\n    case 'system': {\n      return {\n        role: 'system',\n        content: message.content,\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'user': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'user',\n          content: [{ type: 'text', text: message.content }],\n          providerOptions: message.providerOptions,\n        };\n      }\n\n      return {\n        role: 'user',\n        content: message.content\n          .map(part => convertPartToLanguageModelPart(part, downloadedAssets))\n          // remove empty text parts:\n          .filter(part => part.type !== 'text' || part.text !== ''),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'assistant': {\n      if (typeof message.content === 'string') {\n        return {\n          role: 'assistant',\n          content: [{ type: 'text', text: message.content }],\n          providerOptions: message.providerOptions,\n        };\n      }\n\n      return {\n        role: 'assistant',\n        content: message.content\n          .filter(\n            // remove empty text parts (no text, and no provider options):\n            part =>\n              part.type !== 'text' ||\n              part.text !== '' ||\n              part.providerOptions != null,\n          )\n          .filter(\n            (\n              part,\n            ): part is\n              | TextPart\n              | FilePart\n              | ReasoningPart\n              | ToolCallPart\n              | ToolResultPart => part.type !== 'tool-approval-request',\n          )\n          .map(part => {\n            const providerOptions = part.providerOptions;\n\n            switch (part.type) {\n              case 'file': {\n                const { data, mediaType } = convertToLanguageModelV3DataContent(\n                  part.data,\n                );\n                return {\n                  type: 'file',\n                  data,\n                  filename: part.filename,\n                  mediaType: mediaType ?? part.mediaType,\n                  providerOptions,\n                };\n              }\n              case 'reasoning': {\n                return {\n                  type: 'reasoning',\n                  text: part.text,\n                  providerOptions,\n                };\n              }\n              case 'text': {\n                return {\n                  type: 'text' as const,\n                  text: part.text,\n                  providerOptions,\n                };\n              }\n              case 'tool-call': {\n                return {\n                  type: 'tool-call' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  input: part.input,\n                  providerExecuted: part.providerExecuted,\n                  providerOptions,\n                };\n              }\n              case 'tool-result': {\n                return {\n                  type: 'tool-result' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  output: mapToolResultOutput(part.output),\n                  providerOptions,\n                };\n              }\n            }\n          }),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    case 'tool': {\n      return {\n        role: 'tool',\n        content: message.content\n          .filter(\n            // Only include tool-approval-response for provider-executed tools\n            part =>\n              part.type !== 'tool-approval-response' || part.providerExecuted,\n          )\n          .map(part => {\n            switch (part.type) {\n              case 'tool-result': {\n                return {\n                  type: 'tool-result' as const,\n                  toolCallId: part.toolCallId,\n                  toolName: part.toolName,\n                  output: mapToolResultOutput(part.output),\n                  providerOptions: part.providerOptions,\n                };\n              }\n              case 'tool-approval-response': {\n                return {\n                  type: 'tool-approval-response' as const,\n                  approvalId: part.approvalId,\n                  approved: part.approved,\n                  reason: part.reason,\n                };\n              }\n            }\n          }),\n        providerOptions: message.providerOptions,\n      };\n    }\n\n    default: {\n      const _exhaustiveCheck: never = role;\n      throw new InvalidMessageRoleError({ role: _exhaustiveCheck });\n    }\n  }\n}\n\n/**\n * Downloads images and files from URLs in the messages.\n */\nasync function downloadAssets(\n  messages: ModelMessage[],\n  download: DownloadFunction,\n  supportedUrls: Record<string, RegExp[]>,\n): Promise<\n  Record<string, { mediaType: string | undefined; data: Uint8Array }>\n> {\n  const plannedDownloads = messages\n    .filter(message => message.role === 'user')\n    .map(message => message.content)\n    .filter((content): content is Array<TextPart | ImagePart | FilePart> =>\n      Array.isArray(content),\n    )\n    .flat()\n    .filter(\n      (part): part is ImagePart | FilePart =>\n        part.type === 'image' || part.type === 'file',\n    )\n    .map(part => {\n      const mediaType =\n        part.mediaType ?? (part.type === 'image' ? 'image/*' : undefined);\n\n      let data = part.type === 'image' ? part.image : part.data;\n      if (typeof data === 'string') {\n        try {\n          data = new URL(data);\n        } catch (ignored) {}\n      }\n\n      return { mediaType, data };\n    })\n\n    .filter(\n      (part): part is { mediaType: string | undefined; data: URL } =>\n        part.data instanceof URL,\n    )\n    .map(part => ({\n      url: part.data,\n      isUrlSupportedByModel:\n        part.mediaType != null &&\n        isUrlSupported({\n          url: part.data.toString(),\n          mediaType: part.mediaType,\n          supportedUrls,\n        }),\n    }));\n\n  // download in parallel:\n  const downloadedFiles = await download(plannedDownloads);\n\n  return Object.fromEntries(\n    downloadedFiles\n      .map((file, index) =>\n        file == null\n          ? null\n          : [\n              plannedDownloads[index].url.toString(),\n              { data: file.data, mediaType: file.mediaType },\n            ],\n      )\n      .filter(file => file != null),\n  );\n}\n\n/**\n * Convert part of a message to a LanguageModelV3Part.\n * @param part The part to convert.\n * @param downloadedAssets A map of URLs to their downloaded data. Only\n *  available if the model does not support URLs, null otherwise.\n *\n * @returns The converted part.\n */\nfunction convertPartToLanguageModelPart(\n  part: TextPart | ImagePart | FilePart,\n  downloadedAssets: Record<\n    string,\n    { mediaType: string | undefined; data: Uint8Array }\n  >,\n): LanguageModelV3TextPart | LanguageModelV3FilePart {\n  if (part.type === 'text') {\n    return {\n      type: 'text',\n      text: part.text,\n      providerOptions: part.providerOptions,\n    };\n  }\n\n  let originalData: DataContent | URL;\n  const type = part.type;\n  switch (type) {\n    case 'image':\n      originalData = part.image;\n      break;\n    case 'file':\n      originalData = part.data;\n\n      break;\n    default:\n      throw new Error(`Unsupported part type: ${type}`);\n  }\n\n  const { data: convertedData, mediaType: convertedMediaType } =\n    convertToLanguageModelV3DataContent(originalData);\n\n  let mediaType: string | undefined = convertedMediaType ?? part.mediaType;\n  let data: Uint8Array | string | URL = convertedData; // binary | base64 | url\n\n  // If the content is a URL, we check if it was downloaded:\n  if (data instanceof URL) {\n    const downloadedFile = downloadedAssets[data.toString()];\n    if (downloadedFile) {\n      data = downloadedFile.data;\n      mediaType ??= downloadedFile.mediaType;\n    }\n  }\n\n  // Now that we have the normalized data either as a URL or a Uint8Array,\n  // we can create the LanguageModelV3Part.\n  switch (type) {\n    case 'image': {\n      // When possible, try to detect the media type automatically\n      // to deal with incorrect media type inputs.\n      // When detection fails, use provided media type.\n      if (data instanceof Uint8Array || typeof data === 'string') {\n        mediaType =\n          detectMediaType({ data, signatures: imageMediaTypeSignatures }) ??\n          mediaType;\n      }\n\n      return {\n        type: 'file',\n        mediaType: mediaType ?? 'image/*', // any image\n        filename: undefined,\n        data,\n        providerOptions: part.providerOptions,\n      };\n    }\n\n    case 'file': {\n      // We must have a mediaType for files, if not, throw an error.\n      if (mediaType == null) {\n        throw new Error(`Media type is missing for file part`);\n      }\n\n      return {\n        type: 'file',\n        mediaType,\n        filename: part.filename,\n        data,\n        providerOptions: part.providerOptions,\n      };\n    }\n  }\n}\n\nfunction mapToolResultOutput(\n  output: ToolResultOutput,\n): LanguageModelV3ToolResultOutput {\n  if (output.type !== 'content') {\n    return output;\n  }\n\n  return {\n    type: 'content',\n    value: output.value.map(item => {\n      if (item.type !== 'media') {\n        return item;\n      }\n\n      // AI SDK 5 tool backwards compatibility:\n      // map media type to image-data or file-data\n      if (item.mediaType.startsWith('image/')) {\n        return {\n          type: 'image-data' as const,\n          data: item.data,\n          mediaType: item.mediaType,\n        };\n      }\n\n      return {\n        type: 'file-data' as const,\n        data: item.data,\n        mediaType: item.mediaType,\n      };\n    }),\n  };\n}\n","import { convertBase64ToUint8Array } from '@ai-sdk/provider-utils';\n\nexport const imageMediaTypeSignatures = [\n  {\n    mediaType: 'image/gif' as const,\n    bytesPrefix: [0x47, 0x49, 0x46], // GIF\n  },\n  {\n    mediaType: 'image/png' as const,\n    bytesPrefix: [0x89, 0x50, 0x4e, 0x47], // PNG\n  },\n  {\n    mediaType: 'image/jpeg' as const,\n    bytesPrefix: [0xff, 0xd8], // JPEG\n  },\n  {\n    mediaType: 'image/webp' as const,\n    bytesPrefix: [\n      0x52,\n      0x49,\n      0x46,\n      0x46, // \"RIFF\"\n      null,\n      null,\n      null,\n      null, // file size (variable)\n      0x57,\n      0x45,\n      0x42,\n      0x50, // \"WEBP\"\n    ],\n  },\n  {\n    mediaType: 'image/bmp' as const,\n    bytesPrefix: [0x42, 0x4d],\n  },\n  {\n    mediaType: 'image/tiff' as const,\n    bytesPrefix: [0x49, 0x49, 0x2a, 0x00],\n  },\n  {\n    mediaType: 'image/tiff' as const,\n    bytesPrefix: [0x4d, 0x4d, 0x00, 0x2a],\n  },\n  {\n    mediaType: 'image/avif' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x61, 0x76, 0x69, 0x66,\n    ],\n  },\n  {\n    mediaType: 'image/heic' as const,\n    bytesPrefix: [\n      0x00, 0x00, 0x00, 0x20, 0x66, 0x74, 0x79, 0x70, 0x68, 0x65, 0x69, 0x63,\n    ],\n  },\n] as const;\n\nexport const audioMediaTypeSignatures = [\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfb],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xfa],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xf3],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xf2],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xe3],\n  },\n  {\n    mediaType: 'audio/mpeg' as const,\n    bytesPrefix: [0xff, 0xe2],\n  },\n  {\n    mediaType: 'audio/wav' as const,\n    bytesPrefix: [\n      0x52, // R\n      0x49, // I\n      0x46, // F\n      0x46, // F\n      null,\n      null,\n      null,\n      null,\n      0x57, // W\n      0x41, // A\n      0x56, // V\n      0x45, // E\n    ],\n  },\n  {\n    mediaType: 'audio/ogg' as const,\n    bytesPrefix: [0x4f, 0x67, 0x67, 0x53],\n  },\n  {\n    mediaType: 'audio/flac' as const,\n    bytesPrefix: [0x66, 0x4c, 0x61, 0x43],\n  },\n  {\n    mediaType: 'audio/aac' as const,\n    bytesPrefix: [0x40, 0x15, 0x00, 0x00],\n  },\n  {\n    mediaType: 'audio/mp4' as const,\n    bytesPrefix: [0x66, 0x74, 0x79, 0x70],\n  },\n  {\n    mediaType: 'audio/webm',\n    bytesPrefix: [0x1a, 0x45, 0xdf, 0xa3],\n  },\n] as const;\n\nconst stripID3 = (data: Uint8Array | string) => {\n  const bytes =\n    typeof data === 'string' ? convertBase64ToUint8Array(data) : data;\n  const id3Size =\n    ((bytes[6] & 0x7f) << 21) |\n    ((bytes[7] & 0x7f) << 14) |\n    ((bytes[8] & 0x7f) << 7) |\n    (bytes[9] & 0x7f);\n\n  // The raw MP3 starts here\n  return bytes.slice(id3Size + 10);\n};\n\nfunction stripID3TagsIfPresent(data: Uint8Array | string): Uint8Array | string {\n  const hasId3 =\n    (typeof data === 'string' && data.startsWith('SUQz')) ||\n    (typeof data !== 'string' &&\n      data.length > 10 &&\n      data[0] === 0x49 && // 'I'\n      data[1] === 0x44 && // 'D'\n      data[2] === 0x33); // '3'\n\n  return hasId3 ? stripID3(data) : data;\n}\n\n/**\n * Detect the media IANA media type of a file using a list of signatures.\n *\n * @param data - The file data.\n * @param signatures - The signatures to use for detection.\n * @returns The media type of the file.\n */\nexport function detectMediaType({\n  data,\n  signatures,\n}: {\n  data: Uint8Array | string;\n  signatures: typeof audioMediaTypeSignatures | typeof imageMediaTypeSignatures;\n}): (typeof signatures)[number]['mediaType'] | undefined {\n  const processedData = stripID3TagsIfPresent(data);\n\n  // Convert the first ~18 bytes (24 base64 chars) for consistent detection logic:\n  const bytes =\n    typeof processedData === 'string'\n      ? convertBase64ToUint8Array(\n          processedData.substring(0, Math.min(processedData.length, 24)),\n        )\n      : processedData;\n\n  for (const signature of signatures) {\n    if (\n      bytes.length >= signature.bytesPrefix.length &&\n      signature.bytesPrefix.every(\n        (byte, index) => byte === null || bytes[index] === byte,\n      )\n    ) {\n      return signature.mediaType;\n    }\n  }\n\n  return undefined;\n}\n","import { DownloadError } from '@ai-sdk/provider-utils';\nimport {\n  withUserAgentSuffix,\n  getRuntimeEnvironmentUserAgent,\n} from '@ai-sdk/provider-utils';\nimport { VERSION } from '../../version';\n\n/**\n * Download a file from a URL.\n *\n * @param url - The URL to download from.\n * @returns The downloaded data and media type.\n *\n * @throws DownloadError if the download fails.\n */\nexport const download = async ({ url }: { url: URL }) => {\n  const urlText = url.toString();\n  try {\n    const response = await fetch(urlText, {\n      headers: withUserAgentSuffix(\n        {},\n        `ai-sdk/${VERSION}`,\n        getRuntimeEnvironmentUserAgent(),\n      ),\n    });\n\n    if (!response.ok) {\n      throw new DownloadError({\n        url: urlText,\n        statusCode: response.status,\n        statusText: response.statusText,\n      });\n    }\n\n    return {\n      data: new Uint8Array(await response.arrayBuffer()),\n      mediaType: response.headers.get('content-type') ?? undefined,\n    };\n  } catch (error) {\n    if (DownloadError.isInstance(error)) {\n      throw error;\n    }\n\n    throw new DownloadError({ url: urlText, cause: error });\n  }\n};\n","declare const __PACKAGE_VERSION__: string | undefined;\nexport const VERSION: string =\n  typeof __PACKAGE_VERSION__ !== 'undefined'\n    ? __PACKAGE_VERSION__\n    : '0.0.0-test';\n","import { download as originalDownload } from './download';\n\n/**\n * Experimental. Can change in patch versions without warning.\n *\n * Download function. Called with the array of URLs and a boolean indicating\n * whether the URL is supported by the model.\n *\n * The download function can decide for each URL:\n * - to return null (which means that the URL should be passed to the model)\n * - to download the asset and return the data (incl. retries, authentication, etc.)\n *\n * Should throw DownloadError if the download fails.\n *\n * Should return an array of objects sorted by the order of the requested downloads.\n * For each object, the data should be a Uint8Array if the URL was downloaded.\n * For each object, the mediaType should be the media type of the downloaded asset.\n * For each object, the data should be null if the URL should be passed through as is.\n */\nexport type DownloadFunction = (\n  options: Array<{\n    url: URL;\n    isUrlSupportedByModel: boolean;\n  }>,\n) => PromiseLike<\n  Array<{\n    data: Uint8Array;\n    mediaType: string | undefined;\n  } | null>\n>;\n\n/**\n * Default download function.\n * Downloads the file if it is not supported by the model.\n */\nexport const createDefaultDownloadFunction =\n  (download: typeof originalDownload = originalDownload): DownloadFunction =>\n  requestedDownloads =>\n    Promise.all(\n      requestedDownloads.map(async requestedDownload =>\n        requestedDownload.isUrlSupportedByModel\n          ? null\n          : download(requestedDownload),\n      ),\n    );\n","import { AISDKError, LanguageModelV3DataContent } from '@ai-sdk/provider';\nimport {\n  convertBase64ToUint8Array,\n  convertUint8ArrayToBase64,\n  DataContent,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { InvalidDataContentError } from './invalid-data-content-error';\nimport { splitDataUrl } from './split-data-url';\n\n/**\n@internal\n */\nexport const dataContentSchema: z.ZodType<DataContent> = z.union([\n  z.string(),\n  z.instanceof(Uint8Array),\n  z.instanceof(ArrayBuffer),\n  z.custom<Buffer>(\n    // Buffer might not be available in some environments such as CloudFlare:\n    (value: unknown): value is Buffer =>\n      globalThis.Buffer?.isBuffer(value) ?? false,\n    { message: 'Must be a Buffer' },\n  ),\n]);\n\nexport function convertToLanguageModelV3DataContent(\n  content: DataContent | URL,\n): {\n  data: LanguageModelV3DataContent;\n  mediaType: string | undefined;\n} {\n  // Buffer & Uint8Array:\n  if (content instanceof Uint8Array) {\n    return { data: content, mediaType: undefined };\n  }\n\n  // ArrayBuffer needs conversion to Uint8Array (lightweight):\n  if (content instanceof ArrayBuffer) {\n    return { data: new Uint8Array(content), mediaType: undefined };\n  }\n\n  // Attempt to create a URL from the data. If it fails, we can assume the data\n  // is not a URL and likely some other sort of data.\n  if (typeof content === 'string') {\n    try {\n      content = new URL(content);\n    } catch (error) {\n      // ignored\n    }\n  }\n\n  // Extract data from data URL:\n  if (content instanceof URL && content.protocol === 'data:') {\n    const { mediaType: dataUrlMediaType, base64Content } = splitDataUrl(\n      content.toString(),\n    );\n\n    if (dataUrlMediaType == null || base64Content == null) {\n      throw new AISDKError({\n        name: 'InvalidDataContentError',\n        message: `Invalid data URL format in content ${content.toString()}`,\n      });\n    }\n\n    return { data: base64Content, mediaType: dataUrlMediaType };\n  }\n\n  return { data: content, mediaType: undefined };\n}\n\n/**\nConverts data content to a base64-encoded string.\n\n@param content - Data content to convert.\n@returns Base64-encoded string.\n*/\nexport function convertDataContentToBase64String(content: DataContent): string {\n  if (typeof content === 'string') {\n    return content;\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return convertUint8ArrayToBase64(new Uint8Array(content));\n  }\n\n  return convertUint8ArrayToBase64(content);\n}\n\n/**\nConverts data content to a Uint8Array.\n\n@param content - Data content to convert.\n@returns Uint8Array.\n */\nexport function convertDataContentToUint8Array(\n  content: DataContent,\n): Uint8Array {\n  if (content instanceof Uint8Array) {\n    return content;\n  }\n\n  if (typeof content === 'string') {\n    try {\n      return convertBase64ToUint8Array(content);\n    } catch (error) {\n      throw new InvalidDataContentError({\n        message:\n          'Invalid data content. Content string is not a base64-encoded media.',\n        content,\n        cause: error,\n      });\n    }\n  }\n\n  if (content instanceof ArrayBuffer) {\n    return new Uint8Array(content);\n  }\n\n  throw new InvalidDataContentError({ content });\n}\n\n/**\n * Converts a Uint8Array to a string of text.\n *\n * @param uint8Array - The Uint8Array to convert.\n * @returns The converted string.\n */\nexport function convertUint8ArrayToText(uint8Array: Uint8Array): string {\n  try {\n    return new TextDecoder().decode(uint8Array);\n  } catch (error) {\n    throw new Error('Error decoding Uint8Array to text');\n  }\n}\n","export function splitDataUrl(dataUrl: string): {\n  mediaType: string | undefined;\n  base64Content: string | undefined;\n} {\n  try {\n    const [header, base64Content] = dataUrl.split(',');\n    return {\n      mediaType: header.split(';')[0].split(':')[1],\n      base64Content,\n    };\n  } catch (error) {\n    return {\n      mediaType: undefined,\n      base64Content: undefined,\n    };\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidMessageRoleError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidMessageRoleError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly role: string;\n\n  constructor({\n    role,\n    message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".`,\n  }: {\n    role: string;\n    message?: string;\n  }) {\n    super({ name, message });\n\n    this.role = role;\n  }\n\n  static isInstance(error: unknown): error is InvalidMessageRoleError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","export function asArray<T>(value: T | T[] | undefined): T[] {\n  return value === undefined ? [] : Array.isArray(value) ? value : [value];\n}\n","import {\n  LanguageModelV3FunctionTool,\n  LanguageModelV3ProviderTool,\n  LanguageModelV3ToolChoice,\n} from '@ai-sdk/provider';\nimport { asSchema } from '@ai-sdk/provider-utils';\nimport { isNonEmptyObject } from '../util/is-non-empty-object';\nimport { ToolSet } from '../generate-text';\nimport { ToolChoice } from '../types/language-model';\n\nexport async function prepareToolsAndToolChoice<TOOLS extends ToolSet>({\n  tools,\n  toolChoice,\n  activeTools,\n}: {\n  tools: TOOLS | undefined;\n  toolChoice: ToolChoice<TOOLS> | undefined;\n  activeTools: Array<keyof TOOLS> | undefined;\n}): Promise<{\n  tools:\n    | Array<LanguageModelV3FunctionTool | LanguageModelV3ProviderTool>\n    | undefined;\n  toolChoice: LanguageModelV3ToolChoice | undefined;\n}> {\n  if (!isNonEmptyObject(tools)) {\n    return {\n      tools: undefined,\n      toolChoice: undefined,\n    };\n  }\n\n  // when activeTools is provided, we only include the tools that are in the list:\n  const filteredTools =\n    activeTools != null\n      ? Object.entries(tools).filter(([name]) =>\n          activeTools.includes(name as keyof TOOLS),\n        )\n      : Object.entries(tools);\n\n  const languageModelTools: Array<\n    LanguageModelV3FunctionTool | LanguageModelV3ProviderTool\n  > = [];\n  for (const [name, tool] of filteredTools) {\n    const toolType = tool.type;\n\n    switch (toolType) {\n      case undefined:\n      case 'dynamic':\n      case 'function':\n        languageModelTools.push({\n          type: 'function' as const,\n          name,\n          description: tool.description,\n          inputSchema: await asSchema(tool.inputSchema).jsonSchema,\n          ...(tool.inputExamples != null\n            ? { inputExamples: tool.inputExamples }\n            : {}),\n          providerOptions: tool.providerOptions,\n          ...(tool.strict != null ? { strict: tool.strict } : {}),\n        });\n        break;\n      case 'provider':\n        languageModelTools.push({\n          type: 'provider' as const,\n          name,\n          id: tool.id,\n          args: tool.args,\n        });\n        break;\n      default: {\n        const exhaustiveCheck: never = toolType as never;\n        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n      }\n    }\n  }\n\n  return {\n    tools: languageModelTools,\n    toolChoice:\n      toolChoice == null\n        ? { type: 'auto' }\n        : typeof toolChoice === 'string'\n          ? { type: toolChoice }\n          : { type: 'tool' as const, toolName: toolChoice.toolName as string },\n  };\n}\n","export function isNonEmptyObject(\n  object: Record<string, unknown> | undefined | null,\n): object is Record<string, unknown> {\n  return object != null && Object.keys(object).length > 0;\n}\n","import { InvalidPromptError } from '@ai-sdk/provider';\nimport {\n  ModelMessage,\n  safeValidateTypes,\n  SystemModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { modelMessageSchema } from './message';\nimport { Prompt } from './prompt';\nimport { asArray } from '../util/as-array';\n\nexport type StandardizedPrompt = {\n  /**\n   * System message.\n   */\n  system?: string | SystemModelMessage | Array<SystemModelMessage>;\n\n  /**\n   * Messages.\n   */\n  messages: ModelMessage[];\n};\n\nexport async function standardizePrompt(\n  prompt: Prompt,\n): Promise<StandardizedPrompt> {\n  if (prompt.prompt == null && prompt.messages == null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (prompt.prompt != null && prompt.messages != null) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt and messages cannot be defined at the same time',\n    });\n  }\n\n  // validate that system is a string or a SystemModelMessage\n  if (\n    prompt.system != null &&\n    typeof prompt.system !== 'string' &&\n    !asArray(prompt.system).every(\n      message =>\n        typeof message === 'object' &&\n        message !== null &&\n        'role' in message &&\n        message.role === 'system',\n    )\n  ) {\n    throw new InvalidPromptError({\n      prompt,\n      message:\n        'system must be a string, SystemModelMessage, or array of SystemModelMessage',\n    });\n  }\n\n  let messages: ModelMessage[];\n\n  if (prompt.prompt != null && typeof prompt.prompt === 'string') {\n    messages = [{ role: 'user', content: prompt.prompt }];\n  } else if (prompt.prompt != null && Array.isArray(prompt.prompt)) {\n    messages = prompt.prompt;\n  } else if (prompt.messages != null) {\n    messages = prompt.messages;\n  } else {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'prompt or messages must be defined',\n    });\n  }\n\n  if (messages.length === 0) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'messages must not be empty',\n    });\n  }\n\n  const validationResult = await safeValidateTypes({\n    value: messages,\n    schema: z.array(modelMessageSchema),\n  });\n\n  if (!validationResult.success) {\n    throw new InvalidPromptError({\n      prompt,\n      message: 'The messages do not match the ModelMessage[] schema.',\n      cause: validationResult.error,\n    });\n  }\n\n  return {\n    messages,\n    system: prompt.system,\n  };\n}\n","import {\n  AssistantModelMessage,\n  ModelMessage,\n  SystemModelMessage,\n  ToolModelMessage,\n  UserModelMessage,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport {\n  filePartSchema,\n  imagePartSchema,\n  reasoningPartSchema,\n  textPartSchema,\n  toolApprovalRequestSchema,\n  toolCallPartSchema,\n  toolApprovalResponseSchema,\n  toolResultPartSchema,\n} from './content-part';\n\nexport const systemModelMessageSchema: z.ZodType<SystemModelMessage> = z.object(\n  {\n    role: z.literal('system'),\n    content: z.string(),\n    providerOptions: providerMetadataSchema.optional(),\n  },\n);\n\nexport const userModelMessageSchema: z.ZodType<UserModelMessage> = z.object({\n  role: z.literal('user'),\n  content: z.union([\n    z.string(),\n    z.array(z.union([textPartSchema, imagePartSchema, filePartSchema])),\n  ]),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\nexport const assistantModelMessageSchema: z.ZodType<AssistantModelMessage> =\n  z.object({\n    role: z.literal('assistant'),\n    content: z.union([\n      z.string(),\n      z.array(\n        z.union([\n          textPartSchema,\n          filePartSchema,\n          reasoningPartSchema,\n          toolCallPartSchema,\n          toolResultPartSchema,\n          toolApprovalRequestSchema,\n        ]),\n      ),\n    ]),\n    providerOptions: providerMetadataSchema.optional(),\n  });\n\nexport const toolModelMessageSchema: z.ZodType<ToolModelMessage> = z.object({\n  role: z.literal('tool'),\n  content: z.array(z.union([toolResultPartSchema, toolApprovalResponseSchema])),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\nexport const modelMessageSchema: z.ZodType<ModelMessage> = z.union([\n  systemModelMessageSchema,\n  userModelMessageSchema,\n  assistantModelMessageSchema,\n  toolModelMessageSchema,\n]);\n","import { SharedV3ProviderMetadata } from '@ai-sdk/provider';\nimport { z } from 'zod/v4';\nimport { jsonValueSchema } from './json-value';\n\n/**\nAdditional provider-specific metadata that is returned from the provider.\n\nThis is needed to enable provider-specific functionality that can be\nfully encapsulated in the provider.\n */\nexport type ProviderMetadata = SharedV3ProviderMetadata;\n\nexport const providerMetadataSchema: z.ZodType<ProviderMetadata> = z.record(\n  z.string(),\n  z.record(z.string(), jsonValueSchema.optional()),\n);\n","import { JSONValue as OriginalJSONValue } from '@ai-sdk/provider';\nimport { z } from 'zod/v4';\n\nexport const jsonValueSchema: z.ZodType<JSONValue> = z.lazy(() =>\n  z.union([\n    z.null(),\n    z.string(),\n    z.number(),\n    z.boolean(),\n    z.record(z.string(), jsonValueSchema.optional()),\n    z.array(jsonValueSchema),\n  ]),\n);\n\nexport type JSONValue = OriginalJSONValue;\n","import {\n  FilePart,\n  ImagePart,\n  ProviderOptions,\n  ReasoningPart,\n  TextPart,\n  ToolApprovalRequest,\n  ToolApprovalResponse,\n  ToolResultOutput,\n  ToolResultPart,\n} from '@ai-sdk/provider-utils';\nimport { z } from 'zod/v4';\nimport { jsonValueSchema } from '../types/json-value';\nimport { providerMetadataSchema } from '../types/provider-metadata';\nimport { dataContentSchema } from './data-content';\n\n/**\n@internal\n */\nexport const textPartSchema: z.ZodType<TextPart> = z.object({\n  type: z.literal('text'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const imagePartSchema: z.ZodType<ImagePart> = z.object({\n  type: z.literal('image'),\n  image: z.union([dataContentSchema, z.instanceof(URL)]),\n  mediaType: z.string().optional(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const filePartSchema: z.ZodType<FilePart> = z.object({\n  type: z.literal('file'),\n  data: z.union([dataContentSchema, z.instanceof(URL)]),\n  filename: z.string().optional(),\n  mediaType: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\n@internal\n */\nexport const reasoningPartSchema: z.ZodType<ReasoningPart> = z.object({\n  type: z.literal('reasoning'),\n  text: z.string(),\n  providerOptions: providerMetadataSchema.optional(),\n});\n\n/**\nTool call content part of a prompt. It contains a tool call (usually generated by the AI model).\n */\nexport interface ToolCallPart {\n  type: 'tool-call';\n\n  /**\nID of the tool call. This ID is used to match the tool call with the tool result.\n */\n  toolCallId: string;\n\n  /**\nName of the tool that is being called.\n */\n  toolName: string;\n\n  /**\nArguments of the tool call. This is a JSON-serializable object that matches the tool's input schema.\n   */\n  input: unknown;\n\n  /**\nAdditional provider-specific metadata. They are passed through\nto the provider from the AI SDK and enable provider-specific\nfunctionality that can be fully encapsulated in the provider.\n */\n  providerOptions?: ProviderOptions;\n}\n\n/**\n@internal\n */\nexport const toolCallPartSchema: z.ZodType<ToolCallPart> = z.object({\n  type: z.literal('tool-call'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  input: z.unknown(),\n  providerOptions: providerMetadataSchema.optional(),\n  providerExecuted: z.boolean().optional(),\n}) as z.ZodType<ToolCallPart>; // necessary bc input is optional on Zod type\n\n/**\n@internal\n */\nexport const outputSchema: z.ZodType<ToolResultOutput> = z.discriminatedUnion(\n  'type',\n  [\n    z.object({\n      type: z.literal('text'),\n      value: z.string(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('json'),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('execution-denied'),\n      reason: z.string().optional(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('error-text'),\n      value: z.string(),\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('error-json'),\n      value: jsonValueSchema,\n      providerOptions: providerMetadataSchema.optional(),\n    }),\n    z.object({\n      type: z.literal('content'),\n      value: z.array(\n        z.union([\n          z.object({\n            type: z.literal('text'),\n            text: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('media'),\n            data: z.string(),\n            mediaType: z.string(),\n          }),\n          z.object({\n            type: z.literal('file-data'),\n            data: z.string(),\n            mediaType: z.string(),\n            filename: z.string().optional(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('file-url'),\n            url: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('file-id'),\n            fileId: z.union([z.string(), z.record(z.string(), z.string())]),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-data'),\n            data: z.string(),\n            mediaType: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-url'),\n            url: z.string(),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('image-file-id'),\n            fileId: z.union([z.string(), z.record(z.string(), z.string())]),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n          z.object({\n            type: z.literal('custom'),\n            providerOptions: providerMetadataSchema.optional(),\n          }),\n        ]),\n      ),\n    }),\n  ],\n);\n\n/**\n@internal\n */\nexport const toolResultPartSchema: z.ZodType<ToolResultPart> = z.object({\n  type: z.literal('tool-result'),\n  toolCallId: z.string(),\n  toolName: z.string(),\n  output: outputSchema,\n  providerOptions: providerMetadataSchema.optional(),\n}) as z.ZodType<ToolResultPart>; // necessary bc result is optional on Zod type\n\nexport const toolApprovalRequestSchema: z.ZodType<ToolApprovalRequest> =\n  z.object({\n    type: z.literal('tool-approval-request'),\n    approvalId: z.string(),\n    toolCallId: z.string(),\n  });\n\nexport const toolApprovalResponseSchema: z.ZodType<ToolApprovalResponse> =\n  z.object({\n    type: z.literal('tool-approval-response'),\n    approvalId: z.string(),\n    approved: z.boolean(),\n    reason: z.string().optional(),\n  });\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_InvalidArgumentError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport class InvalidArgumentError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  readonly parameter: string;\n  readonly value: unknown;\n\n  constructor({\n    parameter,\n    value,\n    message,\n  }: {\n    parameter: string;\n    value: unknown;\n    message: string;\n  }) {\n    super({\n      name,\n      message: `Invalid argument for parameter ${parameter}: ${message}`,\n    });\n\n    this.parameter = parameter;\n    this.value = value;\n  }\n\n  static isInstance(error: unknown): error is InvalidArgumentError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { InvalidArgumentError } from '../error/invalid-argument-error';\nimport { CallSettings } from './call-settings';\n\n/**\n * Validates call settings and returns a new object with limited values.\n */\nexport function prepareCallSettings({\n  maxOutputTokens,\n  temperature,\n  topP,\n  topK,\n  presencePenalty,\n  frequencyPenalty,\n  seed,\n  stopSequences,\n}: Omit<CallSettings, 'abortSignal' | 'headers' | 'maxRetries'>): Omit<\n  CallSettings,\n  'abortSignal' | 'headers' | 'maxRetries'\n> {\n  if (maxOutputTokens != null) {\n    if (!Number.isInteger(maxOutputTokens)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxOutputTokens',\n        value: maxOutputTokens,\n        message: 'maxOutputTokens must be an integer',\n      });\n    }\n\n    if (maxOutputTokens < 1) {\n      throw new InvalidArgumentError({\n        parameter: 'maxOutputTokens',\n        value: maxOutputTokens,\n        message: 'maxOutputTokens must be >= 1',\n      });\n    }\n  }\n\n  if (temperature != null) {\n    if (typeof temperature !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'temperature',\n        value: temperature,\n        message: 'temperature must be a number',\n      });\n    }\n  }\n\n  if (topP != null) {\n    if (typeof topP !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topP',\n        value: topP,\n        message: 'topP must be a number',\n      });\n    }\n  }\n\n  if (topK != null) {\n    if (typeof topK !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'topK',\n        value: topK,\n        message: 'topK must be a number',\n      });\n    }\n  }\n\n  if (presencePenalty != null) {\n    if (typeof presencePenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'presencePenalty',\n        value: presencePenalty,\n        message: 'presencePenalty must be a number',\n      });\n    }\n  }\n\n  if (frequencyPenalty != null) {\n    if (typeof frequencyPenalty !== 'number') {\n      throw new InvalidArgumentError({\n        parameter: 'frequencyPenalty',\n        value: frequencyPenalty,\n        message: 'frequencyPenalty must be a number',\n      });\n    }\n  }\n\n  if (seed != null) {\n    if (!Number.isInteger(seed)) {\n      throw new InvalidArgumentError({\n        parameter: 'seed',\n        value: seed,\n        message: 'seed must be an integer',\n      });\n    }\n  }\n\n  return {\n    maxOutputTokens,\n    temperature,\n    topP,\n    topK,\n    presencePenalty,\n    frequencyPenalty,\n    stopSequences,\n    seed,\n  };\n}\n","import { APICallError } from '@ai-sdk/provider';\nimport { delay, getErrorMessage, isAbortError } from '@ai-sdk/provider-utils';\nimport { RetryError } from './retry-error';\n\nexport type RetryFunction = <OUTPUT>(\n  fn: () => PromiseLike<OUTPUT>,\n) => PromiseLike<OUTPUT>;\n\nfunction getRetryDelayInMs({\n  error,\n  exponentialBackoffDelay,\n}: {\n  error: APICallError;\n  exponentialBackoffDelay: number;\n}): number {\n  const headers = error.responseHeaders;\n\n  if (!headers) return exponentialBackoffDelay;\n\n  let ms: number | undefined;\n\n  // retry-ms is more precise than retry-after and used by e.g. OpenAI\n  const retryAfterMs = headers['retry-after-ms'];\n  if (retryAfterMs) {\n    const timeoutMs = parseFloat(retryAfterMs);\n    if (!Number.isNaN(timeoutMs)) {\n      ms = timeoutMs;\n    }\n  }\n\n  // About the Retry-After header: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Retry-After\n  const retryAfter = headers['retry-after'];\n  if (retryAfter && ms === undefined) {\n    const timeoutSeconds = parseFloat(retryAfter);\n    if (!Number.isNaN(timeoutSeconds)) {\n      ms = timeoutSeconds * 1000;\n    } else {\n      ms = Date.parse(retryAfter) - Date.now();\n    }\n  }\n\n  // check that the delay is reasonable:\n  if (\n    ms != null &&\n    !Number.isNaN(ms) &&\n    0 <= ms &&\n    (ms < 60 * 1000 || ms < exponentialBackoffDelay)\n  ) {\n    return ms;\n  }\n\n  return exponentialBackoffDelay;\n}\n\n/**\nThe `retryWithExponentialBackoffRespectingRetryHeaders` strategy retries a failed API call with an exponential backoff,\nwhile respecting rate limit headers (retry-after-ms and retry-after) if they are provided and reasonable (0-60 seconds).\nYou can configure the maximum number of retries, the initial delay, and the backoff factor.\n */\nexport const retryWithExponentialBackoffRespectingRetryHeaders =\n  ({\n    maxRetries = 2,\n    initialDelayInMs = 2000,\n    backoffFactor = 2,\n    abortSignal,\n  }: {\n    maxRetries?: number;\n    initialDelayInMs?: number;\n    backoffFactor?: number;\n    abortSignal?: AbortSignal;\n  } = {}): RetryFunction =>\n  async <OUTPUT>(f: () => PromiseLike<OUTPUT>) =>\n    _retryWithExponentialBackoff(f, {\n      maxRetries,\n      delayInMs: initialDelayInMs,\n      backoffFactor,\n      abortSignal,\n    });\n\nasync function _retryWithExponentialBackoff<OUTPUT>(\n  f: () => PromiseLike<OUTPUT>,\n  {\n    maxRetries,\n    delayInMs,\n    backoffFactor,\n    abortSignal,\n  }: {\n    maxRetries: number;\n    delayInMs: number;\n    backoffFactor: number;\n    abortSignal: AbortSignal | undefined;\n  },\n  errors: unknown[] = [],\n): Promise<OUTPUT> {\n  try {\n    return await f();\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error; // don't retry when the request was aborted\n    }\n\n    if (maxRetries === 0) {\n      throw error; // don't wrap the error when retries are disabled\n    }\n\n    const errorMessage = getErrorMessage(error);\n    const newErrors = [...errors, error];\n    const tryNumber = newErrors.length;\n\n    if (tryNumber > maxRetries) {\n      throw new RetryError({\n        message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n        reason: 'maxRetriesExceeded',\n        errors: newErrors,\n      });\n    }\n\n    if (\n      error instanceof Error &&\n      APICallError.isInstance(error) &&\n      error.isRetryable === true &&\n      tryNumber <= maxRetries\n    ) {\n      await delay(\n        getRetryDelayInMs({\n          error,\n          exponentialBackoffDelay: delayInMs,\n        }),\n        { abortSignal },\n      );\n\n      return _retryWithExponentialBackoff(\n        f,\n        {\n          maxRetries,\n          delayInMs: backoffFactor * delayInMs,\n          backoffFactor,\n          abortSignal,\n        },\n        newErrors,\n      );\n    }\n\n    if (tryNumber === 1) {\n      throw error; // don't wrap the error when a non-retryable error occurs on the first try\n    }\n\n    throw new RetryError({\n      message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n      reason: 'errorNotRetryable',\n      errors: newErrors,\n    });\n  }\n}\n","import { AISDKError } from '@ai-sdk/provider';\n\nconst name = 'AI_RetryError';\nconst marker = `vercel.ai.error.${name}`;\nconst symbol = Symbol.for(marker);\n\nexport type RetryErrorReason =\n  | 'maxRetriesExceeded'\n  | 'errorNotRetryable'\n  | 'abort';\n\nexport class RetryError extends AISDKError {\n  private readonly [symbol] = true; // used in isInstance\n\n  // note: property order determines debugging output\n  readonly reason: RetryErrorReason;\n  readonly lastError: unknown;\n  readonly errors: Array<unknown>;\n\n  constructor({\n    message,\n    reason,\n    errors,\n  }: {\n    message: string;\n    reason: RetryErrorReason;\n    errors: Array<unknown>;\n  }) {\n    super({ name, message });\n\n    this.reason = reason;\n    this.errors = errors;\n\n    // separate our last error to make debugging via log easier:\n    this.lastError = errors[errors.length - 1];\n  }\n\n  static isInstance(error: unknown): error is RetryError {\n    return AISDKError.hasMarker(error, marker);\n  }\n}\n","import { InvalidArgumentError } from '../error/invalid-argument-error';\nimport {\n  RetryFunction,\n  retryWithExponentialBackoffRespectingRetryHeaders,\n} from '../util/retry-with-exponential-backoff';\n\n/**\n * Validate and prepare retries.\n */\nexport function prepareRetries({\n  maxRetries,\n  abortSignal,\n}: {\n  maxRetries: number | undefined;\n  abortSignal: AbortSignal | undefined;\n}): {\n  maxRetries: number;\n  retry: RetryFunction;\n} {\n  if (maxRetries != null) {\n    if (!Number.isInteger(maxRetries)) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be an integer',\n      });\n    }\n\n    if (maxRetries < 0) {\n      throw new InvalidArgumentError({\n        parameter: 'maxRetries',\n        value: maxRetries,\n        message: 'maxRetries must be >= 0',\n      });\n    }\n  }\n\n  const maxRetriesResult = maxRetries ?? 2;\n\n  return {\n    maxRetries: maxRetriesResult,\n    retry: retryWithExponentialBackoffRespectingRetryHeaders({\n      maxRetries: maxRetriesResult,\n      abortSignal,\n    }),\n  };\n}\n","import {\n  ImageModelV3Usage,\n  JSONObject,\n  LanguageModelV3Usage,\n} from '@ai-sdk/provider';\n\n/**\n * Represents the number of tokens used in a prompt and completion.\n */\nexport type LanguageModelUsage = {\n  /**\n   * The total number of input (prompt) tokens used.\n   */\n  inputTokens: number | undefined;\n\n  /**\n   * Detailed information about the input tokens.\n   */\n  inputTokenDetails: {\n    /**\n     * The number of non-cached input (prompt) tokens used.\n     */\n    noCacheTokens: number | undefined;\n\n    /**\n     * The number of cached input (prompt) tokens read.\n     */\n    cacheReadTokens: number | undefined;\n\n    /**\n     * The number of cached input (prompt) tokens written.\n     */\n    cacheWriteTokens: number | undefined;\n  };\n\n  /**\n   * The number of total output (completion) tokens used.\n   */\n  outputTokens: number | undefined;\n\n  /**\n   * Detailed information about the output tokens.\n   */\n  outputTokenDetails: {\n    /**\n     * The number of text tokens used.\n     */\n    textTokens: number | undefined;\n\n    /**\n     * The number of reasoning tokens used.\n     */\n    reasoningTokens: number | undefined;\n  };\n\n  /**\n   * The total number of tokens used.\n   */\n  totalTokens: number | undefined;\n\n  /**\n   * @deprecated Use outputTokenDetails.reasoning instead.\n   */\n  reasoningTokens?: number | undefined;\n\n  /**\n   * @deprecated Use inputTokenDetails.cacheRead instead.\n   */\n  cachedInputTokens?: number | undefined;\n\n  /**\n   * Raw usage information from the provider.\n   *\n   * This is the usage information in the shape that the provider returns.\n   * It can include additional information that is not part of the standard usage information.\n   */\n  raw?: JSONObject;\n};\n\n/**\nRepresents the number of tokens used in an embedding.\n */\n// TODO replace with EmbeddingModelV3Usage\nexport type EmbeddingModelUsage = {\n  /**\nThe number of tokens used in the embedding.\n   */\n  tokens: number;\n};\n\nexport function asLanguageModelUsage(\n  usage: LanguageModelV3Usage,\n): LanguageModelUsage {\n  return {\n    inputTokens: usage.inputTokens.total,\n    inputTokenDetails: {\n      noCacheTokens: usage.inputTokens.noCache,\n      cacheReadTokens: usage.inputTokens.cacheRead,\n      cacheWriteTokens: usage.inputTokens.cacheWrite,\n    },\n    outputTokens: usage.outputTokens.total,\n    outputTokenDetails: {\n      textTokens: usage.outputTokens.text,\n      reasoningTokens: usage.outputTokens.reasoning,\n    },\n    totalTokens: addTokenCounts(\n      usage.inputTokens.total,\n      usage.outputTokens.total,\n    ),\n    raw: usage.raw,\n    reasoningTokens: usage.outputTokens.reasoning,\n    cachedInputTokens: usage.inputTokens.cacheRead,\n  };\n}\n\nexport function createNullLanguageModelUsage(): LanguageModelUsage {\n  return {\n    inputTokens: undefined,\n    inputTokenDetails: {\n      noCacheTokens: undefined,\n      cacheReadTokens: undefined,\n      cacheWriteTokens: undefined,\n    },\n    outputTokens: undefined,\n    outputTokenDetails: {\n      textTokens: undefined,\n      reasoningTokens: undefined,\n    },\n    totalTokens: undefined,\n    raw: undefined,\n  };\n}\n\nexport function addLanguageModelUsage(\n  usage1: LanguageModelUsage,\n  usage2: LanguageModelUsage,\n): LanguageModelUsage {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    inputTokenDetails: {\n      noCacheTokens: addTokenCounts(\n        usage1.inputTokenDetails?.noCacheTokens,\n        usage2.inputTokenDetails?.noCacheTokens,\n      ),\n      cacheReadTokens: addTokenCounts(\n        usage1.inputTokenDetails?.cacheReadTokens,\n        usage2.inputTokenDetails?.cacheReadTokens,\n      ),\n      cacheWriteTokens: addTokenCounts(\n        usage1.inputTokenDetails?.cacheWriteTokens,\n        usage2.inputTokenDetails?.cacheWriteTokens,\n      ),\n    },\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    outputTokenDetails: {\n      textTokens: addTokenCounts(\n        usage1.outputTokenDetails?.textTokens,\n        usage2.outputTokenDetails?.textTokens,\n      ),\n      reasoningTokens: addTokenCounts(\n        usage1.outputTokenDetails?.reasoningTokens,\n        usage2.outputTokenDetails?.reasoningTokens,\n      ),\n    },\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n    reasoningTokens: addTokenCounts(\n      usage1.reasoningTokens,\n      usage2.reasoningTokens,\n    ),\n    cachedInputTokens: addTokenCounts(\n      usage1.cachedInputTokens,\n      usage2.cachedInputTokens,\n    ),\n  };\n}\n\nfunction addTokenCounts(\n  tokenCount1: number | undefined,\n  tokenCount2: number | undefined,\n): number | undefined {\n  return tokenCount1 == null && tokenCount2 == null\n    ? undefined\n    : (tokenCount1 ?? 0) + (tokenCount2 ?? 0);\n}\n\n/**\nUsage information for an image model call.\n */\nexport type ImageModelUsage = ImageModelV3Usage;\n\nexport function addImageModelUsage(\n  usage1: ImageModelUsage,\n  usage2: ImageModelUsage,\n): ImageModelUsage {\n  return {\n    inputTokens: addTokenCounts(usage1.inputTokens, usage2.inputTokens),\n    outputTokens: addTokenCounts(usage1.outputTokens, usage2.outputTokens),\n    totalTokens: addTokenCounts(usage1.totalTokens, usage2.totalTokens),\n  };\n}\n"],"mappings":"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","names":["import_provider_utils","import_provider_utils","import_provider_utils","_a","download","import_provider_utils","_a","import_provider","download","_a","import_provider_utils","name","import_provider","import_provider_utils","import_v4","import_v4","import_v4","import_v4","import_v4","import_provider","name","marker","symbol","_a","import_provider","import_provider_utils","import_provider","name","marker","symbol","_a"]}